<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2016 v5.2.120
     Generated on:       5/17/2016 2:28 PM
     Generated by:       josh
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2016
#>

#region Call-run-tests_ps1
function Call-run-tests_ps1
{
	$moduleName = "PSIASTAND"
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$Global:testData = "$here\data"
	Import-Module "$here\..\$($moduleName)"
	Invoke-Pester
	Remove-Module $moduleName
	
}
#endregion

#region Call-codestatistics_tests_ps1
function Call-codestatistics_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$root = "$here\..\..\..\"
	
	
	Describe 'Code Statistics' {
	
	        $files = @(
	            Get-ChildItem "$root" -Include *ps1, *psm1
	            Get-ChildItem "$($root)functions" -Include *.ps1, *.psm1 -Recurse
	            Get-ChildItem "$($root)\tests" -Include *.ps1, *.psm1 -Recurse
	        )
	        $lineCount = 0
	        $NewlineCount = 0
	        $realline = 0
	        foreach ($file in $files) {
	            $lines = [System.IO.File]::ReadAllLines($file.FullName)
	            $lineCount += $lines.Count
	
	            for($i = 0; $i -lt $($lines.Count); $i++) {
	                if ($lines[$i] -match '^\s*$') {
	                    $NewlineCount ++
	                }
	                else{
	                    $realline ++
	                }
	            }
	        }
	
	        $testfiles = @(
	            Get-ChildItem "$($root)\tests" -Include *.ps1, *.psm1 -Recurse
	        )
	        $testlinecount = 0
	        $testnewlineCount = 0
	        $testrealline = 0
	        foreach ($file in $testfiles) {
	            $lines = [System.IO.File]::ReadAllLines($file.FullName)
	            $testlinecount += $lines.Count
	
	            for($i = 0; $i -lt $($lines.Count); $i++) {
	                if ($lines[$i] -match '^\s*$') {
	                    $testnewlineCount ++
	                }
	                else {
	                    $testrealline ++
	                }
	            }
	        }
	
	        $mainfiles = @(
	            Get-ChildItem "$root" -Include *ps1, *psm1
	            Get-ChildItem "$($root)functions" -Include *.ps1, *.psm1 -Recurse
	        )
	        $mainlinecount = 0
	        $mainnewlineCount = 0
	        $mainrealline = 0
	        foreach ($file in $mainfiles) {
	            $lines = [System.IO.File]::ReadAllLines($file.FullName)
	            $mainlinecount += $lines.Count
	
	            for($i = 0; $i -lt $($lines.Count); $i++) {
	                if ($lines[$i] -match '^\s*$') {
	                    $mainnewlineCount ++
	                }
	                else {
	                    $mainrealline ++
	                }
	            }
	        }
	    Context "Overall Code statistics" {
	
	        It "$($moduleName) Code base has $($lineCount) total lines" {
	            $true | Should Be $true
	        }
	
	        It "$($moduleName) Code base has $($realline) code lines" {
	            $true | Should Be $true
	        }
	
	        It "$($moduleName) Code base has $($NewlineCount) blank lines (Style Lines)" {
	            $true | Should Be $true
	        }
	    }
	
	    Context "Test Code statistics" {
	
	        It "$($moduleName) Code base has $($testlinecount) total lines" {
	            $true | Should Be $true
	        }
	
	        It "$($moduleName) Code base has $($testrealline) code lines" {
	            $true | Should Be $true
	        }
	
	        It "$($moduleName) Code base has $($testnewlineCount) blank lines (Style Lines)" {
	            $true | Should Be $true
	        }
	    }
	
	    Context "Main Code statistics" {
	
	        It "$($moduleName) Code base has $($mainlinecount) total lines" {
	            $true | Should Be $true
	        }
	
	        It "$($moduleName) Code base has $($mainrealline) code lines" {
	            $true | Should Be $true
	        }
	
	        It "$($moduleName) Code base has $($mainnewlineCount) blank lines (Style Lines)" {
	            $true | Should Be $true
	        }
	    }
	}
	
}
#endregion

#region Call-module_tests_ps1
function Call-module_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	
	$manifestPath = "$here\..\..\..\PSIASTAND.psd1"
	$changeLogPath = "$here\..\..\..\CHANGELOG.md"
	$guidCheck = '84be6f1a-8fb2-49c4-83be-9e2d0a7cbe4e'
	$moduleName = 'PSIASTAND'
	$tempPath = "H:\Powershell\Modules\Custom\NessusOpenPorts"
	$root = "$here\..\..\..\"
	
	# General manifest annd Changelog checks
	Describe -Tags 'VersionChecks' "Powershell IA Standard Library manifest and changelog" {
	    $Script:manifest - $null
	        It "has a valid manifest" {
	            {
	                $Script:manifest = Test-ModuleManifest -Path $manifestPath -ErrorAction Stop -WarningAction SilentlyContinue
	            } | Should Not Throw
	        }
	
	        It "has a valid name in the manifest" {
	            $Script:manifest.Name | Should Be $moduleName
	        }
	
	        It "has a valid guid in the manifest" {
	            $Script:manifest.Guid | Should Be $guidCheck
	        }
	
	        It "has a version listed in the manifest" {
	            $Script:manifest.Version -as [version] | Should Not BeNullOrEmpty
	        }
	
	        $Script:changeLogVersion = $null
	        It "has a valid version in the changelog" {
	            foreach ($line in (Get-Content $changeLogPath)) {
	                if ($line -match "^\D*(?<Version>(\d+\.){1,3}\d+)") {
	                    $Script:changeLogVersion = $matches.Version
	                    break
	                }
	            }
	            $Script:changeLogVersion | Should Not BeNullOrEmpty
	            $Script:changeLogVersion -as [Version] | Should Not BeNullOrEmpty
	        }
	
	        It "changelog and manifest versions are the same" {
	            $Script:changeLogVersion -as [Version] | Should Be ($Script:manifest.Version -as [Version])
	        }
	}
	
	# Module Checks
	
	# General env Checks
	
	# all commands are called from the safe command table
	#Import-Module "$((Get-Location).Path)\..\..\..\$($moduleName)"
	#Import-Module "$here\..\..\..\$($moduleName)"
	InModuleScope PSIASTAND {
	    Describe 'SafeCommands table' {
	        $path = $ExecutionContext.SessionState.Module.ModuleBase
	        $filesToCheck = Get-ChildItem -Path $path -Recurse -Include *.ps1,*.psm1 -Exclude *.Tests.ps1
	        $i = 0
	        $callsToSafeCommands = @(
	            foreach ($file in $filesToCheck) {
	                $i += 1
	                $tokens = $parseErrors = $null
	                $ast = [System.Management.Automation.Language.Parser]::ParseFile($file.FullName, [ref] $tokens, [ref] $parseErrors)
	                #Write-Host $ast
	                $filter = {
	                    $args[0] -is [System.Management.Automation.Language.CommandAst] -and
	                    $args[0].InvocationOperator -eq [System.Management.Automation.Language.TokenKind]::Ampersand -and
	                    $args[0].CommandElements[0] -is [System.Management.Automation.Language.IndexExpressionAst] -and
	                    $args[0].CommandElements[0].Target -is [System.Management.Automation.Language.VariableExpressionAst] -and
	                    $args[0].CommandElements[0].Target.VariablePath.UserPath -match '^(?:script:)?SafeCommands$'
	                }
	
	                $ast.FindAll($filter, $true)
	                #Write-Host $ast.FindAll($filter, $true) $i
	            }
	        )
	        #write-host $callsToSafeCommands.GetType()
	        $uniqueSafeCommands = $callsToSafeCommands | ForEach-Object { $_.CommandElements[0].Index.Value } | Select-Object -Unique
	        #write-host $callsToSafeCommands
	        $missingSafeCommands = $uniqueSafeCommands | Where-Object { -not $script:SafeCommands.ContainsKey($_) }
	
	        It 'The SafeCommands table contains all commands that are called from the module' {
	            $missingSafeCommands | Should Be $null
	        }
	    }
	}
	#Remove-Module $moduleName
	
	# Style Enforcement
	Describe 'Style rules' {
	
	  #  $files = @(
	   #     Get-ChildItem "$((Get-Location).Path)" -Include *ps1, *psm1
	    #    Get-ChildItem "$((Get-Location).Path)\functions" -Include *.ps1, *.psm1 -Recurse
	     #   Get-ChildItem "$((Get-Location).Path)\tests" -Include *.ps1, *.psm1 -Recurse
	    #)
	
	        $files = @(
	        Get-ChildItem "$root" -Include *ps1, *psm1
	        Get-ChildItem "$($root)functions" -Include *.ps1, *.psm1 -Recurse
	        Get-ChildItem "$($root)\tests" -Include *.ps1, *.psm1 -Recurse
	    )
	
	    It "$($moduleName) source files contain no trailing whitespace" {
	        $badLines = @(
	            foreach ($file in $files) {
	                $lines = [System.IO.File]::ReadAllLines($file.FullName)
	                $lineCount = $lines.Count
	
	                for ($i = 0; $i -lt $lineCount; $i++) {
	                    if ($lines[$i] -match '\s+$') {
	                        'File: {0}, Line: {1}' -f $file.FullName, ($i + 1)
	                    }
	                }
	            }
	        )
	
	        if ($badLines.Count -gt 0) {
	            Throw "The following $($badLines.Count) lines contain trailing whitespace: `r`n`r`n$($badLines -join '`r`n')"
	        }
	    }
	
	    It "$($moduleName) source files all end with a new line" {
	        $badFiles = @(
	            foreach ($file in $files) {
	                $string = [System.IO.File]::ReadAllText($file.FullName)
	                if ($string.Length -gt 0 -and $string[-1] -ne "`n") {
	                    $file.FullName
	                }
	            }
	        )
	
	        if ($badFiles.Count -gt 0) {
	            throw "The following files do not end with newline: `r`n`r`n$($badFiles -join '`r`n')"
	        }
	    }
	}
	
}
#endregion

#region Call-Invoke-NessusOpenPorts_tests_ps1
function Call-Invoke-NessusOpenPorts_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	
	$moduleName = 'PSIASTAND'
	$root = "$here\..\..\..\..\"
	
	# Module Checks
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	Describe "Invoke-NessusOpenPorts" {
	        Setup -File sample.nessus
	        Setup -File anothersample.nessus
	        Setup -File sample2.nessus
	        Setup -File sample3.nessus
	        Setup -File sample4.nessus
	
	        Setup -Dir Test
	
	        Set-Content -Path TestDrive:\sample.nessus -Value @'
<?xml version="1.0" ?>
<NessusClientData_v2>
	<Policy>
		<policyName>
		</policyName>
		<Preferences>
		</Preferences>
		<FamilySelection>
		</FamilySelection>
		<IndividualPluginSelection>
		</IndividualPluginSelection>
	</Policy>
	<Report name="Test Scan" xmlns:cm="http://wwww.nessus.org/cm">
		<ReportHost name="192.168.1.1">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.1</tag>
				<tag name="host-fq">randomhost1.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="2868" svc_name="npep-messaging?" protocol="tcp" severity="0" pluginID="25221" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>
  Process id   : 2544
  Executable   : /opt/vmware/sbin/vami-lighttpd
  Command line : /opt/vmware/sbin/vami-lighttpd -f /opt/vmware/etc/lighttpd/lighttpd.conf </plugin_output>

			</ReportItem>
			<ReportItem port="514" svc_name="syslog?" protocol="udp" severity="0" pluginID="25221" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>  Process id   : 2118
  Executable   : /sbin/syslog-ng
  Command line : /sbin/syslog-ng </plugin_output>

			</ReportItem>
		</ReportHost>
		<ReportHost name="192.168.1.2">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.2</tag>
				<tag name="host-fq">randomhost2.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="445" svc_name="cifs" protocol="tcp" severity="0" pluginID="34252" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;System&apos; is listening on this port (pid 4).</plugin_output>
			</ReportItem>

			<ReportItem port="49152" svc_name="dce-rpc" protocol="tcp" severity="0" pluginID="34252" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;wininit.exe&apos; is listening on this port (pid 488).</plugin_output>

			</ReportItem>

		</ReportHost>
		<ReportHost name="192.168.1.3">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.3</tag>
				<tag name="host-fq">randomhost3.randomsubdomain.randomdomain</tag>
			</HostProperties>
		</ReportHost>
	</Report>
</NessusClientData_v2>
'@
	        Set-Content -Path TestDrive:\sample2.nessus -Value @'
<?xml version="1.0" encoding="UTF-8"?>
<note>
	<to>Tove</to>
	<from>Jani</from>
	<heading>Reminder</heading>
	<body>Don't forget me this weekend!</body>
</note>
'@
	
	        Set-Content -Path TestDrive:\sample3.nessus -Value @'
<?xml version="1.0" ?>
<NessusClientData_v2>
	<Policy>
		<policyName>
		</policyName>
		<Preferences>
		</Preferences>
		<FamilySelection>
		</FamilySelection>
		<IndividualPluginSelection>
		</IndividualPluginSelection>
	</Policy>
	<Report name="Test Scan" xmlns:cm="http://wwww.nessus.org/cm">
		<ReportHost name="192.168.1.1">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.1</tag>
				<tag name="host-fq">randomhost1.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="2868" svc_name="npep-messaging?" protocol="tcp" severity="0" pluginID="34252" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>
  Process id   : 2544
  Executable   : /opt/vmware/sbin/vami-lighttpd
  Command line : /opt/vmware/sbin/vami-lighttpd -f /opt/vmware/etc/lighttpd/lighttpd.conf </plugin_output>

			</ReportItem>
			<ReportItem port="514" svc_name="syslog?" protocol="udp" severity="0" pluginID="34252" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>  Process id   : 2118
  Executable   : /sbin/syslog-ng
  Command line : /sbin/syslog-ng </plugin_output>

			</ReportItem>
		</ReportHost>
		<ReportHost name="192.168.1.2">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.2</tag>
				<tag name="host-fq">randomhost2.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="445" svc_name="cifs" protocol="tcp" severity="0" pluginID="11111" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;System&apos; is listening on this port (pid 4).</plugin_output>
			</ReportItem>

			<ReportItem port="49152" svc_name="dce-rpc" protocol="tcp" severity="0" pluginID="11111" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;wininit.exe&apos; is listening on this port (pid 488).</plugin_output>

			</ReportItem>

		</ReportHost>
	</Report>
</NessusClientData_v2>
'@
	
	        Set-Content -Path TestDrive:\sample4.nessus -Value  @'
<?xml version="1.0" ?>
<NessusClientData_v2>
	<Policy>
		<policyName>
		</policyName>
		<Preferences>
		</Preferences>
		<FamilySelection>
		</FamilySelection>
		<IndividualPluginSelection>
		</IndividualPluginSelection>
	</Policy>
	<Report name="Test Scan" xmlns:cm="http://wwww.nessus.org/cm">
		<ReportHost name="192.168.1.1">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.1</tag>
				<tag name="host-fq">randomhost1.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="2868" svc_name="npep-messaging?" protocol="tcp" severity="0" pluginID="25221" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>
  Process id   : 2544
  Executable   : /opt/vmware/sbin/vami-lighttpd
  Command line : /opt/vmware/sbin/vami-lighttpd -f /opt/vmware/etc/lighttpd/lighttpd.conf </plugin_output>

			</ReportItem>
			<ReportItem port="514" svc_name="syslog?" protocol="udp" severity="0" pluginID="25221" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>  Process id   : 2118
  Executable   : /sbin/syslog-ng
  Command line : /sbin/syslog-ng </plugin_output>

			</ReportItem>
		</ReportHost>
		<ReportHost name="192.168.1.2">
			<HostProperties>
				<tag name="Credentialed_Scan">false</tag>
				<tag name="host-ip">192.168.1.2</tag>
				<tag name="host-fq">randomhost2.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="445" svc_name="cifs" protocol="tcp" severity="0" pluginID="34252" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;System&apos; is listening on this port (pid 4).</plugin_output>
			</ReportItem>

			<ReportItem port="49152" svc_name="dce-rpc" protocol="tcp" severity="0" pluginID="34252" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;wininit.exe&apos; is listening on this port (pid 488).</plugin_output>

			</ReportItem>

		</ReportHost>
	</Report>
</NessusClientData_v2>
'@
	    $dateObject = new-object system.globalization.datetimeformatinfo
	    $date = Get-Date
	
	    It "[End Block] should create a csv export" {
	        Invoke-NessusOpenPorts -Nessus TestDrive:\sample.nessus -packagename "Test" -outPut TestDrive:\
	        $report = Get-Item -Path "TestDrive:\Test_OpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	        $report.name | Should Be "Test_OpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	    }
	
	    It "[End Block] csv should have 4 total detected open ports" {
	        Invoke-NessusOpenPorts -Nessus TestDrive:\sample.nessus -packagename "Test" -outPut TestDrive:\
	        $report = Import-Csv -Path "TestDrive:\Test_OpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	        $report.Count | Should Be 4
	    }
	
	    It "[End Block] csv should find 2 plugins with ID 25221 (linux)" {
	        Invoke-NessusOpenPorts -Nessus TestDrive:\sample.nessus -packagename "Test" -outPut TestDrive:\
	        $report = Import-Csv -Path "TestDrive:\Test_OpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	        $test = $report | Where-Object{$_.Plugin -eq 25221}
	        $test.Count | Should Be 2
	    }
	
	    It "[End Block] csv should find 2 plugins with ID 34252 (windows)" {
	        Invoke-NessusOpenPorts -Nessus TestDrive:\sample.nessus -packagename "Test" -outPut TestDrive:\
	        $report = Import-Csv -Path "TestDrive:\Test_OpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	        $test = $report | Where-Object{$_.Plugin -eq 34252}
	        $test.Count | Should Be 2
	    }
	
	    It "[End Block] csv should find 2 unique hosts" {
	        Invoke-NessusOpenPorts -Nessus TestDrive:\sample.nessus -packagename "Test" -outPut TestDrive:\
	        $report = Import-Csv -Path "TestDrive:\Test_OpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	        $test = $report | %{$_.IP} | Get-Unique
	        $test.Count | Should Be 2
	    }
	
	    It "[End Block] should create a no open ports report" {
	        Invoke-NessusOpenPorts -Nessus TestDrive:\sample.nessus -packagename "Test" -outPut TestDrive:\
	        $report = Get-Item -Path "TestDrive:\Test_NoOpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	        $report.name | Should Be "Test_NoOpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	    }
	
	    It "[End Block] should have 1 system in no open ports report" {
	        Invoke-NessusOpenPorts -Nessus TestDrive:\sample.nessus -packagename "Test" -outPut TestDrive:\
	        $report = Import-Csv -Path "TestDrive:\Test_NoOpenPorts_$($date.Day)$($dateObject.GetMonthName($date.Month))$($date.Year).csv"
	        $report.("#text") | Should Be "192.168.1.3"
	    }
	
	    It "[Begin Block] should throw unable to create at provided path" {
	        {Invoke-NessusOpenPorts -Nessus TestDrive:\sample.nessus -packagename "Test" -outPut TempDrive:\} | Should Throw "unable to create at provided path: TempDrive:\"
	    }
	
	    It "[Begin Block] should throw path not found" {
	        {Invoke-NessusOpenPorts -Nessus TempDrive:\sample.nessus -packagename "Test" -outPut TestDrive:\} | Should Throw "path not found"
	    }
	
	    It "[Begin Block] should throw path not found (Recursive)" {
	        {Invoke-NessusOpenPorts -Nessus TempDrive:\ -packagename "Test" -outPut TestDrive:\ -recursive} | Should Throw "path not found"
	    }
	
	    It "[Begin Block] should throw No Nessus Files Found" {
	        {Invoke-NessusOpenPorts -Nessus TestDrive:\Test -packagename "Test" -outPut TestDrive:\ -recursive} | Should Throw "No Nessus Files Found"
	    }
	
	    It "[Process Block] should throw Not an XML Document" {
	        {Invoke-NessusOpenPorts -Nessus TestDrive:\anothersample.nessus -packagename "Test" -outPut TestDrive:\} | Should Throw "$((Get-Item TestDrive:\anothersample.nessus).name) Not an XML Document"
	    }
	
	    It "[Process Block] should throw Not a Nessus File" {
	        {Invoke-NessusOpenPorts -Nessus TestDrive:\sample2.nessus -packagename "Test" -outPut TestDrive:\} | Should Throw "$((Get-Item TestDrive:\sample2.nessus).name) Not a Nessus File"
	    }
	
	    It "[Process Block] should throw Not a credentialed Scan" {
	        {Invoke-NessusOpenPorts -Nessus TestDrive:\sample4.nessus -packagename "Test" -outPut TestDrive:\} | Should Throw "$((Get-Item TestDrive:\sample4.nessus).name) Not a credentialed Scan"
	    }
	}
	#Remove-Module $moduleName
	
	#Invoke-NessusOpenPorts
	
}
#endregion

#region Call-Export-CombinedReports_tests_ps1
function Call-Export-CombinedReports_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Export-CombinedReports PS: $PSVersion" {
	
	    Setup -Dir nofiles
	    Setup -Dir results
	    Setup -Dir single
	    Setup -Dir resultsxlsx
	
	    Copy-Item "$Global:testData\CKL\CKLv1\sample.ckl" "TestDrive:\sample.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv1\sample.ckl" "TestDrive:\single\sample.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv2\sampleV2.ckl" "TestDrive:\sampleV2.ckl"
	    Copy-Item "$Global:testData\Nessus_Scans\Nessus_Sample_Linux.nessus" "TestDrive:\Nessus_Sample_Linux.nessus"
	    Copy-Item "$Global:testData\Nessus_Scans\Nessus_Sample_Windows.nessus" "TestDrive:\Nessus_Sample_Windows.nessus"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No output path given'" {
	            {Export-CombinedReports} | Should Throw "No output path given"
	        }
	
	        It "Should Throw 'No paths defined'" {
	            {Export-CombinedReports -Output "TestDrive:\"} | Should Throw "No paths defined"
	        }
	
	        It "Should Throw 'CKL path does not exist'" {
	            {Export-CombinedReports -CKLFILES "TestDrive:\fake" -Output "TestDrive:\"} | Should Throw "CKL path does not exist"
	        }
	
	        It "Should Throw 'NESSUS path does not exist'" {
	            {Export-CombinedReports -NESSUS "TestDrive:\fake" -Output "TestDrive:\"} | Should Throw "NESSUS path does not exist"
	        }
	
	        It "Should Throw 'No CKL Files Found'" {
	            {Export-CombinedReports -CKLFILES "TestDrive:\nofiles" -Output "TestDrive:\"} | Should Throw "No CKL Files Found"
	        }
	
	        It "Should Throw 'No Nessus Files Found'" {
	            {Export-CombinedReports -NESSUS "TestDrive:\nofiles" -Output "TestDrive:\"} | Should Throw "No Nessus Files Found"
	        }
	
	        It "Should Throw 'CKL file failed to process'" {
	            {Export-CombinedReports -CKLFILES "TestDrive:\" -Output "TestDrive:\results"} | Should Throw "$($(Get-ChildItem -Path "TestDrive:\sampleV2.ckl").name) CKL file failed to process"
	        }
	
	        It "Should Create 2 (csv) files" {
	            Remove-Item -Path "TestDrive:\sampleV2.ckl"
	            Export-CombinedReports -CKLFILES $TestDrive -NESSUS "$TestDrive" -Output "TestDrive:\results" -name "Sample"
	            $reportfile = Get-ChildItem -Path "TestDrive:\results"
	            $reportfile.count | Should Be 2
	            $reportfile[0].extension | should be ".csv"
	        }
	
	        It "Should Create 2 (xlsx) files" {
	            Export-CombinedReports -CKLFILES $TestDrive -NESSUS "$TestDrive" -Output "TestDrive:\resultsxlsx" -name "Sample" -xlsx
	            $reportfile = Get-ChildItem -Path "TestDrive:\resultsxlsx"
	            $reportfile.count | Should Be 2
	            $reportfile[0].extension | should be ".xlsx"
	        }
	
	    }
	}
	
}
#endregion

#region Call-Export-RiskElements_tests_ps1
function Call-Export-RiskElements_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Export-RiskElements PS: $PSVersion" {
	
	    Setup -Dir CKL
	    Setup -Dir Nessus
	    Setup -Dir Controls
	    Setup -Dir Empty
	    Setup -Dir results
	
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample04_Win2008R2MS.ckl" "TestDrive:\CKL\Sample04_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample05_Win2008R2MS.ckl" "TestDrive:\CKL\Sample05_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\Controls\Sample_DODI_8500_2_Controls.xlsx" "TestDrive:\Controls\Sample_DODI_8500_2_Controls.xlsx"
	    Copy-Item "$Global:testData\Nessus_Scans\Nessus_Sample_Linux.nessus" "TestDrive:\Nessus\Nessus_Sample_Linux.nessus"
	    Copy-Item "$Global:testData\Nessus_Scans\Nessus_Sample_Windows.nessus" "TestDrive:\Nessus\Nessus_Windows.nessus"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No Name was provided'" {
	            {Export-RiskElements} | Should Throw "No Name was provided"
	        }
	
	        It "Should Throw 'No output path given'" {
	            {Export-RiskElements -name "APP_Owner"} | Should Throw "No output path given"
	        }
	
	        It "Should Throw 'Nothing to process'" {
	            {Export-RiskElements -name "APP_Owner" -Out "$($TestDrive)\Out"} | Should Throw "Nothing to process"
	        }
	
	        It "Should Throw 'Both DIACAP and RMF Specified. Please select DIACAP OR RMF" {
	            {Export-RiskElements -DIACAP "$($TestDrive)\Controls\Sample_DODI_8500_2_Controls.xlsx" -RMF "$($TestDrive)\Controls\Sample_DODI_8500_2_Controls.xlsx" -name "APP_Owner" -Out "$($TestDrive)\Out"} | Should Throw "Both DIACAP and RMF Specified. Please select DIACAP OR RMF"
	        }
	
	        It "Should Throw 'No Files Found'" {
	            {Export-RiskElements -CKLFILES "$($TestDrive)\Empty" -name "APP_Owner" -Out "$($TestDrive)\Out"} | Should Throw "No CKL files found"
	            {Export-RiskElements -Nessus "$($TestDrive)\Empty" -name "APP_Owner" -Out "$($TestDrive)\Out"} | Should Throw "No NESSUS files found"
	
	        }
	
	        It "Should Throw 'Path Not Found'" {
	             {Export-RiskElements -CKLFILES "$($TestDrive)\test" -name "APP_Owner" -Out "$($TestDrive)\Out"} | Should Throw "CKL Path not found"
	             {Export-RiskElements -NESSUS "$($TestDrive)\test" -name "APP_Owner" -Out "$($TestDrive)\Out"} | Should Throw "Nessus Path not found"
	        }
	
	        It "Should output risk elements xlsx" {
	            Export-RiskElements -CKLFILES "$($TestDrive)\CKL" -NESSUS "$($TestDrive)\Nessus" -DIACAP "$($TestDrive)\Controls\Sample_DODI_8500_2_Controls.xlsx" -Name "APP_OWNER" -Output "$($TestDrive)\results" -mergecontrol
	            $filetest = Get-Item -Path "$($TestDrive)\results\APP_OWNER_Risk.xlsx"
	            $filetest.extension | Should Be ".xlsx"
	        }
	    }
	}
	
}
#endregion

#region Call-Get-Compliance_tests_ps1
function Call-Get-Compliance_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Get-Compliance PS: $PSVersion" {
	
	    Setup -Dir CKL
	    Setup -Dir results
	
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample04_Win2008R2MS.ckl" "TestDrive:\CKL\Sample04_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample05_Win2008R2MS.ckl" "TestDrive:\CKL\Sample05_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample.ckl" "TestDrive:\CKL\Sample.ckl"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No CKL Path Provided'" {
	            {Get-Compliance} | Should Throw "No CKL Path Provided"
	        }
	
	        It "Should Throw 'No Output folder provided'" {
	            {Get-Compliance -ckl "FAKE"} | Should Throw "No Output folder provided"
	        }
	
	        It "Should Throw 'No Name provided'" {
	            {Get-Compliance -ckl "FAKE" -Output "FAKE"} | Should Throw "No Name provided"
	        }
	
	        It "Should Create a Compliance Report" {
	            Get-Compliance -ckl "$($testDrive)\CKL" -output "$($testDrive)\results" -name "APP_OWNER"
	            $xlsx = Import-XLSX -path "$($testDrive)\results\APP_OWNER_STIG_Compliance_Report.xlsx"
	            $headers = $($xlsx | Get-Member -MemberType NoteProperty).Name
	            $($headers -contains "STIG" -and $headers -contains "Systems" -and $headers -contains "System_Count" -and $headers -contains "High_Count_Finding" -and $headers -contains "MED_Count_Finding" -and $headers -contains "LOW_Count_Finding" -and $headers -contains "High_Total" -and $headers -contains "MED_Total" -and $headers -contains "LOW_Total" -and $headers -contains "Total_Checks" -and $headers -contains "Compliance_Percentage" -and $headers -contains "Compliant") | Should Be $true
	        }
	    }
	}
	
}
#endregion

#region Call-Update-Controls_tests_ps1
function Call-Update-Controls_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Update-Controls PS: $PSVersion" {
	
	    Setup -Dir CKL
	    Setup -Dir Controls
	    Setup -Dir results
	
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample04_Win2008R2MS.ckl" "TestDrive:\CKL\Sample04_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample05_Win2008R2MS.ckl" "TestDrive:\CKL\Sample05_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\Controls\Sample_DODI_8500_2_Controls.xlsx" "TestDrive:\Controls\Sample_DODI_8500_2_Controls.xlsx"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No path Provided'" {
	            {Update-Controls} | Should Throw "No path Provided"
	        }
	
	        It "Should Throw 'No CKL Path Provided'" {
	            {Update-Controls -path "FAKE"} | Should Throw "No CKL Path Provided"
	        }
	
	        It "Should Throw 'No Output folder provided'" {
	            {Update-Controls -path "FAKE" -ckl "FAKE"} | Should Throw "No Output folder provided"
	        }
	
	        It "Should Throw 'No Name provided'" {
	            {Update-Controls -path "FAKE" -ckl "FAKE" -output "FAKE"} | Should Throw "No Name provided"
	        }
	
	        It "Should Throw 'No report type selected'" {
	            {Update-Controls -path "FAKE" -ckl "FAKE" -output "FAKE" -name "FAKE"} | Should Throw "No report type selected"
	        }
	
	        It "Should Throw 'Both DIACAP and RMF Selected'" {
	            {Update-Controls -path "$($testDrive)\Sample_DODI_8500_2_Controls.xlsx" -ckl "FAKE" -output "FAKE" -name "FAKE" -diacap -rmf} | Should Throw "Both DIACAP and RMF Selected"
	        }
	
	        It "Should Merge the Failed STIG Items that Map to IA Controls (Requires Import-XLSX, Import-DIACAP)" {
	            Update-Controls -path "$($testDrive)\controls\Sample_DODI_8500_2_Controls.xlsx" -ckl "$($testDrive)\CKL" -output "$($testDrive)\results" -name "APP_OWNER" -diacap
	            $xlsx = Import-XLSX -path "$($testDrive)\results\APP_OWNER_8500.2_Controls.xlsx"
	            $controls = Import-DIACAP -doc $xlsx
	            $($controls | Where-Object {$_."Control Number" -match "IAIA-1" -and $_."Assessment Status" -match "Fail"}).count | Should Be 12
	        }
	    }
	}
	
}
#endregion

#region Call-Update-TestPlan_tests_ps1
function Call-Update-TestPlan_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Update-TestPlan PS: $PSVersion" {
	
	    Setup -Dir CKL
	    SetUp -Dir testplan
	    Setup -Dir results
	    Setup -Dir fake
	
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample04_Win2008R2MS.ckl" "TestDrive:\CKL\Sample04_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample05_Win2008R2MS.ckl" "TestDrive:\CKL\Sample05_Win2008R2MS.ckl"
	    #Copy-Item "$Global:testData\CKL\CKLv1\Sample.ckl" "TestDrive:\CKL\Sample.ckl"
	    Copy-Item "$Global:testData\MCCAST_TestPlan\MCCAST_TestPlan.xlsx" "TestDrive:\testplan\MCCAST_TestPlan.xlsx"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No CKL Path provided'" {
	            {Update-TestPlan} | Should Throw "No CKL Path provided"
	        }
	
	        It "Should Throw 'No Testplan provided'" {
	            {Update-TestPlan -ckl "$($testDrive)\CKL"} | Should Throw "No Testplan provided"
	        }
	
	        It "Should Throw 'No Output folder provided'" {
	            {Update-TestPlan -ckl "$($testDrive)\CKL" -testplan "$($testDrive)\testplan\MCCAST_TestPlan.xlsx"} | Should Throw "No Output folder provided"
	        }
	
	        It "Should Throw 'No Name provided'" {
	            {Update-TestPlan -ckl "$($testDrive)\CKL" -testplan "$($testDrive)\testplan\MCCAST_TestPlan.xlsx" -output "$($testDrive)\results"} | Should Throw "No Name provided"
	        }
	
	        It "Should Throw 'CKL Path not found'" {
	            {Update-TestPlan -ckl "$($testDrive)\blue" -testplan "$($testDrive)\testplan\MCCAST_TestPlan.xlsx" -output "$($testDrive)\results" -name "APP_OWNER"} | Should Throw "CKL Path not found"
	        }
	
	        It "Should Throw 'No CKL files found'" {
	            {Update-TestPlan -ckl "$($testDrive)\fake" -testplan "$($testDrive)\testplan\MCCAST_TestPlan.xlsx" -output "$($testDrive)\results" -name "APP_OWNER"} | Should Throw "No CKL files found"
	        }
	
	        It "Should Throw 'Testplan not found'" {
	            {Update-TestPlan -ckl "$($testDrive)\CKL" -testplan "$($testDrive)\testplan1\MCCAST_TestPlan.xlsx" -output "$($testDrive)\results" -name "APP_OWNER"} | Should Throw "Testplan not found"
	        }
	
	        It "Should update the testplan (Requires Import-XLSX)" {
	            Update-TestPlan -ckl "$($testDrive)\CKL" -testplan "$($testDrive)\testplan\MCCAST_TestPlan.xlsx" -output "$($testDrive)\results" -name "APP_OWNER"
	            $xlsx = Import-XLSX -path "$($testDrive)\results\APP_OWNER_TestPlan.xlsx"
	            $results = $xlsx | Where-Object {$_."Implementation Result" -notmatch "^\s*$"}
	            $results.count | Should Be 662
	        }
	    }
	}
	
}
#endregion

#region Call-Invoke-RiskAlgorithm_tests_ps1
function Call-Invoke-RiskAlgorithm_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Invoke-RiskAlgorithm PS: $PSVersion" {
	
	    Setup -Dir Risk
	    SetUp -Dir Map
	    Setup -Dir results
	    Setup -Dir fake
	
	    Copy-Item "$Global:testData\Mock_APP\APP_OWNER_Risk.xlsx" "TestDrive:\Risk\APP_OWNER_Risk.xlsx"
	    Copy-Item "$Global:testData\Mock_APP\APP_OWNER_Risk_ERROR.xlsx" "TestDrive:\Risk\APP_OWNER_Risk_ERROR.xlsx"
	    Copy-Item "$Global:testData\Risk_Mapping\Sample_Risk_Map.xlsx" "TestDrive:\Map\Sample_Risk_Map.xlsx"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No RISK Path provided'" {
	            {Invoke-RiskAlgorithm} | Should Throw "No RISK Path provided"
	        }
	
	        It "Should Throw 'No MAP provided'" {
	            {Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk.xlsx"} | Should Throw "No MAP provided"
	        }
	
	        It "Should Throw 'No Documentation level provided'" {
	            {Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk.xlsx" -map "$($testDrive)\map\Sample_Risk_Map.xlsx"} | Should Throw "No Documentation level provided"
	        }
	
	        It "Should Throw 'No System Knowledge level provided'" {
	            {Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk.xlsx" -map "$($testDrive)\map\Sample_Risk_Map.xlsx" -docrisk 45} | Should Throw "No System Knowledge level provided"
	        }
	
	        It "Should Throw 'No Output folder provided'" {
	            {Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk.xlsx" -map "$($testDrive)\map\Sample_Risk_Map.xlsx" -docrisk 45 -sysrisk 45} | Should Throw "No Output folder provided"
	        }
	
	        It "Should Throw 'No Name provided'" {
	            {Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk.xlsx" -map "$($testDrive)\map\Sample_Risk_Map.xlsx" -docrisk 45 -sysrisk 45 -output "$($testDrive)\results"} | Should Throw "No Name provided"
	        }
	
	        It "Should Throw 'System Knowledge risk or Documentation risk falls outside of 0-100'" {
	            {Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk.xlsx" -map "$($testDrive)\map\Sample_Risk_Map.xlsx" -docrisk -100 -sysrisk 45 -output "$($testDrive)\results" -name "APP_OWNER"} | Should Throw "System Knowledge risk or Documentation risk falls outside of 0-100"
	            {Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk.xlsx" -map "$($testDrive)\map\Sample_Risk_Map.xlsx" -docrisk 45 -sysrisk 101 -output "$($testDrive)\results" -name "APP_OWNER"} | Should Throw "System Knowledge risk or Documentation risk falls outside of 0-100"
	        }
	
	        It "Should Throw 'No Mapping element is not mapped'" {
	            {Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk_ERROR.xlsx" -map "$($testDrive)\map\Sample_Risk_Map.xlsx" -docrisk 45 -sysrisk 45 -output "$($testDrive)\results" -name "APP_OWNER"} | Should Throw "No Mapping is not mapped"
	        }
	
	        It "Should create a risk algorithm report (Requires Import-XLSX, Get-Average)" {
	            Invoke-RiskAlgorithm -risk "$($testDrive)\risk\APP_OWNER_Risk.xlsx" -map "$($testDrive)\map\Sample_Risk_Map.xlsx" -docrisk 45 -sysrisk 45 -output "$($testDrive)\results" -name "APP_OWNER"
	            $results = Import-XLSX -path "$($testDrive)\results\APP_OWNER_Risk_Algorithm_Report.xlsx"
	            $results."Risk Level" | Should Be "MEDIUM"
	        }
	    }
	}
	
}
#endregion

#region Call-Export-CKL_tests_ps1
function Call-Export-CKL_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Export-CKL PS: $PSVersion" {
	
	    Setup -Dir results
	    Setup -Dir recursion
	    Setup -Dir nofiles
	
	    Copy-Item "$here\Sample_Win2008R2MS.csv" "TestDrive:\Sample_Win2008R2MS1.csv"
	    Copy-Item "$here\Sample_Win2008R2MS.xlsx" "TestDrive:\Sample_Win2008R2MS2.xlsx"
	    Copy-Item "$here\Sample_Win2008R2MS.csv" "TestDrive:\recursion\Sample_Win2008R2MS3.csv"
	    Copy-Item "$here\Sample_Win2008R2MS.xlsx" "TestDrive:\recursion\Sample_Win2008R2MS4.xlsx"
	
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No Path provided'" {
	            {Export-CKL} | Should Throw "No Path provided"
	        }
	
	        It "Should Throw 'No output path provided'" {
	            {Export-CKL -Path "TestDrive:\"} | Should Throw "No output path provided"
	        }
	
	        It "Should Throw 'No Version provided'" {
	            {Export-CKL -Path "TestDrive:\" -Out "TestDrive:\results"} | Should Throw "No Version provided"
	        }
	
	        It "Should Throw 'No Files Found'" {
	            {Export-CKL -Path "TestDrive:\nofiles" -Out "TestDrive:\results" -version 1} | Should Throw "No Files Found"
	        }
	
	        It "Should output 2 files (No Recursion)'" {
	            Export-CKL -Path $TestDrive -Out "$($TestDrive)\results" -version 1
	            $files = Get-ChildItem -Path "TestDrive:\results" -Filter "*.ckl"
	            $files.count | Should Be 2
	        }
	
	        It "Should output 4 files (Recursion)'" {
	            Export-CKL -Path $TestDrive -Out "$($TestDrive)\results" -version 1 -Recursive
	            $files = Get-ChildItem -Path "TestDrive:\results" -Filter "*.ckl"
	            $files.count | Should Be 4
	        }
	
	        It "Should create 4 Version 1 CKL files (Requires Import-XML, Import-CKL)" {
	            $files = Get-ChildItem -Path "TestDrive:\results" -Filter "*.ckl"
	            $files.count | Should Be 4
	            foreach($file in $files){
	                $xml = Import-XML -fileobj $file
	                $ckl = Import-CKL -doc $xml
	                $ckl[0].StigViewer_Version | Should Be 1
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Add-PivotChart_tests_ps1
function Call-Add-PivotChart_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Add-PivotChart PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should add a pivot chart' {
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
	            Get-ChildItem C:\Windows |
	                Where {-not $_.PSIsContainer} |
	                Export-XLSX -Path $NewXLSXFile -PivotRows Extension -PivotValues Length
	
	            Add-PivotChart -Path $NewXLSXFile -ChartType Pie3D
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            $WorkSheet = @( $Excel | Get-Worksheet -Name PivotTable1 )
	
	            $WorkSheet[0].Drawings[0].ChartType.ToString() | Should be 'Pie3D'
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Add-PivotTable_tests_ps1
function Call-Add-PivotTable_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Add-PivotTable PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should add a pivot table to an existing xlsx' {
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
	            Get-ChildItem C:\Windows |
	                Where {-not $_.PSIsContainer} |
	                Export-XLSX -Path $NewXLSXFile
	
	            Add-PivotTable -Path $NewXLSXFile -WorkSheetName 'Worksheet1' -PivotTableWorksheetName 'PivotTable2' -PivotRows Extension -PivotValues Length
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            $WorkSheet = @( $Excel | Get-Worksheet -Name PivotTable2 )
	
	            $worksheet[0].PivotTables[0].RowFields[0].Name | Should be Extension
	
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	        }
	        It 'Should add a pivot chart if specified' {
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
	            Get-ChildItem C:\Windows |
	                Where {-not $_.PSIsContainer} |
	                Export-XLSX -Path $NewXLSXFile
	
	            Add-PivotTable -Path $NewXLSXFile -WorkSheetName 'Worksheet1' -PivotTableWorksheetName 'PivotTable2' -PivotRows Extension -PivotValues Length -ChartType Area3D
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            $WorkSheet = @( $Excel | Get-Worksheet -Name PivotTable2 )
	
	            $WorkSheet[0].Drawings[0].ChartType.ToString() | Should be 'Area3D'
	
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Add-Table_tests_ps1
function Call-Add-Table_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Add-Table PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should add a table to an existing xlsx' {
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
		    $TableName = "TestTable"
		    $WorkSheetName = 'Worksheet1'
	
	            Get-ChildItem C:\Windows |
	                Where {-not $_.PSIsContainer} |
	                Export-XLSX -Path $NewXLSXFile
	
	            Add-Table -Path $NewXLSXFile -WorkSheetName $WorkSheetName -TableStyle Medium10 -TableName $TableName
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            $WorkSheet = @( $Excel | Get-Worksheet -Name $WorkSheetName )
	
	            $Table = $Worksheet[0].Tables[0]
		    $Table.Name | Should be $TableName
		    $Table.Worksheet | Should be $WorkSheetName
		    $Table.StyleName | Should be 'TableStyleMedium10'
	
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	        }
		It 'Should create a table in an xlsx' {
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
		    $WorkSheetName = 'Worksheet1'
	
	            Get-ChildItem C:\Windows |
	                Where {-not $_.PSIsContainer} |
	                Export-XLSX -Path $NewXLSXFile -WorkSheetName $WorkSheetName -Table -TableStyle Medium10 -AutoFit
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            $WorkSheet = @( $Excel | Get-Worksheet -Name $WorkSheetName )
	
	            $Table = $Worksheet[0].Tables[0]
		    $Table.Name | Should be $WorkSheetName
		    $Table.Worksheet | Should be $WorkSheetName
		    $Table.StyleName | Should be 'TableStyleMedium10'
	
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Close-Excel_tests_ps1
function Call-Close-Excel_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Close-Excel PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should close an excelpackage' {
	            $Excel = New-Excel -Path $NewXLSXFile
	            $File = $Excel.File
	            $Excel | Close-Excel
	            $Excel.File -like $File | Should be $False
	        }
	
	        It 'should save when requested' {
	            Remove-Item $NewXLSXFile -Force -ErrorAction SilentlyContinue
	            $Excel = New-Excel -Path $NewXLSXFile
	            [void]$Excel.Workbook.Worksheets.Add(1)
	            $Excel | Close-Excel -Save
	            Test-Path $NewXLSXFile | Should be $True
	        }
	
	        It 'should save as a specified path' {
	            $Excel = New-Excel -Path $NewXLSXFile
	            $Excel | Close-Excel -Path "$NewXLSXFile`2"
	            Test-Path "$NewXLSXFile`2" | Should be $True
	            Remove-Item "$NewXLSXFile`2" -Force -ErrorAction SilentlyContinue
	        }
	    }
	}
	
	
	
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Export-XLSX_tests_ps1
function Call-Export-XLSX_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	
	Describe "Export-XLSX PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should create a file' {
	            $Files | Export-XLSX -Path $NewXLSXFile
	            Test-Path $NewXLSXFile | Should Be $True
	        }
	
	        It 'should add the correct number of rows' {
	            $ExportedData = Import-XLSX -Path $NewXLSXFile
	            $Files.Count | Should be $ExportedData.count
	        }
	
	        It 'should append to a file' {
	            $Files | Export-XLSX -Path $NewXLSXFile -Append
	            Test-Path $NewXLSXFile | Should Be $True
	        }
	
	        It 'should append the correct number of rows' {
	            $ExportedData = Import-XLSX -Path $NewXLSXFile
	            ( $Files.Count * 2 ) | Should be $ExportedData.count
	        }
	
	        It 'should build pivot tables' {
	
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
	            Get-ChildItem C:\Windows |
	                Where {-not $_.PSIsContainer} |
	                Export-XLSX -Path $NewXLSXFile -PivotRows Extension -PivotValues Length
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            $WorkSheet = @( $Excel | Get-Worksheet -Name PivotTable1 )
	            $worksheet[0].PivotTables[0].RowFields[0].Name | Should be Extension
	
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
	        }
	
	        It 'should build pivot charts' {
	
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	
	            Get-ChildItem C:\Windows |
	                Where {-not $_.PSIsContainer} |
	                Export-XLSX -Path $NewXLSXFile -PivotRows Extension -PivotValues Length -ChartType Pie
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            $WorkSheet = @( $Excel | Get-Worksheet -Name PivotTable1 )
	            $WorkSheet[0].Drawings[0].ChartType.ToString() | Should be 'Pie'
	
	            Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Format-Cell_tests_ps1
function Call-Format-Cell_tests_ps1
{
	 #Describe "Format-Cell PS$PSVersion" {}
	
	 <#
	Describe "Verb-Noun PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should do something' {
	            # $NewXLSXFile - Remove, create, and remove this as needed
	            # $ExistingXLSXFile - Use this to verify reads if desired, but other tests use it.  Please do no modify or remove.
	
	        }
	    }
	}
	#>
	
}
#endregion

#region Call-Get-CellValue_tests_ps1
function Call-Get-CellValue_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Get-CellValue PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should get a value from an Excel object' {
	            Copy-Item -Path $ExistingXLSXFile -Destination $NewXLSXFile -Force
	
	            $Excel = New-Excel -Path $NewXLSXFile
	
	            $Result = @($Excel | Get-CellValue -Coordinates "A2:A3")
	            $Result[0].Name | Should be 'Prop1'
	            $Result[1].Name | Should be 'Prop2'
	            $Result.Count | Should be 2
	        }
	        It 'Should get a value from an Excel file' {
	            Copy-Item -Path $ExistingXLSXFile -Destination $NewXLSXFile -Force
	
	            $Result = @( Get-CellValue -Path $NewXLSXFile -Coordinates "B2:B2" )
	            $Result[0].Val | Should be 944041859
	            $Result.Count | Should be 1
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Get-Workbook_tests_ps1
function Call-Get-Workbook_tests_ps1
{
	# Describe "Get-Workbook PS$PSVersion" {}
	
	<#
	Describe "Verb-Noun PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should do something' {
	            # $NewXLSXFile - Remove, create, and remove this as needed
	            # $ExistingXLSXFile - Use this to verify reads if desired, but other tests use it.  Please do no modify or remove.
	
	        }
	    }
	}
	#>
	
}
#endregion

#region Call-Get-Worksheet_tests_ps1
function Call-Get-Worksheet_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Get-Worksheet PS$PSVersion" {
	
	 Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should return a worksheet' {
	
	            $Excel = New-Excel -Path $ExistingXLSXFile
	            $WorkSheet = $Excel | Get-Worksheet
	            $WorkSheet -is [OfficeOpenXml.ExcelWorksheet] | Should Be $True
	            $WorkSheet.Name | Should Be 'WorkSheet1'
	
	        }
	    }
	
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Import-XLSX_tests_ps1
function Call-Import-XLSX_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Import-XLSX PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should import data with expected results' {
	            $ExcelData = Import-XLSX -Path $ExistingXLSXFile
	            $Props = $ExcelData[0].PSObject.Properties | Select -ExpandProperty Name
	
	            $ExcelData.count | Should be 10
	            $Props[0] | Should be 'Name'
	            $Props[1] | Should be 'Val'
	
	            $Exceldata[0].val | Should be '944041859'
	            $Exceldata[0].name | Should be 'Prop1'
	
	        }
	        It 'should parse numberformat for dates' {
	            $ExcelData = Import-XLSX -Path $ExistingXLSXFile
	
	            $Exceldata[0].Date -is [datetime] | Should be $True
	            $Exceldata[0].Date.Month | Should be 1
	            $Exceldata[0].Date.Year | Should be 2015
	            $Exceldata[0].Date.Hour | Should be 4
	        }
	
	        It 'should replace headers' {
	            $ExcelData = Import-XLSX -Path $ExistingXLSXFile -Header one, two, three
	            $Props = $ExcelData[0].PSObject.Properties | Select -ExpandProperty Name
	
	            $Props[0] | Should be 'one'
	            $Props[1] | Should be 'two'
	            $Props[2] | Should be 'three'
	        }
	
	        It 'should handle alternate row and column starts' {
	            $ExcelData = Import-XLSX -Path $PSScriptRoot\DataPlacementTest.xlsx -RowStart 3 -ColumnStart 2
	            $Props = $ExcelData[0].PSObject.Properties | Select -ExpandProperty Name
	
	            $ExcelData.count | Should be 10
	            $Props[0] | Should be 'Name'
	            $Props[1] | Should be 'Val'
	
	            $Exceldata[0].val | Should be '944041859'
	            $Exceldata[0].name | Should be 'Prop1'
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Join-WorkSheet_tests_ps1
function Call-Join-WorkSheet_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Join-Worksheet PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should join worksheets' {
	
	            #Get the worksheets to join:
	                $JoinPath = "$PSScriptRoot\JoinTest.xlsx"
	                $Excel = New-Excel -Path $JoinPath
	                $LeftWorksheet = Get-Worksheet -Excel $Excel -Name 'Left'
	                $RightWorksheet = Get-WorkSheet -Excel $Excel -Name 'Right'
	
	            #We have the data - join it where Left.Name = Right.Manager
	                Remove-Item $NewXLSXFile -ErrorAction SilentlyContinue -force
	                Join-Worksheet -Path $NewXLSXFile -LeftWorksheet $LeftWorksheet -RightWorksheet $RightWorksheet -LeftJoinColumn Name -RightJoinColumn Manager
	                $Excel | Close-Excel
	
	            #Verify the output:
	                $Result = @( Import-XLSX -Path $NewXLSXFile )
	
	                $Result.count | Should Be 5
	                $Names = $Result | Select -ExpandProperty Name
	                $ExpectedNames = echo jsmith1, jsmith2, jsmith3, 'Department 4', 'Department 5'
	
	                @(Compare-Object $Names $ExpectedNames).count | Should Be 0
	                @($Result | ?{$_.Name -eq 'jsmith2'})[0].Manager -like $null | Should Be $true
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-New-Excel_tests_ps1
function Call-New-Excel_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	
	Describe "New-Excel PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should create an ExcelPackage' {
	            $Excel = New-Excel
	            $Excel -is [OfficeOpenXml.ExcelPackage] | Should Be $True
	            $Excel.Dispose()
	            $Excel = $Null
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            $Excel -is [OfficeOpenXml.ExcelPackage] | Should Be $True
	            $Excel.Dispose()
	            $Excel = $Null
	
	        }
	
	        It 'should reflect the correct path' {
	            Remove-Item $NewXLSXFile -force -ErrorAction silentlycontinue
	            $Excel = New-Excel -Path $NewXLSXFile
	            $Excel.File | Should be $NewXLSXFile
	            $Excel.Dispose()
	            $Excel = $Null
	        }
	
	        It 'should not create a file' {
	            Test-Path $NewXLSXFile | Should Be $False
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Save-Excel_tests_ps1
function Call-Save-Excel_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Save-Excel PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should save an xlsx file' {
	
	            Remove-Item $NewXLSXFile -Force -ErrorAction SilentlyContinue
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            [void]$Excel.Workbook.Worksheets.Add(1)
	            $Excel | Save-Excel
	
	            Test-Path $NewXLSXFile | Should be $True
	        }
	
	        It 'should close an excelpackage when specified' {
	
	            Remove-Item $NewXLSXFile -Force -ErrorAction SilentlyContinue
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            [void]$Excel.Workbook.Worksheets.Add(1)
	            $File = $Excel.File
	            $Excel | Save-Excel -Close
	
	            $Excel.File -like $File | Should be $False
	        }
	
	        It 'should save as a specified path' {
	
	            Remove-Item "$NewXLSXFile`2" -Force -ErrorAction SilentlyContinue
	            Remove-Item "$NewXLSXFile" -Force -ErrorAction SilentlyContinue
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            [void]$Excel.Workbook.Worksheets.Add(1)
	            $Excel | Save-Excel -Path "$NewXLSXFile`2"
	
	            Test-Path "$NewXLSXFile`2" | Should be $True
	            Remove-Item "$NewXLSXFile`2" -Force -ErrorAction SilentlyContinue
	        }
	
	        It 'should return a fresh excelpackage when passthru is specified' {
	
	            #If you want to save twice, you need to pull the excel package back in, otherwise, it bombs out.
	
	            Remove-Item "$NewXLSXFile" -Force -ErrorAction SilentlyContinue
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            [void]$Excel.Workbook.Worksheets.Add(1)
	            $Excel = $Excel | Save-Excel -Passthru
	
	            $Excel -is [OfficeOpenXml.ExcelPackage] | Should Be $True
	
	            [void]$Excel.Workbook.Worksheets.Add(2)
	            @($Excel.Workbook.Worksheets).count | Should be 2
	            $Excel | Save-Excel
	
	            $Excel = New-Excel -Path $NewXLSXFile
	            @($Excel.Workbook.Worksheets).count | Should be 2
	
	            Remove-Item "$NewXLSXFile" -Force -ErrorAction SilentlyContinue
	        }
	    }
	}
	
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Search-CellValue_tests_ps1
function Call-Search-CellValue_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Search-CellValue PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should find cells' {
	
	            $Result = @( Search-CellValue -Path $ExistingXLSXFile -FilterScript {$_ -eq "Prop2" -or ($_ -is [datetime] -and $_.day -like 7)} )
	            $Result.Count | Should be 2
	            $Result[0].Row | Should be 3
	            $Result[0].Match | Should be 'Prop2'
	
	        }
	
	        It 'Should return raw when specified' {
	            $Result = @( Search-CellValue -Path $ExistingXLSXFile -FilterScript {$_ -eq 'Prop3'} -as Raw )
	            $Result.count | Should be 1
	            $Result[0] -is [string] | Should be $True
	        }
	
	        It 'Should return ExcelRange if specified' {
	            $Result = @( Search-CellValue -Path $ExistingXLSXFile -FilterScript {$_ -is [string]} -as Passthru )
	            $Result.count | Should be 13
	            $Result[0] -is [OfficeOpenXml.ExcelRangeBase] | Should be $True
	        }
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Set-CellValue_tests_ps1
function Call-Set-CellValue_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	#Set up some data we will use in testing
	    $ExistingXLSXFile = "$here\Working.xlsx"
	    Remove-Item $ExistingXLSXFile  -force -ErrorAction SilentlyContinue
	    Copy-Item $here\Test.xlsx $ExistingXLSXFile -force
	
	    $NewXLSXFile = "$here\New.xlsx"
	    Remove-Item $NewXLSXFile  -force -ErrorAction SilentlyContinue
	
	    $Files = Get-ChildItem $PSScriptRoot | Where {-not $_.PSIsContainer}
	
	Describe "Set-CellValue PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'Should set a value based on CellRange' {
	            Copy-Item -Path $ExistingXLSXFile -Destination $NewXLSXFile -Force
	
	            $Excel = New-Excel -Path $NewXLSXFile
	
	            $Excel | Search-CellValue {$_ -eq "Prop2"} -As Passthru | Set-CellValue -Value "REDACTED"
	            $Excel | Save-Excel
	
	            $Result = @( Import-XLSX -Path $NewXLSXFile )
	            $Result[1].Name | Should be 'REDACTED'
	        }
	        It 'Should set a value based on Path' {
	            Copy-Item -Path $ExistingXLSXFile -Destination $NewXLSXFile -Force
	
	            Set-CellValue -Coordinates "A2:A3" -Path $NewXLSXFile -Value "REDACTED"
	            $Result = @( Import-XLSX -Path $NewXLSXFile )
	            $Result[0].Name | Should be 'REDACTED'
	            $Result[1].Name | Should be 'REDACTED'
	        }
	
	    }
	}
	#Remove-Module $moduleName
	Remove-Item $NewXLSXFile -force -ErrorAction SilentlyContinue
	Remove-Item $ExistingXLSXFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Import-DIACAP_tests_ps1
function Call-Import-DIACAP_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Import-DIACAP PS: $PSVersion" {
	
	    Copy-Item "$Global:testData\Controls\FAIL_Sample_DODI_8500_2_Controls.xlsx" "TestDrive:\FAIL_Sample_DODI_8500_2_Controls.xlsx"
	    Copy-Item "$Global:testData\Controls\Sample_DODI_8500_2_Controls.xlsx" "TestDrive:\Sample_DODI_8500_2_Controls.xlsx"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No object provided'" {
	            {Import-DIACAP} | Should Throw "No object provided"
	        }
	
	        It "Should Throw 'Sanity Check Failure: Columns are missing from DIACAP Control Doc' (Requires IMPORT-XLSX)" {
	            $xlsx = Import-XLSX -Path "$($TestDrive)\FAIL_Sample_DODI_8500_2_Controls.xlsx"
	            {Import-DIACAP -doc $xlsx} | Should Throw "Sanity Check Failure: Columns are missing from DIACAP Control Doc"
	        }
	
	        It "Should return an object (Requsires IMPORT-XLSX)" {
	            $xlsx = Import-XLSX -Path "$($TestDrive)\Sample_DODI_8500_2_Controls.xlsx"
	            $controls = Import-DIACAP -doc $xlsx
	            $controls -is [Object] | Should Be $true
	        }
	
	        It "Should return all properties" {
	            $xlsx = Import-XLSX -Path "$($TestDrive)\Sample_DODI_8500_2_Controls.xlsx"
	            $controls = Import-DIACAP -doc $xlsx
	            $properties = $($controls | Get-Member -MemberType NoteProperty).Name
	            ($properties -contains "Allocated Assessment ID" -and $properties -contains "Allocated Control ID" -and $properties -contains "Assessed By" -and $properties -contains "Assessment Date" -and $properties -contains "Assessment Objectives" -and $properties -contains "Assessment Status" -and $properties -contains "AssessmentObjectiveID" -and $properties -contains "Authorization Package" -and $properties -contains "Comments" -and $properties -contains "Control Implementation Status" -and $properties -contains "Control Name" -and $properties -contains "Control Number" -and $properties -contains "Impact Code" -and $properties -contains "Implementation Details" -and $properties -contains "Methods Used") | Should Be $true
	        }
	
	    }
	}
	
}
#endregion

#region Call-Join-Controls_tests_ps1
function Call-Join-Controls_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Join-Controls PS: $PSVersion" {
	
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample04_Win2008R2MS.ckl" "TestDrive:\Sample04_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\Controls\Sample_DODI_8500_2_Controls.xlsx" "TestDrive:\Sample_DODI_8500_2_Controls.xlsx"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No object provided' Controls" {
	            {Join-Controls} | Should Throw "No object provided"
	        }
	
	        It "Should Throw 'No object provided' CKL (Requires Import-XLSX, Import-DIACAP)" {
	            $diacapxlsx = Import-XLSX -Path "$($TestDrive)\Sample_DODI_8500_2_Controls.xlsx"
	            $controls = Import-DIACAP -doc $diacapxlsx
	            {Join-Controls -Controls $controls} | Should Throw "No object provided"
	        }
	
	        It "Should Merge the Failed STIG Items that Map to IA Controls (Requires Import-XLSX, Import-DIACAP, Import-XML, Import-CKL, Compress-Report)" {
	            #IAIA-1, IAIA-2
	            $diacapxlsx = Import-XLSX -Path "$($TestDrive)\Sample_DODI_8500_2_Controls.xlsx"
	            $controls = Import-DIACAP -doc $diacapxlsx
	            $file = Get-Item -Path "$($TestDrive)\Sample04_Win2008R2MS.ckl"
	            $cklxml = Import-XML -fileobj $file
	            $cklfile = Import-CKL -doc $cklxml
	            $filteredCKL = $cklfile | Where-Object{$_.Status -match "Open"}
	            $compressedCKL = Compress-Report -Report $filteredCKL -CKL
	            $Script:finalControls = Join-Controls -Controls $controls -CKL $compressedCKL -DIACAP
	            $Script:finalControls -is [Object] | Should Be True
	        }
	
	        It "Should return IAIA-1 with a Count of 12 now Passed" {
	            $diacapxlsx = Import-XLSX -Path "$($TestDrive)\Sample_DODI_8500_2_Controls.xlsx"
	            $controls = Import-DIACAP -doc $diacapxlsx
	            $($controls | Where-Object {$_."Control Number" -match "IAIA-1" -and $_."Assessment Status" -match "Pass"}).count | Should Be 12
	        }
	
	        It "Should return IAIA-1 with a Count of 12 now Failed" {
	            #$($Script:controls | Where-Object {$_."Control Number" -match "IAIA-1" -and $_."Assessment Status" -match "Pass"}).count | Should Be 12
	            $($Script:finalControls | Where-Object {$_."Control Number" -match "IAIA-1" -and $_."Assessment Status" -match "Fail"}).count | Should Be 12
	        }
	    }
	}
	
}
#endregion

#region Call-Get-NessusFile_Tests_ps1
function Call-Get-NessusFile_Tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$moduleName = "PSIASTAND"
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	#InModuleScope nessusOpenPorts {
	    Describe "Get-NessusFile" {
	        Setup -File somefile.nessus
	        Setup -File somefile.test.nessus
	        Setup -File somefile.text
	        Setup -File somefile.test.txt
	        Setup -Dir Temp
	        setup -Dir Recur
	        Setup -File Recur\filesome.nessus
	        Setup -File Recur\filesomemore.txt
	
	        It "should find nessus files none-recursive" {
	            $files = Get-NessusFile -Path TestDrive:\
	            $files.Count | Should Be 2
	        }
	
	        It "should find nessus files recursive" {
	            $files = Get-NessusFile -Path TestDrive:\ -recursive
	            $files.Count | Should Be 3
	        }
	
	        It "should throw No Nessus Files Found" {
	            {Get-NessusFile -Path TestDrive:\Temp} | Should Throw "No Nessus Files Found"
	        }
	
	        It "should throw path not found" {
	            {Get-NessusFile -Path TempDrive:\Temp} | Should Throw "path not found"
	        }
	
	        IT "should throw No Path Provided" {
	            {Get-NessusFile} | Should Throw "No Path Provided"
	        }
	    }
	#}
	#Remove-Module $moduleName
	
}
#endregion

#region Call-Import-Nessus_tests_ps1
function Call-Import-Nessus_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Import-Nessus PS: $PSVersion" {
	
	    Copy-Item "$here\Nessus_Sample_Linux.nessus" "TestDrive:\Nessus_Sample_Linux.nessus"
	    Copy-Item "$here\Nessus_Sample_Windows.nessus" "TestDrive:\Nessus_Sample_Windows.nessus"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Nessus File (Sample Linux) is an object (Requires Import-XML)" {
	            $file = Get-ChildItem -Path "TestDrive:\Nessus_Sample_Linux.nessus"
	            $xml = Import-XML -fileobj $file
	            $Script:linuxnessus = Import-Nessus -doc $xml
	            $Script:linuxnessus -is [Object] | Should be $true
	        }
	
	        It "Nessus File (Sample Windows) is an object (Requires Import-XML)" {
	            $file = Get-ChildItem -Path "TestDrive:\Nessus_Sample_Windows.nessus"
	            $xml = Import-XML -fileobj $file
	            $Script:windowsnessus = Import-Nessus -doc $xml
	            $Script:windowsnessus -is [Object] | Should be $true
	        }
	
	        It "Nessus File (Sample linux) has 3 hosts" {
	            $nessushost = $Script:linuxnessus.'host-ip' | sort -Unique
	            $nessushost.count | Should be 3
	        }
	
	        It "Nessus File (Sample linux) has 61 objects" {
	            $Script:linuxnessus.count | Should be 61
	        }
	
	        It "Nessus File (Sample linux) has 3 Failed Credentialed Scans" {
	            $nessuscred = $Script:linuxnessus | Select-Object 'HOST-IP', 'Credentialed_Scan' | Get-Unique -AsString
	            $nessuscred.count | Should Be 3
	        }
	
	        It "Nessus File (Sample Windows) has 3 hosts" {
	            $nessushost = $Script:windowsnessus.'host-ip' | sort -Unique
	            $nessushost.count | Should be 3
	        }
	
	        It "Nessus File (Sample Windows) has 168 objects" {
	            $Script:windowsnessus.count | Should be 168
	        }
	
	        It "Nessus File (Sample Windows) has 3 Failed Credentialed Scans" {
	            $nessuscred = $Script:windowsnessus | Select-Object 'HOST-IP', 'Credentialed_Scan' | Get-Unique -AsString
	            $nessuscred.count | Should Be 3
	        }
	
	    }
	}
	
}
#endregion

#region Call-Import-NessusOpenPortsPlugin_Tests_ps1
function Call-Import-NessusOpenPortsPlugin_Tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	#InModuleScope nessusOpenPorts {
	    Describe "Import-NessusOpenPortsPlugin" {
	        Setup -File sample.nessus
	        Setup -File anothersample.txt
	        Setup -File sample2.nessus
	        Setup -File sample3.nessus
	        Setup -File sample4.nessus
	
	        Set-Content -Path TestDrive:\sample.nessus -Value @'
<?xml version="1.0" ?>
<NessusClientData_v2>
	<Policy>
		<policyName>
		</policyName>
		<Preferences>
		</Preferences>
		<FamilySelection>
		</FamilySelection>
		<IndividualPluginSelection>
		</IndividualPluginSelection>
	</Policy>
	<Report name="Test Scan" xmlns:cm="http://wwww.nessus.org/cm">
		<ReportHost name="192.168.1.1">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.1</tag>
				<tag name="host-fq">randomhost1.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="2868" svc_name="npep-messaging?" protocol="tcp" severity="0" pluginID="25221" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>
  Process id   : 2544
  Executable   : /opt/vmware/sbin/vami-lighttpd
  Command line : /opt/vmware/sbin/vami-lighttpd -f /opt/vmware/etc/lighttpd/lighttpd.conf </plugin_output>

			</ReportItem>
			<ReportItem port="514" svc_name="syslog?" protocol="udp" severity="0" pluginID="25221" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>  Process id   : 2118
  Executable   : /sbin/syslog-ng
  Command line : /sbin/syslog-ng </plugin_output>

			</ReportItem>
		</ReportHost>
		<ReportHost name="192.168.1.2">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.2</tag>
				<tag name="host-fq">randomhost2.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="445" svc_name="cifs" protocol="tcp" severity="0" pluginID="34252" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;System&apos; is listening on this port (pid 4).</plugin_output>
			</ReportItem>

			<ReportItem port="49152" svc_name="dce-rpc" protocol="tcp" severity="0" pluginID="34252" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;wininit.exe&apos; is listening on this port (pid 488).</plugin_output>

			</ReportItem>

		</ReportHost>
	</Report>
</NessusClientData_v2>
'@
	        Set-Content -Path TestDrive:\sample2.nessus -Value @'
<?xml version="1.0" encoding="UTF-8"?>
<note>
	<to>Tove</to>
	<from>Jani</from>
	<heading>Reminder</heading>
	<body>Don't forget me this weekend!</body>
</note>
'@
	
	        Set-Content -Path TestDrive:\sample3.nessus -Value @'
<?xml version="1.0" ?>
<NessusClientData_v2>
	<Policy>
		<policyName>
		</policyName>
		<Preferences>
		</Preferences>
		<FamilySelection>
		</FamilySelection>
		<IndividualPluginSelection>
		</IndividualPluginSelection>
	</Policy>
	<Report name="Test Scan" xmlns:cm="http://wwww.nessus.org/cm">
		<ReportHost name="192.168.1.1">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.1</tag>
				<tag name="host-fq">randomhost1.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="2868" svc_name="npep-messaging?" protocol="tcp" severity="0" pluginID="34252" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>
  Process id   : 2544
  Executable   : /opt/vmware/sbin/vami-lighttpd
  Command line : /opt/vmware/sbin/vami-lighttpd -f /opt/vmware/etc/lighttpd/lighttpd.conf </plugin_output>

			</ReportItem>
			<ReportItem port="514" svc_name="syslog?" protocol="udp" severity="0" pluginID="34252" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>  Process id   : 2118
  Executable   : /sbin/syslog-ng
  Command line : /sbin/syslog-ng </plugin_output>

			</ReportItem>
		</ReportHost>
		<ReportHost name="192.168.1.2">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.2</tag>
				<tag name="host-fq">randomhost2.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="445" svc_name="cifs" protocol="tcp" severity="0" pluginID="11111" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;System&apos; is listening on this port (pid 4).</plugin_output>
			</ReportItem>

			<ReportItem port="49152" svc_name="dce-rpc" protocol="tcp" severity="0" pluginID="11111" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;wininit.exe&apos; is listening on this port (pid 488).</plugin_output>

			</ReportItem>

		</ReportHost>
	</Report>
</NessusClientData_v2>
'@
	
	        Set-Content -Path TestDrive:\sample4.nessus -Value  @'
<?xml version="1.0" ?>
<NessusClientData_v2>
	<Policy>
		<policyName>
		</policyName>
		<Preferences>
		</Preferences>
		<FamilySelection>
		</FamilySelection>
		<IndividualPluginSelection>
		</IndividualPluginSelection>
	</Policy>
	<Report name="Test Scan" xmlns:cm="http://wwww.nessus.org/cm">
		<ReportHost name="192.168.1.1">
			<HostProperties>
				<tag name="Credentialed_Scan">true</tag>
				<tag name="host-ip">192.168.1.1</tag>
				<tag name="host-fq">randomhost1.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="2868" svc_name="npep-messaging?" protocol="tcp" severity="0" pluginID="25221" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>
  Process id   : 2544
  Executable   : /opt/vmware/sbin/vami-lighttpd
  Command line : /opt/vmware/sbin/vami-lighttpd -f /opt/vmware/etc/lighttpd/lighttpd.conf </plugin_output>

			</ReportItem>
			<ReportItem port="514" svc_name="syslog?" protocol="udp" severity="0" pluginID="25221" pluginName="Remote listeners enumeration (Linux / AIX)" pluginFamily="Service detection">

				<agent>unix</agent>

				<description>Remote listeners enumeration (Sample Description)</description>

				<fname>process_on_port.nasl</fname>

				<plugin_modification_date>2015/06/02</plugin_modification_date>

				<plugin_name>Remote listeners enumeration (Linux / AIX)</plugin_name>

				<plugin_publication_date>2007/05/16</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>1.17</script_version>

				<solution>n/a</solution>

				<synopsis>Using the supplied credentials, it is possible to identify the process listening on the remote port.</synopsis>

				<plugin_output>  Process id   : 2118
  Executable   : /sbin/syslog-ng
  Command line : /sbin/syslog-ng </plugin_output>

			</ReportItem>
		</ReportHost>
		<ReportHost name="192.168.1.2">
			<HostProperties>
				<tag name="Credentialed_Scan">false</tag>
				<tag name="host-ip">192.168.1.2</tag>
				<tag name="host-fq">randomhost2.randomsubdomain.randomdomain</tag>
			</HostProperties>
			<ReportItem port="445" svc_name="cifs" protocol="tcp" severity="0" pluginID="34252" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;System&apos; is listening on this port (pid 4).</plugin_output>
			</ReportItem>

			<ReportItem port="49152" svc_name="dce-rpc" protocol="tcp" severity="0" pluginID="34252" pluginName="Microsoft Windows Remote Listeners Enumeration (WMI)" pluginFamily="Windows">

				<description>WMI (Sample Description)</description>

				<fname>wmi_process_on_port.nbin</fname>

				<plugin_modification_date>2015/08/24</plugin_modification_date>

				<plugin_name>Microsoft Windows Remote Listeners Enumeration (WMI)</plugin_name>

				<plugin_publication_date>2008/09/23</plugin_publication_date>

				<plugin_type>local</plugin_type>

				<risk_factor>None</risk_factor>

				<script_version>$Revision: 1.32 $</script_version>

				<solution>n/a</solution>

				<synopsis>It is possible to obtain the names of processes listening on the remote UDP and TCP ports.</synopsis>

				<plugin_output>
The Win32 process &apos;wininit.exe&apos; is listening on this port (pid 488).</plugin_output>

			</ReportItem>

		</ReportHost>
	</Report>
</NessusClientData_v2>
'@
	
	        It "should find 4 total ports" {
	            $result = Import-NessusOpenPortsPlugin -file (Get-Item TestDrive:\sample.nessus)
	            $result[0].Count | Should Be 4
	        }
	
	        It "should find 2 plugins with ID 25221 (linux)" {
	            $result = Import-NessusOpenPortsPlugin -file (Get-Item TestDrive:\sample.nessus)
	            $test = $($result[0] | Where-Object{$_.Plugin -eq 25221})
	            $test.Count | Should Be 2
	        }
	
	        It "should find 2 plugins with ID 34252 (windows)" {
	            $result = Import-NessusOpenPortsPlugin -file (Get-Item TestDrive:\sample.nessus)
	            $test = $($result[0] | Where-Object{$_.Plugin -eq 34252})
	            $test.Count | Should Be 2
	        }
	
	        It "should find 1 system with no open ports" {
	            $result = Import-NessusOpenPortsPlugin -file (Get-Item TestDrive:\sample3.nessus)
	            $result[1].Count | Should Be 1
	        }
	
	        It "should throw No Path Provided" {
	            {Import-NessusOpenPortsPlugin} | Should Throw "No File Object Provided"
	        }
	
	        It "should throw Not an XML Document" {
	            {Import-NessusOpenPortsPlugin -file (Get-Item TestDrive:\anothersample.txt)} | Should Throw "$((Get-Item TestDrive:\anothersample.txt).name) Not an XML Document"
	        }
	
	        It "should throw Not a Nessus File" {
	            {Import-NessusOpenPortsPlugin -file (Get-Item TestDrive:\sample2.nessus)} | Should Throw "$((Get-Item TestDrive:\sample2.nessus).name) Not a Nessus File"
	        }
	
	        It "should throw not a credentialed scan" {
	            {Import-NessusOpenPortsPlugin -file (Get-Item TestDrive:\sample4.nessus)} | Should Throw "$((Get-Item TestDrive:\sample4.nessus).name) Not a credentialed Scan"
	        }
	    }
	#}
	#Remove-Module $moduleName
	
}
#endregion

#region Call-Invoke-SQLiteBulkCopy_tests_ps1
function Call-Invoke-SQLiteBulkCopy_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$Verbose = @{}
	if($env:APPVEYOR_REPO_BRANCH -and $env:APPVEYOR_REPO_BRANCH -notlike "master")
	{
	    $Verbose.add("Verbose",$True)
	}
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	$SQLiteFile = "$here\Working.SQLite"
	Remove-Item $SQLiteFile  -force -ErrorAction SilentlyContinue
	Copy-Item $here\Names.SQLite $here\Working.SQLite -force
	
	$DataTable = 1..1000 | %{
	                New-Object -TypeName PSObject -property @{
	                    fullname = "Name $_"
	                    surname = "Name"
	                    givenname = "$_"
	                    BirthDate = (Get-Date).Adddays(-$_)
	                } | Select fullname, surname, givenname, birthdate
	            } | Out-DataTable @Verbose
	
	Describe "Invoke-SQLiteBulkCopy (Requires Out-DataTable) PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should insert data' {
	            Invoke-SQLiteBulkCopy @Verbose -DataTable $Script:DataTable -DataSource $SQLiteFile -Table Names -NotifyAfter 100 -force
	
	            @( Invoke-SQLiteQuery @Verbose -Database $SQLiteFile -Query "SELECT fullname FROM NAMES WHERE surname = 'Name'" ).count | Should Be 1000
	        }
	        It "should adhere to ConflictCause" {
	
	            #Basic set of tests, need more...
	
	            #Try adding same data
	            { Invoke-SQLiteBulkCopy @Verbose -DataTable $Script:DataTable -DataSource $SQLiteFile -Table Names -NotifyAfter 100 -force } | Should Throw
	
	            #Change a known row's prop we can test to ensure it does or does not change
	            $Script:DataTable.Rows[0].surname = "Name 1"
	            { Invoke-SQLiteBulkCopy @Verbose -DataTable $Script:DataTable -DataSource $SQLiteFile -Table Names -NotifyAfter 100 -force } | Should Throw
	
	            $Result = @( Invoke-SQLiteQuery @Verbose -Database $SQLiteFile -Query "SELECT surname FROM NAMES WHERE fullname = 'Name 1'")
	            $Result[0].surname | Should Be 'Name'
	
	            { Invoke-SQLiteBulkCopy @Verbose -DataTable $Script:DataTable -DataSource $SQLiteFile -Table Names -NotifyAfter 100 -ConflictClause Rollback -Force } | Should Throw
	
	            $Result = @( Invoke-SQLiteQuery @Verbose -Database $SQLiteFile -Query "SELECT surname FROM NAMES WHERE fullname = 'Name 1'")
	            $Result[0].surname | Should Be 'Name'
	
	            Invoke-SQLiteBulkCopy @Verbose -DataTable $Script:DataTable -DataSource $SQLiteFile -Table Names -NotifyAfter 100 -ConflictClause Replace -Force
	
	            $Result = @( Invoke-SQLiteQuery @Verbose -Database $SQLiteFile -Query "SELECT surname FROM NAMES WHERE fullname = 'Name 1'")
	            $Result[0].surname | Should Be 'Name 1'
	
	
	        }
	    }
	}
	
	#Remove-Module $moduleName
	Remove-Item $SQLiteFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Invoke-SQLiteQuery_tests_ps1
function Call-Invoke-SQLiteQuery_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$Verbose = @{}
	if($env:APPVEYOR_REPO_BRANCH -and $env:APPVEYOR_REPO_BRANCH -notlike "master")
	{
	    $Verbose.add("Verbose",$True)
	}
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	$SQLiteFile = "$here\Working.SQLite"
	Remove-Item $SQLiteFile  -force -ErrorAction SilentlyContinue
	Copy-Item $here\Names.SQLite $here\Working.SQLite -force
	$Script:Connection = New-SQLiteConnection @Verbose -DataSource :MEMORY:
	
	Describe "Invoke-SQLiteQuery (Requires New-SQLiteConnection) PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should take file input' {
	            $Out = @( Invoke-SqliteQuery @Verbose -DataSource $SQLiteFile -InputFile $PSScriptRoot\Test.SQL )
	            $Out.count | Should be 2
	            $Out[1].OrderID | Should be 500
	        }
	
	        It 'should take query input' {
	            $Out = @( Invoke-SQLiteQuery @Verbose -Database $SQLiteFile -Query "PRAGMA table_info(NAMES)" -ErrorAction Stop )
	            $Out.count | Should Be 4
	            $Out[0].Name | SHould Be "fullname"
	        }
	
	        It 'should support parameterized queries' {
	
	            $Out = @( Invoke-SQLiteQuery @Verbose -Database $SQLiteFile -Query "SELECT * FROM NAMES WHERE BirthDate >= @Date" -SqlParameters @{
	                Date = (Get-Date 3/13/2012)
	            } -ErrorAction Stop )
	            $Out.count | Should Be 1
	            $Out[0].fullname | Should Be "Cookie Monster"
	
	            $Out = @( Invoke-SQLiteQuery @Verbose -Database $SQLiteFile -Query "SELECT * FROM NAMES WHERE BirthDate >= @Date" -SqlParameters @{
	                Date = (Get-Date 3/15/2012)
	            } -ErrorAction Stop )
	            $Out.count | Should Be 0
	        }
	
	        It 'should use existing SQLiteConnections' {
	            Invoke-SqliteQuery @Verbose -SQLiteConnection $Script:Connection -Query "CREATE TABLE OrdersToNames (OrderID INT PRIMARY KEY, fullname TEXT);"
	            Invoke-SqliteQuery @Verbose -SQLiteConnection $Script:Connection -Query "INSERT INTO OrdersToNames (OrderID, fullname) VALUES (1,'Cookie Monster');"
	            @( Invoke-SqliteQuery @Verbose -SQLiteConnection $Script:Connection -Query "PRAGMA STATS" ) |
	                Select -first 1 -ExpandProperty table |
	                Should be 'OrdersToNames'
	
	            $Script:COnnection.State | Should Be Open
	
	            $Script:Connection.close()
	        }
	
	        It 'should respect PowerShell expectations for null' {
	
	            #The SQL folks out there might be annoyed by this, but we want to treat DBNulls as null to allow expected PowerShell operator behavior.
	
	            $Connection = New-SQLiteConnection -DataSource :MEMORY:
	            Invoke-SqliteQuery @Verbose -SQLiteConnection $Connection -Query "CREATE TABLE OrdersToNames (OrderID INT PRIMARY KEY, fullname TEXT);"
	            Invoke-SqliteQuery @Verbose -SQLiteConnection $Connection -Query "INSERT INTO OrdersToNames (OrderID, fullname) VALUES (1,'Cookie Monster');"
	            Invoke-SqliteQuery @Verbose -SQLiteConnection $Connection -Query "INSERT INTO OrdersToNames (OrderID) VALUES (2);"
	
	            @( Invoke-SqliteQuery @Verbose -SQLiteConnection $Connection -Query "SELECT * FROM OrdersToNames" -As DataRow | Where{$_.fullname}).count |
	                Should Be 2
	
	            @( Invoke-SqliteQuery @Verbose -SQLiteConnection $Connection -Query "SELECT * FROM OrdersToNames" | Where{$_.fullname} ).count |
	                Should Be 1
	            $Connection.close()
	        }
	    }
	}
	
	#Remove-Module $moduleName
	Remove-Item $SQLiteFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-New-SQLiteConnection_tests_ps1
function Call-New-SQLiteConnection_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$Verbose = @{}
	if($env:APPVEYOR_REPO_BRANCH -and $env:APPVEYOR_REPO_BRANCH -notlike "master")
	{
	    $Verbose.add("Verbose",$True)
	}
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	$SQLiteFile = "$here\Working.SQLite"
	Remove-Item $SQLiteFile  -force -ErrorAction SilentlyContinue
	Copy-Item $here\Names.SQLite $here\Working.SQLite -force
	
	Describe "New-SQLiteConnection PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should create a connection' {
	            $Connection = New-SQLiteConnection @Verbose -DataSource :MEMORY:
	            $Connection.ConnectionString | Should be "Data Source=:MEMORY:;"
	            $Connection.State | Should be "Open"
	            $Connection.close()
	        }
	    }
	}
	
	#Remove-Module $moduleName
	Remove-Item $SQLiteFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-Out-DataTable_tests_ps1
function Call-Out-DataTable_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	$Verbose = @{}
	if($env:APPVEYOR_REPO_BRANCH -and $env:APPVEYOR_REPO_BRANCH -notlike "master")
	{
	    $Verbose.add("Verbose",$True)
	}
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	$SQLiteFile = "$here\Working.SQLite"
	Remove-Item $SQLiteFile  -force -ErrorAction SilentlyContinue
	Copy-Item $here\Names.SQLite $here\Working.SQLite -force
	
	Describe "Out-DataTable PS$PSVersion" {
	
	    Context 'Strict mode' {
	
	        Set-StrictMode -Version latest
	
	        It 'should create a DataTable' {
	
	            $DataTable = 1..1000 | %{
	                New-Object -TypeName PSObject -property @{
	                    fullname = "Name $_"
	                    surname = "Name"
	                    givenname = "$_"
	                    BirthDate = (Get-Date).Adddays(-$_)
	                } | Select fullname, surname, givenname, birthdate
	            } | Out-DataTable @Verbose
	
	            $DataTable.GetType().Fullname | Should Be 'System.Data.DataTable'
	            @($DataTable.Rows).Count | Should Be 1000
	            $Columns = $DataTable.Columns | Select -ExpandProperty ColumnName
	            $Columns[0] | Should Be 'fullname'
	            $Columns[3] | Should Be 'BirthDate'
	            $DataTable.columns[3].datatype.fullname | Should Be 'System.DateTime'
	
	        }
	    }
	}
	
	#Remove-Module $moduleName
	Remove-Item $SQLiteFile -force -ErrorAction SilentlyContinue
	
}
#endregion

#region Call-ConvertTo-CKL_tests_ps1
function Call-ConvertTo-CKL_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	
	Describe "ConvertTo-CKL PS: $PSVersion" {
	
	    # Stig viewer version
	    $stigViewerVersion = "DISA STIG Viewer : 1.2.0"
	
	    # mappers
	    $headMappers = [ordered]@{ # Change the value of the hastable key values to match the headers of the sheet your importing # Maybe needed [ordered]
	        "Vuln_Num"="Vuln ID"
	        "Severity"="Severity"
	        "Group_Title"="Group Title"
	        "Rule_ID"="Rule ID"
	        "Rule_Ver"="STIG ID"
	        "Rule_Title"="Rule Title"
	        "Vuln_Discuss"="Discussion"
	        "IA_Controls"="IA Controls"
	        "Check_Content"="Check Content"
	        "Fix_Text"="Fix Text"
	        "False_Positives"="False Positives"
	        "False_Negatives"="False Negatives"
	        "Documentable"="Documentable"
	        "Mitigations"="Mitigations"
	        "Potential_Impact"="Potential Impact"
	        "Third_Party_Tools"="Third Party Tools"
	        "Mitigation_Control"="Mitigation Control"
	        "Responsibility"="Responsibility"
	        "Security_Override_Guidance"="Severity Override Guidance"
	        "Check_Content_Ref"="Check Content Reference"
	        "Class"="Classification"
	        "STIGRef"="STIG"
	        "TargetKey"="VMS Asset Posture"
	        # "CCI_REF"="CCI Data"  -- Removed this Attribute
	        "STATUS"="Status"
	        # These Below can be equal to $null
	        "FINDING_DETAILS"="Notes"
	        "COMMENTS"= "Comments"
	        "SEVERITY_OVERRIDE"= "Severity Override"
	        "SEVERITY_JUSTIFICATION"= "Severity Override Justification"
	    }
	
	    Copy-Item -Path "$Global:testData\Trackers\Sample04_Win2008R2MS.csv" -Destination "TestDrive:\Sample_Win2008R2MS.csv"
	    Copy-Item -Path "$Global:testData\Trackers\Sample05_Win2008R2MS.xlsx" -Destination "TestDrive:\Sample_Win2008R2MS.xlsx"
	
	    Setup -Dir "result"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should create a file (CSV)" {
	            $csvfile = Import-Csv -Path "TestDrive:\Sample_Win2008R2MS.csv"
	            ConvertTo-CKL -Obj $csvfile -version $stigViewerVersion -hostn "Sample" -map $headMappers -ofile $(Join-Path $TestDrive "result\samplecsvV1.ckl")
	            $file = Get-Item -Path "TestDrive:\result\samplecsvV1.ckl"
	            #Remove-Item "TestDrive:\result\sample.ckl"
	            $file.name | Should be "samplecsvV1.ckl"
	        }
	
	        It "Should create a file (XLSX) (Requires Import-XLSX)" {
	            $xlsxfile = Import-XLSX -Path "TestDrive:\Sample_Win2008R2MS.xlsx"
	            ConvertTo-CKL -Obj $xlsxfile -version $stigViewerVersion -hostn "Sample" -map $headMappers -ofile $(Join-Path $TestDrive "result\samplexlsxV1.ckl")
	            $file = Get-Item -Path "TestDrive:\result\samplexlsxV1.ckl"
	            #Remove-Item "TestDrive:\result\sample.ckl"
	            $file.name | Should be "samplexlsxV1.ckl"
	        }
	
	        It "Should create a CKL v1 file (csv) (Requires Import-XML, Import-CKL)" {
	            $xml = Import-XML -Path $(Join-Path $TestDrive "result\samplecsvV1.ckl")
	            $xml.CHECKLIST.VULN | Should Be $true
	        }
	
	        It "Should create a CKL v1 file (xlsx) (Requires Import-XML, Import-CKL)" {
	            $xml2 = Import-XML -Path $(Join-Path $TestDrive "result\samplexlsxV1.ckl")
	            $xml2.CHECKLIST.VULN | Should Be $true
	        }
	
	        It "Should create a CKL v2 file (Requires Import-XML, Import-CKL)" {
	        }
	    }
	}
	
	#Remove-Module $moduleName
	
}
#endregion

#region Call-import-ckl_tests_ps1
function Call-import-ckl_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Import-CKL PS: $PSVersion" {
	
	    Copy-Item "$Global:testData\CKL\CKLv1\sample.ckl" "TestDrive:\sample.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv2\sampleV2.ckl" "TestDrive:\sampleV2.ckl"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Return an Object v1 (Requires Import-XML)" {
	            #$file = Get-Item "TestDrive:\sample.ckl"
	            $file = Get-Item $(Join-Path $TestDrive "sample.ckl")
	            $xml = Import-XML -fileobj $file
	            $Script:ckl = import-ckl -doc $xml
	            $Script:ckl -is [object] | Should Be $True
	        }
	
	        It "Should have used Stig Viewer Version 1 Format (Requires Import-XML)" {
	            $Script:ckl[0].StigViewer_Version | Should Be 1
	        }
	
	        It "Should have 331 items v1 (Requires Import-XML)" {
	            $Script:ckl.count | Should Be 331
	        }
	
	        It "Should have 5 failed items v1 (Requires Import-XML)" {
	            $($Script:ckl | Where-Object{$_.status -eq "open"}).count | Should be 5
	        }
	
	        It "Should Return an Object v2 (Requires Import-XML)" {
	            $file = Get-Item "TestDrive:\sampleV2.ckl"
	            $xml = Import-XML -fileobj $file
	            $Script:ckl = import-ckl -doc $xml
	            $Script:ckl -is [object] | Should Be $True
	        }
	
	        It "Should have used Stig Viewer Version 2 Format (Requires Import-XML)" {
	            $Script:ckl[0].StigViewer_Version | Should Be 2
	        }
	
	        It "Should have 306 items v2 (Requires Import-XML)" {
	            $Script:ckl.count | Should Be 306
	        }
	
	        It "Should have 0 failed items v2 (Requires Import-XML)" {
	            $($Script:ckl | Where-Object{$_.status -eq "open"}) | Should be $null
	        }
	
	    }
	}
	
}
#endregion

#region Call-Compress-Report_tests_ps1
function Call-Compress-Report_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Compress-Report PS: $PSVersion" {
	
	    Setup -Dir CKL
	    Setup -Dir Nessus
	
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample04_Win2008R2MS.ckl" "TestDrive:\CKL\Sample04_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample05_Win2008R2MS.ckl" "TestDrive:\CKL\Sample05_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\Nessus_Scans\Nessus_Sample_Linux.nessus" "TestDrive:\Nessus\Nessus_Sample_Linux.nessus"
	    Copy-Item "$Global:testData\Nessus_Scans\Nessus_Sample_Windows.nessus" "TestDrive:\Nessus\Nessus_Sample_Windows.nessusl"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No report Provided'" {
	            {Compress-Report} | Should Throw "No report Provided"
	        }
	
	        It "Should Throw 'Report Type not selected'" {
	            {Compress-Report -report "FAKE"} | Should Throw "Report Type not selected"
	        }
	
	        It "Should Compress CKL Report (Requires Import-XML, Import-CKL)" {
	            $files = Get-ChildItem -Path "$($TestDrive)\CKL"
	            $compiled = @()
	            foreach ($file in $files) {
	                $xml = Import-XML -fileobj $file
	                $report = Import-CKL -doc $xml
	                $compiled += $report
	            }
	            $filtered = $compiled | Where-Object {$_.Status -match "Open"}
	            $compressed = Compress-Report -report $filtered -ckl
	            $compressed.count -lt $filtered.count | Should Be $true
	        }
	
	        It "Should Compress Nessus Report (Requires Import-XML, Import-Nessus)" {
	            $files = Get-ChildItem -Path "$($TestDrive)\Nessus"
	            $compiled = @()
	            foreach ($file in $files) {
	                $xml = Import-XML -fileobj $file
	                $report = Import-Nessus -doc $xml
	                $compiled += $report
	            }
	            $filtered = $compiled | Where-Object {$_.risk_factor -match "none"}
	            $compressed = Compress-Report -report $filtered -nessus
	            $compressed.count -lt $filtered.count | Should Be $true
	        }
	    }
	}
	
}
#endregion

#region Call-Compress-ZIP_tests_ps1
function Call-Compress-ZIP_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Compress-ZIP PS: $PSVersion" {
	
	    Setup -Dir results
	    Setup -File results\sample.txt
	    Setup -File results\sample1.txt
	    Setup -File results\sample2.txt
	    Setup -File results\sample3.txt
	
	
	    Context "Strict mode" {
	
	        it "Should Throw 'No Source Provided'" {
	            {Compress-ZIP} | Should Throw "No Source Provided"
	        }
	
	        it "Should Throw 'No destination Provided'" {
	            {Compress-ZIP -source TestDrive:\results} | Should Throw "No destination Provided"
	        }
	
	        it "Should create a Zip File" {
	            Compress-ZIP -source $("$TestDrive\results") -destination $("$TestDrive\test.zip")
	            $file = Get-ChildItem -Path "$TestDrive\test.zip"
	            $file.name | Should Be "test.zip"
	        }
	
	        It "Should Throw 'Already Exist'" {
	            {Compress-ZIP -source $("$TestDrive\results") -destination $("$TestDrive\test.zip")} | Should Throw "$($TestDrive)\test.zip Already Exist"
	        }
	    }
	}
	
}
#endregion

#region Call-ConvertTo-RiskElements_tests_ps1
function Call-ConvertTo-RiskElements_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "ConvertTo-RiskElements PS: $PSVersion" {
	
	    Copy-Item "$Global:testData\CKL\CKLv1\Sample04_Win2008R2MS.ckl" "TestDrive:\Sample04_Win2008R2MS.ckl"
	    Copy-Item "$Global:testData\Controls\Sample_DODI_8500_2_Controls.xlsx" "TestDrive:\Sample_DODI_8500_2_Controls.xlsx"
	    Copy-Item "$Global:testData\Nessus_Scans\Nessus_Sample_Windows.nessus" "TestDrive:\Nessus_Sample_Windows.nessus"
	
	    Context "Strict mode" {
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'No report Provided'" {
	            {ConvertTo-RiskElements} | Should Throw "No report Provided"
	        }
	
	        It "Should Throw 'Report Type not selected'" {
	            {ConvertTo-RiskElements -report "FAKE"} | Should Throw "Report Type not selected"
	        }
	
	        It "Should Convert to Risk Elements (CKL) (Requires Import-XLSX, Import-DIACAP, Import-XML, Import-CKL, Compress-Report)" {
	            $file = Get-Item -Path "$($TestDrive)\Sample04_Win2008R2MS.ckl"
	            $xml = Import-XML -fileobj $file
	            $ckl = Import-CKL -doc $xml
	            $filteredCKL = $ckl | Where-Object{$_.Status -match "Open"}
	            $compressedCKL = Compress-Report -Report $filteredCKL -CKL
	            $risk = ConvertTo-RiskElements -report $compressedCKL -ckl
	            $properties = $($risk | Get-Member -MemberType NoteProperty).Name
	            $($properties -contains "Name" -and $properties -contains "Weaknesses" -and $properties -contains "Cat" -and $properties -contains "IA Control" -and $properties -contains "Count" -and $properties -contains "Assessed Risk Level" -and $properties -contains "Quantitative Values") | Should Be $true
	        }
	
	        It "Should Convert to Risk Elements (Nessus) (Requires Import-XLSX, Import-XML, Import-Nessus, Compress-Report)" {
	            $file = Get-Item -Path "$($TestDrive)\Nessus_Sample_Windows.nessus"
	            $xml = Import-XML -fileobj $file
	            $nessus = Import-Nessus -doc $xml
	            $filterednessus = $nessus | Where-Object {$_.risk_factor -notmatch "None"}
	            $compressnessus = compress-report -report $filterednessus -nessus
	            $risk = ConvertTo-RiskElements -report $compressnessus -nessus
	            $properties = $($risk | Get-Member -MemberType NoteProperty).Name
	            $($properties -contains "Name" -and $properties -contains "Weaknesses" -and $properties -contains "Cat" -and $properties -contains "IA Control" -and $properties -contains "Count" -and $properties -contains "Assessed Risk Level" -and $properties -contains "Quantitative Values") | Should Be $true
	        }
	
	        It "Should Convert to Risk Elements (Controls) (Requires Import-XLSX, Import-DIACAP, Import-XML, Import-CKL, Compress-Report)" {
	            $diacapxlsx = Import-XLSX -Path "$($TestDrive)\Sample_DODI_8500_2_Controls.xlsx"
	            $controls = Import-DIACAP -doc $diacapxlsx
	            $final = $controls | Where-Object {$_."Assessment Status" -match "Fail"}
	            $risk = ConvertTo-RiskElements -report $final -diacap
	            $properties = $($risk | Get-Member -MemberType NoteProperty).Name
	            $($properties -contains "Name" -and $properties -contains "Weaknesses" -and $properties -contains "Cat" -and $properties -contains "IA Control" -and $properties -contains "Count" -and $properties -contains "Assessed Risk Level" -and $properties -contains "Quantitative Values") | Should Be $true
	        }
	    }
	}
	
}
#endregion

#region Call-Expand-ZIP_tests_ps1
function Call-Expand-ZIP_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\openports\$sut"
	
	$moduleName = "PSIASTAND"
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	Describe "Expand-ZIP PS: $PSVersion" {
	
	    Setup -Dir results
	    #Setup -Dir expand
	    Setup -File results\sample.txt
	    Setup -File results\sample1.txt
	    Setup -File results\sample2.txt
	    Setup -File results\sample3.txt
	
	    Compress-ZIP -source $("$TestDrive\results") -destination $("$TestDrive\test.zip")
	
	
	    Context "Strict mode" {
	
	        it "Should Throw 'No Source Provided'" {
	            {Expand-ZIP} | Should Throw "No Source Provided"
	        }
	
	        it "Should Throw 'No destination Provided'" {
	            {Expand-ZIP -source $("$TestDrive\test.zip")} | Should Throw "No destination Provided"
	        }
	
	        it "Should extract a Zip File (Requires Compress-ZIP)" {
	            Expand-ZIP -source $("$TestDrive\test.zip") -destination $("$TestDrive\expand")
	            $file = Get-ChildItem -Path "$TestDrive\expand"
	            $file.count | Should Be 4
	        }
	
	        It "Should Throw 'Already Exist'" {
	            {Expand-ZIP -source $("$TestDrive\test.zip") -destination $("$TestDrive\expand")} | Should Throw "$($TestDrive)\expand Already Exist"
	        }
	    }
	}
	
}
#endregion

#region Call-Get-OutPutDir_Tests_ps1
function Call-Get-OutPutDir_Tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\functions\support\$sut"
	
	$moduleName = "PSIASTAND"
	
	#Import-Module "$here\..\..\..\$($moduleName)"
	#InModuleScope nessusOpenPorts {
	    Describe "Get-OutPutDir" {
	        Setup -Dir Temp
	
	        It "should return Path Exsists" {
	            Get-OutPutDir -Path TestDrive:\Temp | Should Be 'Path Exsists'
	        }
	
	        It "should return Created Path" {
	            Get-OutPutDir -Path TestDrive:\Test | Should Be 'Created Path'
	        }
	
	        It "Should Throw No Path Provided" {
	            {Get-OutPutDir} | Should Throw "No Path Provided"
	        }
	
	        It "should throw unable to create at provided path" {
	            {Get-OutPutDir -Path TempDrive:\Test} | Should Throw "unable to create at provided path: TempDrive:\Test"
	        }
	    }
	#}
	#Remove-Module $moduleName
	
}
#endregion

#region Call-Get-Timediff_Tests_ps1
function Call-Get-Timediff_Tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\functions\support\$sut"
	
	$moduleName = "PSIASTAND"
	
	#Import-Module "$here\..\..\..\$($moduleName)"
	#InModuleScope nessusOpenPorts {
	    Describe "Get-Timediff" {
	        It "should return 1 hour difference" {
	            Get-Timediff -Start $(Get-Date -Hour 1 -Minute 1 -Second 1 -Format HH:mm:ss) -End $(Get-Date -Hour 2 -Minute 1 -Second 1 -Format HH:mm:ss) | Should Be "1:0:0"
	        }
	
	        It "should return 1 minute difference" {
	            Get-Timediff -Start $(Get-Date -Hour 1 -Minute 1 -Second 1 -Format HH:mm:ss) -End $(Get-Date -Hour 1 -Minute 2 -Second 1 -Format HH:mm:ss) | Should Be "0:1:0"
	        }
	
	        It "should return 1 second difference" {
	            Get-Timediff -Start $(Get-Date -Hour 1 -Minute 1 -Second 1 -Format HH:mm:ss) -End $(Get-Date -Hour 1 -Minute 1 -Second 2 -Format HH:mm:ss) | Should Be "0:0:1"
	        }
	
	        It "should throw No Start Time Provided" {
	            {Get-Timediff} | Should Throw "No Start Time Provided"
	        }
	
	        It "should throw No End Time Provided" {
	            {Get-Timediff -Start $(Get-Date -Hour 1 -Minute 1 -Second 1 -Format HH:mm:ss)} | Should Throw "No End Time Provided"
	        }
	    }
	#}
	#Remove-Module $moduleName
	
}
#endregion

#region Call-Import-XML_tests_ps1
function Call-Import-XML_tests_ps1
{
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	#$sut = (Split-Path -Leaf $MyInvocation.MyCommand.Path) -replace '\.Tests\.', '.'
	#. "$here\..\..\..\..\functions\nessus\main\$sut"
	
	
	$moduleName = "PSIASTAND"
	
	$PSVersion = $PSVersionTable.PSVersion.Major
	
	#Import-Module "$here\..\..\..\..\$($moduleName)"
	
	Describe "Import-XML PS: $PSVersion"{
	
	    Setup -File sample.xml
	    Setup -File failsample.xml
	    Set-Content -Path TestDrive:\sample.xml -Value @'
<?xml version="1.0" ?>
<note>
    <to>Tove</to>
    <from>Jani</from>
    <heading>Reminder</heading>
    <body>Dont forget me this weekend</body>
</note>
'@
	
	    Set-Content -Path TestDrive:\failsample.xml -Value @'
hello
there
this
is
a
test
'@
	
	    Context 'Strict mode' {
	
	
	
	        Set-StrictMode -Version latest
	
	        It "Should Throw 'no path, string, or fileobj provided'" {
	            {Import-XML} | Should Throw "no path, string, or fileobj provided"
	        }
	
	        It "Should Throw 'Not an XML Document' using the Path Method" {
	            {Import-XML -Path $(Get-item TestDrive:\failsample.xml).fullname} | Should Throw "$($(Get-item TestDrive:\failsample.xml).fullname) Not an XML Document"
	        }
	
	        It "Should Throw 'Not an XML Document' using the String Method" {
	            {Import-XML -string $($(Get-content -path TestDrive:\failsample.xml) -join "")} | Should Throw "Not an XML Document"
	        }
	
	        It "Should Throw 'Not an XML Document' using the fileobj Method" {
	            {Import-XML -fileobj $(Get-item TestDrive:\failsample.xml)} | Should Throw "$($(Get-item TestDrive:\failsample.xml).name) Not an XML Document"
	        }
	
	        It "Should return an XML Object using the Path Method" {
	            $xml = Import-XML -Path $(Get-item TestDrive:\sample.xml).fullname
	            $xml -is [System.Xml.XmlDataDocument] | Should Be $true
	        }
	
	        It "Should return an XML Object using the string Method" {
	            $xml = Import-XML -string $($(Get-content -path TestDrive:\sample.xml) -join "")
	            $xml -is [System.Xml.XmlDataDocument] | Should Be $true
	        }
	
	        It "Should return an XML Object using the fileobj Methon" {
	            $xml = Import-XML -fileobj $(Get-item TestDrive:\sample.xml)
	            $xml -is [System.Xml.XmlDataDocument] | Should Be $true
	        }
	
	    }
	}
	
	#Remove-Module $moduleName
	
}
#endregion

#region Call-Add-PivotChart_ps1
function Call-Add-PivotChart_ps1
{
	function Add-PivotChart {
	    <#
	    .SYNOPSIS
	        Add a pivot chart to an Excel worksheet
	
	    .DESCRIPTION
	        Add a pivot chart to an Excel worksheet
	
	        Note:
	            Each time you call this function, you need to save and re-create your Excel Object.
	            If you attempt to modify the Excel object, save, modify, and save a second time, it will fail.
	            See Save-Excel Passthru parameter for a workaround
	
	    .PARAMETER Path
	        Path to an xlsx file to add the pivot chart to
	
	        If Path is specified and you do not use passthru, we save the file
	
	    .PARAMETER Excel
	        ExcelPackage to add the pivot chart to
	
	        We do not save the ExcelPackage upon completion.  See Save-Excel.
	
	    .PARAMETER PivotTableName
	        Pivot table for chart data. If not specified, we add a chart to all pivot tables
	
	    .PARAMETER TargetWorkSheetName
	        Optional target worksheet for the chart.  If not specified, we use the existing pivot table worksheet
	
	    .PARAMETER ChartName
	        Optional, use this to ensure chart names are unique.  Defaults to CT-<PivotTableName>
	
	    .PARAMETER ChartType
	        If specified, add a chart with this type
	
	    .PARAMETER ChartTitle
	        Optional chart title
	
	    .PARAMETER ChartWidth
	        Width of the chart
	
	    .PARAMETER ChartHeight
	        Height of the chart
	
	    .PARAMETER Passthru
	        If specified, pass the ExcelPackage back
	
	    .EXAMPLE
	
	        Get-ChildItem C:\ -file | Export-XLSX -Path C:\temp\files.xlsx -PivotRows Extension -PivotValues Length
	
	        Add-PivotChart -Path C:\Temp\files.xlsx -ChartType Pie -ChartName CT1
	        Add-PivotChart -Path C:\Temp\files.xlsx -ChartType Area3D -ChartName CT2
	
	        # Get files, create an xlsx in C:\temp\ps.xlsx
	            # Pivot rows on 'Extension'
	            # Pivot values on 'Length'
	
	        # Take the xlsx and add a pie pivot chart
	        # Take the xlsx and add an Area3D pivot chart
	
	        #This example gives you a pie chart breaking down storage by file extension
	
	    .EXAMPLE
	
	        #Create an xlsx and pivot table
	            Get-ChildItem C:\ -file | Export-XLSX -Path C:\temp\files.xlsx -PivotRows Extension -PivotValues Length
	
	        # Open the excel file, add a pivot chart (this won't save), add another pivot chart (this won't save), save.
	            New-Excel -Path C:\temp\files.xlsx |
	                Add-PivotChart -ChartType Pie -ChartTitle "Space per Extension" -ChartWidth 800 -ChartHeight 600 -Passthru |
	                Add-PivotChart -ChartType PieExploded3D -ChartTitle "Why Do I Want This?" -ChartName CT2 -Passthru |
	                Save-Excel -Close
	
	    .NOTES
	        Thanks to Doug Finke for his example
	        This function borrows heavily if not everything from Doug:
	            https://github.com/dfinke/ImportExcel
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelPackage])]
	    [cmdletbinding(DefaultParameterSetName = 'Excel')]
	    param(
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'Excel',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'File',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [validatescript({Test-Path $_})]
	        [string]$Path,
	
	        [parameter( Position = 1,
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [string]$PivotTableName = '*',
	
	        [parameter( Position = 2,
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [string]$TargetWorkSheetName,
	
	        [string]$ChartName = 'Chart1',
	
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.Drawing.Chart.eChartType]$ChartType,
	
	        [string]$ChartTitle,
	
	        [int]$ChartWidth = 600,
	
	        [int]$ChartHeight = 400,
	
	        [switch]$Passthru
	    )
	    Process
	    {
	
	        Write-Verbose "PSBoundParameters: $($PSBoundParameters | Out-String)"
	        $SourceWS = @{}
	
	        #Find sheets with pivot tables
	            Try
	            {
	                if($PSCmdlet.ParameterSetName -like 'File')
	                {
	                    $Excel = New-Excel -Path $Path -ErrorAction Stop
	                }
	
	                $PivotTableWorkSheets = @( $Excel | Get-Worksheet -ErrorAction Stop | Where-Object {$_.PivotTables} )
	            }
	            Catch
	            {
	                Throw "Could not get ExcelPackage or Worksheets to search: $_"
	            }
	
	        #Filter those tables
	            If($PivotTableWorkSheets.Count -eq 0)
	            {
	                Throw "Something went wrong, we didn't find any worksheets with a pivot table"
	            }
	            else
	            {
	                $PivotTables = @( $PivotTableWorkSheets | Select -ExpandProperty PivotTables | Where-Object {$_.Name -Like $PivotTableName})
	            }
	
	        if($PivotTables.count -gt 0)
	        {
	            Foreach($PivotTable in $PivotTables)
	            {
	
	                #No chart name? Take the pivottable name, prepend CT
	                    if(-not $PSBoundParameters.ContainsKey('ChartName'))
	                    {
	                        $ChartName = "CT-$( $PivotTable.Name )"
	                    }
	
	                #We need a worksheet for the chart
	                    if( @( $Excel.WorkBook.Worksheets | Select -ExpandProperty Name -ErrorAction SilentlyContinue) -notcontains $TargetWorkSheetName)
	                    {
	                        $TargetWorkSheet = $Excel.Workbook.Worksheets | Where-Object {$_.Name -like $PivotTable.Worksheet.Name}
	                        Write-Verbose "Could not find target worksheet '$TargetWorkSheetName', picking $($TargetWorkSheet.Name)"
	                    }
	                    else
	                    {
	                        $TargetWorkSheet = $Excel.Workbook.Worksheets[$TargetWorkSheetName]
	                    }
	
	                #We need to avoid dupes
	                    if( @( $TargetWorkSheet.Drawings | Select -ExpandProperty Name -ErrorAction SilentlyContinue) -contains $ChartName)
	                    {
	                        Write-Error "Duplicate drawing found for ChartName '$ChartName', please specify a unique chart name"
	                        continue
	                    }
	
	                #We have all we need, create the chart!
	                    Write-Verbose "Adding $ChartType chart"
	
	                    $chart = $TargetWorkSheet.Drawings.AddChart("$ChartName", $ChartType, $PivotTable)
	                    $chart.SetPosition(1, 0, 6, 0)
	                    $chart.SetSize($ChartWidth, $ChartHeight)
	                    if($ChartTitle)
	                    {
	                        $chart.title.text = $ChartTitle
	                    }
	            }
	        }
	        else
	        {
	            Throw "Found no pivot tables matching '$PivotTableName'.  Existing pivot tables:`n$($PivotTableWorkSheets | Select -ExpandProperty PivotTables | Select -ExpandProperty Name )"
	        }
	
	        #Clean up
	            if($PSCmdlet.ParameterSetName -like 'File' -and -not $Passthru)
	            {
	                Write-Verbose "Saving '$($Excel.File)'"
	                $Excel.save()
	                $Excel.Dispose()
	            }
	            if($Passthru)
	            {
	                $Excel
	            }
	    }
	}
	
}
#endregion

#region Call-Add-PivotTable_ps1
function Call-Add-PivotTable_ps1
{
	function Add-PivotTable {
	    <#
	    .SYNOPSIS
	        Add a pivot table to an Excel worksheet
	
	    .DESCRIPTION
	        Add a pivot table to an Excel worksheet
	
	        Note:
	            Each time you call this function, you need to save and re-create your Excel Object.
	            If you attempt to modify the Excel object, save, modify, and save a second time, it will fail.
	            See Save-Excel Passthru parameter for a workaround
	
	    .PARAMETER Path
	        Path to an xlsx file to add the pivot table to
	
	        If Path is specified and you do not use passthru, we save the file
	
	    .PARAMETER Excel
	        ExcelPackage to add the pivot table to
	
	        We do not save the ExcelPackage upon completion.  See Save-Excel.
	
	    .PARAMETER WorksheetName
	        If specified, use this worksheet as the source.
	
	    .PARAMETER StartRow
	        The top row for pivottable data.  If not specified, we use the dimensions start row
	
	    .PARAMETER StartColumn
	        The leftmost column for pivottable data.  If not specified, we use the dimensions start column
	
	    .PARAMETER EndRow
	        The bottom row for pivottable data.  If not specified, we use the dimensions' end row
	
	    .PARAMETER EndColumn
	        The rightmost column for pivottable data.  If not specified, we use the dimensions' end column
	
	    .PARAMETER PivotTableWorksheetName
	        Name for the WorkSheet we create for the pivottable
	
	    .PARAMETER PivotData
	        Pivot data
	
	    .PARAMETER PivotRows
	        Pivot on these rows
	
	    .PARAMETER PivotColumns
	        Pivot on these columns
	
	    .PARAMETER ChartType
	        If specified, add a chart with this type
	
	    .PARAMETER ChartTitle
	        Optional chart title
	
	    .PARAMETER ChartWidth
	        Width of the chart
	
	    .PARAMETER ChartHeight
	        Height of the chart
	
	    .PARAMETER Passthru
	        If specified, pass the ExcelPackage back
	
	    .EXAMPLE
	
	        Get-ChildItem C:\ -file | Export-XLSX -Path C:\temp\files.xlsx
	
	        Add-PivotTable -Path C:\Temp\files.xlsx -PivotRows Extension -PivotValues Length -ChartType PieExploded3D
	
	        # Get files, create an xlsx in C:\temp\ps.xlsx
	
	        # Take existing xlsx and add a pivot chart
	            # Pivot rows on 'Extension'
	            # Pivot values on 'Length'
	            # Add an exploding pie chart!
	
	        #This example gives you a pie chart breaking down storage by file extension
	
	    .EXAMPLE
	
	        #Create an xlsx.
	            Get-ChildItem C:\ -file | Export-XLSX -Path C:\temp\files.xlsx
	
	        # Open the excel file, add a pivot table (this won't save), pass through the excel object, save.
	            New-Excel -Path C:\temp\files.xlsx |
	                Add-PivotTable -PivotRows Extension -PivotValues Length -ChartType Pie -ChartTitle "Space per Extension" -ChartWidth 800 -ChartHeight 600 -Passthru |
	                Save-Excel -Close
	
	    .NOTES
	        Thanks to Doug Finke for his example
	        This function borrows heavily if not everything from Doug:
	            https://github.com/dfinke/ImportExcel
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelPackage])]
	    [cmdletbinding(DefaultParameterSetName = 'Excel')]
	    param(
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'Excel',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'File',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [validatescript({Test-Path $_})]
	        [string]$Path,
	
	        [parameter( Position = 1,
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [string]$WorkSheetName,
	
	        [parameter( Position = 2,
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [string]$PivotTableWorksheetName = 'PivotTable1',
	
	        [parameter(
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$StartRow,
	
	        [parameter(
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$StartColumn,
	
	        [parameter(
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$EndRow,
	
	        [parameter(
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$EndColumn,
	
	        [string[]]$PivotRows,
	        [string[]]$PivotColumns,
	        [string[]]$PivotValues,
	
	        [OfficeOpenXml.Drawing.Chart.eChartType]$ChartType,
	        [string]$ChartTitle,
	        [int]$ChartWidth = 600,
	        [int]$ChartHeight = 400,
	
	        [switch]$Passthru
	    )
	    Process
	    {
	
	        Write-Verbose "PSBoundParameters: $($PSBoundParameters | Out-String)"
	        $SourceWS = @{}
	        if($PSBoundParameters.ContainsKey( 'WorkSheetName') )
	        {
	            $SourceWS.Add('Name',$WorkSheetName)
	        }
	
	        Try
	        {
	            if($PSCmdlet.ParameterSetName -like 'File')
	            {
	                $Excel = New-Excel -Path $Path -ErrorAction Stop
	            }
	
	            $WorkSheets = @( $Excel | Get-Worksheet @SourceWS -ErrorAction Stop )
	        }
	        Catch
	        {
	            Throw "Could not get worksheets to search: $_"
	        }
	
	        If($WorkSheets.Count -eq 0)
	        {
	            Throw "Something went wrong, we didn't find a worksheet"
	        }
	
	        Foreach($SourceWorkSheet in $WorkSheets)
	        {
	            if($WorkSheets.count -gt 1)
	            {
	                $PivotTableWorksheetName = "$PivotTableWorksheetName-$($SourceWorkSheet.Name)"
	            }
	
	            Try
	            {
	                if( @( $Excel.WorkBook.Worksheets | Select -ExpandProperty Name -ErrorAction SilentlyContinue) -contains $PivotTableWorksheetName)
	                {
	                    Write-Error "Skipping existing worksheet '$PivotTableWorksheetName'"
	                    continue
	                }
	                else
	                {
	                    Write-Verbose "Adding pivot worksheet $PivotTableWorksheetName"
	                    $PivotWorkSheet = $Excel.Workbook.Worksheets.Add($PivotTableWorksheetName)
	                }
	            }
	            Catch
	            {
	                Throw "Could not add PivotTable: $_"
	            }
	
	            #Get the coordinates
	                $dimension = $SourceWorkSheet.Dimension
	
	                If(-not $StartRow)
	                {
	                    $StartRow = $dimension.Start.Row
	                }
	                If(-not $StartColumn)
	                {
	                    $StartColumn = $dimension.Start.Column
	                }
	                If(-not $EndRow)
	                {
	                    $EndRow = $dimension.End.Row
	                }
	                If(-not $EndColumn)
	                {
	                    $EndColumn = $dimension.End.Column
	                }
	
	                $Start = ConvertTo-ExcelCoordinate -Row $StartRow -Column $StartColumn
	                $End = ConvertTo-ExcelCoordinate -Row $EndRow -Column $EndColumn
	                $RangeCoordinates = "$Start`:$End"
	
	                Write-Verbose "Adding pivot table over data range '$RangeCoordinates' with name PT$PivotTableWorksheetName"
	
	            #Pivot! Borrowed from Doug Finke - thanks Doug!
	                #$PivotWorkSheet.View.TabSelected = $True
	                $PivotTable = $PivotWorkSheet.PivotTables.Add($PivotWorkSheet.Cells["A1"], $SourceWorkSheet.Cells[$RangeCoordinates], "PT$PivotTableWorksheetName")
	
	                if($PivotRows)
	                {
	                    Write-Verbose "Adding PivotRows $PivotRows"
	
	                    foreach ($Row in @($PivotRows | Select -Unique))
	                    {
	                        [void]$PivotTable.RowFields.Add($PivotTable.Fields[$Row])
	                    }
	                }
	
	                if($PivotColumns)
	                {
	                    Write-Verbose "Adding PivotColumns $PivotColumns"
	
	                    foreach ($Column in @($PivotColumns | Select -Unique))
	                    {
	                        [void]$PivotTable.ColumnFields.Add($PivotTable.Fields[$Column])
	                    }
	                }
	
	                if($PivotValues)
	                {
	                    Write-Verbose "Adding PivotValues $PivotValues"
	
	                    foreach ($Value in @($PivotValues | Select -Unique))
	                    {
	                        [void]$PivotTable.DataFields.Add($PivotTable.Fields[$Value])
	                    }
	                }
	
	                if($ChartType)
	                {
	
	                    Write-Verbose "Adding $ChartType chart"
	                    $chart = $PivotWorkSheet.Drawings.AddChart("PC$PivotTableWorksheetName", $ChartType, $PivotTable)
	                    $chart.SetPosition(1, 0, 6, 0)
	                    $chart.SetSize($ChartWidth, $ChartHeight)
	                    if($ChartTitle)
	                    {
	                        $chart.title.text = $ChartTitle
	                    }
	                }
	
	            if($PSCmdlet.ParameterSetName -like 'File' -and -not $Passthru)
	            {
	                Write-Verbose "Saving '$($Excel.File)'"
	                $Excel.save()
	                $Excel.Dispose()
	            }
	            if($Passthru)
	            {
	                $Excel
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Add-Table_ps1
function Call-Add-Table_ps1
{
	function Add-Table {
	    <#
	    .SYNOPSIS
	        Add a table to an Excel worksheet
	
	    .DESCRIPTION
	        Add a table to an Excel worksheet
	
	        Note:
	            Each time you call this function, you need to save and re-create your Excel Object.
	            If you attempt to modify the Excel object, save, modify, and save a second time, it will fail.
	            See Save-Excel Passthru parameter for a workaround
	
	    .PARAMETER Path
	        Path to an xlsx file to add the table to
	
	        If Path is specified and you do not use passthru, we save the file
	
	    .PARAMETER Excel
	        ExcelPackage to add the table to
	
	        We do not save the ExcelPackage upon completion.  See Save-Excel.
	
	    .PARAMETER WorkSheetName
	        If specified, use this worksheet as the source.
	
	    .PARAMETER StartRow
	        The top row for table data.  If not specified, we use the dimensions start row
	
	    .PARAMETER StartColumn
	        The leftmost column for table data.  If not specified, we use the dimensions start column
	
	    .PARAMETER EndRow
	        The bottom row for table data.  If not specified, we use the dimensions' end row
	
	    .PARAMETER EndColumn
	        The rightmost column for table data.  If not specified, we use the dimensions' end column
	
	    .PARAMETER TableStyle
	        Style of the table
	
	    .PARAMETER TableName
	        Name of the table, defaults to worksheet name if none provided
	
	    .PARAMETER Passthru
	        If specified, pass the ExcelPackage back
	
	    .EXAMPLE
	
	        Get-ChildItem C:\ -file | Export-XLSX -Path C:\temp\files.xlsx
	
	        Add-Table -Path C:\Temp\files.xlsx -TableStyle Medium10
	
	        # Get files, create an xlsx in C:\temp\ps.xlsx
	
	        # Take existing xlsx and add a table with the Medium10 style
	
	    .EXAMPLE
	        # Create an xlsx.
	            Get-ChildItem C:\ -file | Export-XLSX -Path C:\temp\files.xlsx
	
	        # Open the excel file, add a table (this won't save), pass through the excel object, save.
	            New-Excel -Path C:\temp\files.xlsx |
	                Add-Table -TableStyle Medium10 -TableName "Files" -Passthru |
	                Save-Excel -Close
	
	    .NOTES
	        Added by Andrew Widdersheim
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelPackage])]
	    [cmdletbinding(DefaultParameterSetName = 'Excel')]
	    param(
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'Excel',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'File',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [validatescript({Test-Path $_})]
	        [string]$Path,
	
	        [parameter( Position = 1,
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [string]$WorkSheetName,
	
	        [parameter(
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$StartRow,
	
	        [parameter(
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$StartColumn,
	
	        [parameter(
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$EndRow,
	
	        [parameter(
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$EndColumn,
	
	        [OfficeOpenXml.Table.TableStyles]$TableStyle,
	
	        [string]$TableName,
	
	        [switch]$Passthru
	    )
	    Process
	    {
	        Write-Verbose "PSBoundParameters: $($PSBoundParameters | Out-String)"
	        $SourceWS = @{}
	        if($PSBoundParameters.ContainsKey( 'WorkSheetName') )
	        {
	            $SourceWS.Add('Name',$WorkSheetName)
	        }
	
	        Try
	        {
	            if($PSCmdlet.ParameterSetName -like 'File')
	            {
	                $Excel = New-Excel -Path $Path -ErrorAction Stop
	            }
	
	            $WorkSheets = @( $Excel | Get-Worksheet @SourceWS -ErrorAction Stop )
	        }
	        Catch
	        {
	            Throw "Could not get worksheets to search: $_"
	        }
	
	        If($WorkSheets.Count -eq 0)
	        {
	            Throw "Something went wrong, we didn't find a worksheet"
	        }
	
	        Foreach($SourceWorkSheet in $WorkSheets)
	        {
	            # Get the coordinates
	                $dimension = $SourceWorkSheet.Dimension
	
	                If(-not $StartRow)
	                {
	                    $StartRow = $dimension.Start.Row
	                }
	                If(-not $StartColumn)
	                {
	                    $StartColumn = $dimension.Start.Column
	                }
	                If(-not $EndRow)
	                {
	                    $EndRow = $dimension.End.Row
	                }
	                If(-not $EndColumn)
	                {
	                    $EndColumn = $dimension.End.Column
	                }
	
	                $Start = ConvertTo-ExcelCoordinate -Row $StartRow -Column $StartColumn
	                $End = ConvertTo-ExcelCoordinate -Row $EndRow -Column $EndColumn
	                $RangeCoordinates = "$Start`:$End"
	
	                if(-not $TableName)
	                {
	                    $TableWorksheetName = $SourceWorkSheet.Name
	                }
	                else
	                {
	                    $TableWorksheetName = $TableName
	                }
	
	                Write-Verbose "Adding table over data range '$RangeCoordinates' with name $TableWorksheetName"
	                $Table = $SourceWorkSheet.Tables.Add($SourceWorkSheet.Cells[$RangeCoordinates], $TableWorksheetName)
	
	                if($TableStyle)
	                {
	                    Write-Verbose "Adding $TableStyle table style"
	                    $Table.TableStyle = $TableStyle
	                }
	
	            if($PSCmdlet.ParameterSetName -like 'File' -and -not $Passthru)
	            {
	                Write-Verbose "Saving '$($Excel.File)'"
	                $Excel.save()
	                $Excel.Dispose()
	            }
	            if($Passthru)
	            {
	                $Excel
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Close-Excel_ps1
function Call-Close-Excel_ps1
{
	function Close-Excel {
	    <#
	    .SYNOPSIS
	        Close an OfficeOpenXml ExcelPackage
	
	    .DESCRIPTION
	        Close an OfficeOpenXml ExcelPackage
	
	    .PARAMETER Excel
	        An ExcelPackage object to close
	
	    .PARAMETER Save
	        Save the ExcelPackage before closing
	
	    .PARAMETER Path
	        If specified, Save the ExcelPackage as this path before closing
	
	    .EXAMPLE
	        Close-Excel -Excel $Excel -Save
	
	        #Save and close $Excel
	
	    .EXAMPLE
	        Close-Excel -Excel $Excel
	
	        #Close $Excel without saving
	
	    .EXAMPLE
	        Close-Excel -Excel $Excel -Path C:\new.xlsx
	
	        #Save $Excel as C:\new.xlsx and close
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [cmdletbinding()]
	    param(
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [Switch]$Save,
	
	        [parameter( Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [validatescript({
	            $Parent = Split-Path $_ -Parent -ErrorAction SilentlyContinue
	            if( -not (Test-Path -Path $Parent -PathType Container -ErrorAction SilentlyContinue) )
	            {
	                Throw "Specify a valid path.  Parent '$Parent' does not exist: $_"
	            }
	            $True
	        })]
	        [string]$Path
	    )
	    Process
	    {
	        foreach($xl in $Excel)
	        {
	            Try
	            {
	                if($Path)
	                {
	                    Try
	                    {
	                        #Resolve relative paths... Thanks Oisin! http://stackoverflow.com/a/3040982/3067642
	                        $Path = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($Path)
	                    }
	                    Catch
	                    {
	                        Write-Error "Could not resolve path for '$Path': $_"
	                        continue
	                    }
	
	                    write-verbose "Saving $($xl.File) as $($Path)"
	
	                    $xl.saveas($Path)
	                }
	                elseif($Save)
	                {
	                    write-verbose "Saving $($xl.File)"
	
	                    $xl.save()
	                }
	            }
	            Catch
	            {
	                Write-Error "Error saving file.  Will not close this ExcelPackage: $_"
	                Continue
	            }
	
	            Try
	            {
	                write-verbose "Closing $($xl.File)"
	
	                $xl.Dispose()
	                $xl = $null
	            }
	            Catch
	            {
	                Write-Error $_
	                Continue
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-ConvertTo-ExcelCoordinate_ps1
function Call-ConvertTo-ExcelCoordinate_ps1
{
	Function ConvertTo-ExcelCoordinate
	{
	    <#
	    .SYNOPSIS
	        Convert a row and column to an Excel coordinate
	
	    .DESCRIPTION
	        Convert a row and column to an Excel coordinate
	
	    .PARAMETER Row
	        Row number
	
	    .PARAMETER Column
	        Column number
	
	    .EXAMPLE
	        ConvertTo-ExcelCoordinate -Row 1 -Column 2
	
	        #Get Excel coordinates for Row 1, Column 2.  B1.
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([system.string])]
	    [cmdletbinding()]
	    param(
	        [int]$Row,
	        [int]$Column
	    )
	
	        #From http://stackoverflow.com/questions/297213/translate-a-column-index-into-an-excel-column-name
	        Function Get-ExcelColumn
	        {
	            param([int]$ColumnIndex)
	
	            [string]$Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
	
	            $ColumnIndex -= 1
	            [int]$Quotient = [math]::floor($ColumnIndex / 26)
	
	            if($Quotient -gt 0)
	            {
	                ( Get-ExcelColumn -ColumnIndex $Quotient ) + $Chars[$ColumnIndex % 26]
	            }
	            else
	            {
	                $Chars[$ColumnIndex % 26]
	            }
	        }
	
	    $ColumnIndex = Get-ExcelColumn $Column
	    "$ColumnIndex$Row"
	}
	
}
#endregion

#region Call-Export-XLSX_ps1
function Call-Export-XLSX_ps1
{
	Function Export-XLSX {
	    <#
	    .SYNOPSIS
	        Export data to an XLSX file
	
	    .DESCRIPTION
	        Export data to an XLSX file
	
	    .PARAMETER InputObject
	        Data to export
	
	    .PARAMETER Path
	        Path to the file to export
	
	    .PARAMETER WorksheetName
	        Name the worksheet you are importing to
	
	    .PARAMETER Header
	        Header to use. Must match order and count of your data's properties
	
	    .PARAMETER AutoFit
	        If specified, autofit everything
	
	    .PARAMETER PivotRows
	        If specified, add pivot table pivoting on these rows
	
	    .PARAMETER PivotColumns
	        If specified, add pivot table pivoting on these columns
	
	    .PARAMETER PivotValues
	        If specified, add pivot table pivoting on these values
	
	    .PARAMETER ChartType
	        If specified, add pivot chart of this type
	
	    .PARAMETER Table
	        If specified, add table to all cells
	
	    .PARAMETER TableStyle
	        If specified, add table style
	
	    .PARAMETER Append
	        If specified, append to existing worksheet.
	
	        We don't check header names, but header count must match.
	
	    .PARAMETER Force
	        If file exists, overwrite it.
	
	    .PARAMETER ClearSheet
	        If worksheet with the same name exists, clear it before filling it in
	
	    .PARAMETER RemoveSheet
	        If worksheet with the same name exists, remove it and re-add it
	
	    .PARAMETER Passthru
	        If specified, we re-open the ExcelPackage and return it
	
	    .EXAMPLE
	        $Files = Get-ChildItem C:\ -File
	
	        Export-XLSX -Path C:\Files.xlsx -InputObject $Files
	
	        Export file listing to C:\Files.xlsx
	
	    .EXAMPLE
	        $Files = Get-ChildItem C:\ -File
	
			$Worksheet = 'Files'
	
	        Export-XLSX -Path C:\temp\Files.xlsx -InputObject $Files -WorksheetName $Worksheet -ClearSheet
	
	        Export file listing to C:\temp\Files.xlsx to the worksheet named "Files".  If it exists already, clear the sheet then import the data.
	
	    .EXAMPLE
	
	        1..10 | Foreach-Object {
	            New-Object -typename PSObject -Property @{
	                Something = "Prop$_"
	                Value = Get-Random
	            }
	        } |
	            Select-Object Something, Value |
	            Export-XLSX -Path C:\Random.xlsx -Force -Header Name, Val
	
	        # Generate data
	        # Send it to Export-XLSX
	        # Give it new headers
	        # Overwrite C:\random.xlsx if it exists
	
	    .EXAMPLE
	
	        # Create XLSX
	        Get-ChildItem -file | Export-XLSX -Path C:\temp\multi.xlsx
	
	        # Add a second worksheet to the xlsx
	        Get-ChildItem -file | Export-XLSX -Path C:\temp\multi.xlsx -WorksheetName "Two"
	
	    .EXAMPLE
	
	        # Create XLSX
	        Get-ChildItem -file | Export-XLSX -Path C:\temp\multi.xlsx
	
	        # Add a second worksheet to the xlsx
	        Get-ChildItem -file | Export-XLSX -Path C:\temp\multi.xlsx -WorksheetName "Two"
	
	        # I don't like that second worksheet. Recreate it, deleting the existing worksheet if it exists.
	        Get-ChildItem -file | Select -first 1 | Export-XLSX -Path C:\temp\multi.xlsx -WorksheetName "Two" -ReplaceSheet
	
	    .EXAMPLE
	
	        Get-ChildItem C:\ -file |
	            Export-XLSX -Path C:\temp\files.xlsx -PivotRows Extension -PivotValues Length -ChartType Pie
	
	        # Get files
	        # Create an xlsx in C:\temp\files.xlsx
	        # Pivot rows on 'Extension'
	        # Pivot values on 'Length
	        # Add a pie chart
	
	        # This example gives you a pie chart breaking down storage by file extension
	
	    .EXAMPLE
	
		    Get-Process | Export-XLSX -Path C:\temp\process.xlsx -Worksheet process -Table -TableStyle Medium1 -AutoFit
	
		    # Get all processes
		    # Create an xlsx
		    # Create a table with the Medium1 style and all cells autofit on the 'process' worksheet
	
	    .EXAMPLE
	
	    #
	    # This example illustrates appending data
	
	        1..10 | Foreach-Object {
	            New-Object -typename PSObject -Property @{
	                Something = "Prop$_"
	                Value = Get-Random
	            }
	        } |
	            Select-Object Something, Value |
	            Export-XLSX -Path C:\Random.xlsx -Force
	
	        # Generate data
	        # Send it to Export-XLSX
	        # Overwrite C:\random.xlsx if it exists
	
	        1..5 | Foreach-Object {
	            New-Object -typename PSObject -Property @{
	                Something = "Prop$_"
	                Value = Get-Random
	            }
	        } |
	            Select-Object Something, Value |
	            Export-XLSX -Path C:\Random.xlsx -Append
	
	        # Generate data
	        # Send it to Export-XLSX
	        # Append to C:\random.xlsx
	
	    .NOTES
	        Thanks to Doug Finke for his example
	        The pivot stuff is straight from Doug:
	            https://github.com/dfinke/ImportExcel
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [CmdletBinding(DefaultParameterSetName='Path')]
	    param(
	        [parameter( ParameterSetName='Path',
	                    Position = 0,
	                    Mandatory=$true )]
	        [ValidateScript({
	            $Parent = Split-Path $_ -Parent
	            if( -not (Test-Path -Path $Parent -PathType Container) )
	            {
	                Throw "Specify a valid path.  Parent '$Parent' does not exist: $_"
	            }
	            $True
	        })]
	        [string]$Path,
	
	        [parameter( ParameterSetName='Excel',
	                    Position = 0,
	                    Mandatory=$true )]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [parameter( Position = 1,
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromRemainingArguments=$false)]
	        $InputObject,
	
	        [string[]]$Header,
	
	        [string]$WorksheetName = "Worksheet1",
	
	        [string[]]$PivotRows,
	
	        [string[]]$PivotColumns,
	
	        [string[]]$PivotValues,
	
	        [OfficeOpenXml.Drawing.Chart.eChartType]$ChartType,
	
	        [switch]$Table,
	
	        [OfficeOpenXml.Table.TableStyles]$TableStyle = [OfficeOpenXml.Table.TableStyles]"Medium2",
	
	        [switch]$AutoFit,
	
	        [switch]$Append,
	
	        [switch]$Force,
	
			[switch]$ClearSheet,
	
	        [switch]$ReplaceSheet,
	
	        [switch]$Passthru
	    )
	    begin
	    {
	        if ( $PSBoundParameters.ContainsKey('Path'))
	        {
	            if ( Test-Path $Path )
	            {
	                if($Append)
	                {
	                    Write-Verbose "'$Path' exists. Appending data"
	                }
	                elseif($Force)
	                {
	                    Try
	                    {
	                        Remove-Item -Path $Path -Force -Confirm:$False
	                    }
	                    Catch
	                    {
	                        Throw "'$Path' exists and could not be removed: $_"
	                    }
	                }
	                else
	                {
	                    Write-Verbose "'$Path' exists. Use -Force to overwrite. Attempting to add sheet to existing workbook"
	                }
	            }
	
	            #Resolve relative paths... Thanks Oisin! http://stackoverflow.com/a/3040982/3067642
	            $Path = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($Path)
	        }
	
	        Write-Verbose "Export-XLSX '$($PSCmdlet.ParameterSetName)' PSBoundParameters = $($PSBoundParameters | Out-String)"
	
	        $bound = $PSBoundParameters.keys -contains "InputObject"
	        if(-not $bound)
	        {
	            [System.Collections.ArrayList]$AllData = @()
	        }
	    }
	    process
	    {
	        #We write data by row, so need everything countable, not going to stream...
	        if($bound)
	        {
	            $AllData = $InputObject
	        }
	        Else
	        {
	            foreach($Object in $InputObject)
	            {
	                [void]$AllData.add($Object)
	            }
	        }
	    }
	    end
	    {
	        #Deal with headers
	            $ExistingHeader = @(
	
	                # indexes might be an issue if we get array of strings, so select first
	                ($AllData | Select -first 1).PSObject.Properties |
	                    Select -ExpandProperty Name
	            )
	
	            $Columns = $ExistingHeader.count
	
	            if($Header)
	            {
	                if($Header.count -ne $ExistingHeader.count)
	                {
	                    Throw "Found '$columns' columns, provided $($header.count) headers.  You must provide a header for every column."
	                }
	            }
	            else
	            {
	                $Header = $ExistingHeader
	            }
	
	        #initialize stuff
	            $RowIndex = 2
	            Try
	            {
	                if( $PSBoundParameters.ContainsKey('Path'))
	                {
	                    $Excel = New-Object OfficeOpenXml.ExcelPackage($Path) -ErrorAction Stop
	                }
	                else
	                {
	                    $Path = $Excel.File.FullName
	                }
	
	                $Workbook = $Excel.Workbook
	                if($ReplaceSheet)
	                {
	                    Try
	                    {
	                        Write-Verbose "Attempting to delete worksheet $WorksheetName"
	                        $Workbook.Worksheets.Delete($WorksheetName)
	                    }
	                    Catch
	                    {
	                        if($_.Exception -notmatch 'Could not find worksheet to delete')
	                        {
	                            Write-Error "Error removing worksheet $WorksheetName"
	                            Throw $_
	                        }
	                    }
	                }
	
	                #If we have an excel or valid path, try to append or clearsheet as needed
	                if (($Append -or $ClearSheet) -and ($PSBoundParameters.ContainsKey('Excel') -or (Test-Path $Path)) )
	                {
	                    $WorkSheet=$Excel.Workbook.Worksheets | Where-Object {$_.Name -like $WorkSheetName}
	                    if($ClearSheet)
	                    {
	                        $WorkSheet.Cells[$WorkSheet.Dimension.Start.Row, $WorkSheet.Dimension.Start.Column, $WorkSheet.Dimension.End.Row, $WorkSheet.Dimension.End.Column].Clear()
	                    }
	                    if($Append)
	                    {
	                        $RealHeaderCount = $WorkSheet.Dimension.Columns
	                        if($Header.count -ne $RealHeaderCount)
	                        {
	                            $Excel.Dispose()
	                            Throw "Found $RealHeaderCount existing headers, provided data has $($Header.count)."
	                        }
	                        $RowIndex = 1 + $Worksheet.Dimension.Rows
	                    }
	                }
	                else
	                {
	                    $WorkSheet = $Workbook.Worksheets.Add($WorkSheetName)
	                }
	            }
	            Catch
	            {
	                Throw "Failed to initialize Excel, Workbook, or Worksheet. Try -ClearSheet switch if worksheet already exists:`n`n_"
	            }
	
	        #Set those headers if we aren't appending
	            if(-not $Append)
	            {
	                for ($ColumnIndex = 1; $ColumnIndex -le $Header.count; $ColumnIndex++)
	                {
	                    $WorkSheet.SetValue(1, $ColumnIndex, $Header[$ColumnIndex - 1])
	                }
	            }
	
	        #Write the data...
	            foreach($RowData in $AllData)
	            {
	                Write-Verbose "Working on object:`n$($RowData | Out-String)"
	                for ($ColumnIndex = 1; $ColumnIndex -le $Header.count; $ColumnIndex++)
	                {
	                    $Object = @($RowData.PSObject.Properties)[$ColumnIndex - 1]
	                    $Value = $Object.Value
	                    $WorkSheet.SetValue($RowIndex, $ColumnIndex, $Value)
	
	                    Try
	                    {
	                        #Nulls will error, catch them
	                        $ThisType = $Null
	                        $ThisType = $Value.GetType().FullName
	                    }
	                    Catch
	                    {
	                        Write-Verbose "Applying no style to null in row $RowIndex, column $ColumnIndex"
	                    }
	
	                    #Idea from Philip Thompson, thank you Philip!
	                    $StyleName = $Null
	                    $ExistingStyles = @($WorkBook.Styles.NamedStyles | Select -ExpandProperty Name)
	                    Switch -regex ($ThisType)
	                    {
	                        "double|decimal|single"
	                        {
	                            $StyleName = 'decimals'
	                            $StyleFormat = "0.00"
	                        }
	                        "int\d\d$"
	                        {
	                            $StyleName = 'ints'
	                            $StyleFormat = "0"
	                        }
	                        "datetime"
	                        {
	                            $StyleName = "dates"
	                            $StyleFormat = "M/d/yyy h:mm"
	                        }
	                        "TimeSpan"
	                        {
	                            #Open to other ways to handle this
	                            $WorkSheet.SetValue($RowIndex, $ColumnIndex, "$Value")
	                        }
	                        default
	                        {
	                            #No default yet...
	                        }
	                    }
	
	                    if($StyleName)
	                    {
	                        if($ExistingStyles -notcontains $StyleName)
	                        {
	                            $StyleSheet = $WorkBook.Styles.CreateNamedStyle($StyleName)
	                            $StyleSheet.Style.Numberformat.Format = $StyleFormat
	                        }
	
	                        $WorkSheet.Cells.Item($RowIndex, $ColumnIndex).Stylename = $StyleName
	                    }
	
	                }
	                Write-Verbose "Wrote row $RowIndex"
	                $RowIndex++
	            }
	
	            # Any pivot params specified?  add a pivot!
	            if($PSBoundParameters.Keys -match 'Pivot')
	            {
	                $Params = @{}
	                if($PivotRows)    {$Params.Add('PivotRows',$PivotRows)}
	                if($PivotColumns) {$Params.Add('PivotColumns',$PivotColumns)}
	                if($PivotValues)  {$Params.Add('PivotValues',$PivotValues)}
	                if($ChartType)    {$Params.Add('ChartType',$ChartType)}
	                $Excel = Add-PivotTable @Params -Excel $Excel -WorkSheetName $WorksheetName -Passthru -ErrorAction stop
	
	            }
	
	            # Create table
	            elseif($Table)
	            {
	                $Excel = Add-Table -Excel $Excel -WorkSheetName $WorksheetName -TableStyle $TableStyle -Passthru
	            }
	
	            if($AutoFit)
	            {
	                $WorkSheet.Cells[$WorkSheet.Dimension.Address].AutoFitColumns()
	            }
	
	            # This is an export command. Save whether we have a path or ExcelPackage input...
	            $Excel.SaveAs($Path)
	
	            if($Passthru)
	            {
	                New-Excel -Path $Path
	            }
	    }
	}
	
}
#endregion

#region Call-Format-Cell_ps1
function Call-Format-Cell_ps1
{
	function Format-Cell {
	    <#
	    .SYNOPSIS
	        Format cells in an Excel worksheet
	
	    .DESCRIPTION
	        Format cells in an Excel worksheet
	
	        Note:
	            Each time you call this function, you need to save and re-create your Excel Object.
	            If you attempt to modify the Excel object, save, modify, and save a second time, it will fail.
	            See Save-Excel Passthru parameter for a workaround
	
	    .PARAMETER Worksheet
	        Worksheet to format cells on
	
	    .PARAMETER StartRow
	        The top row to format.  If not specified, we use the dimensions start row
	
	    .PARAMETER StartColumn
	        The leftmost column to format.  If not specified, we use the dimensions start column
	
	    .PARAMETER EndRow
	        The bottom row to format.  If not specified, we use the dimensions' end row
	
	    .PARAMETER EndColumn
	        The rightmost column to format.  If not specified, we use the dimensions' end column
	
	    .PARAMETER Header
	        If specified, identify and apply formatting to the header row only.
	
	    .PARAMETER Bold
	        Add or remove bold font (boolean)
	
	    .PARAMETER Italic
	        Add or remove Italic font (boolean)
	
	    .PARAMETER Underline
	        Add or remove Underline font (boolean)
	
	    .PARAMETER Size
	        Set font size
	
	    .PARAMETER Font
	        Set font name
	
	    .PARAMETER Color
	        Set font color
	
	    .PARAMETER BackgroundColor
	        Set background fill color
	
	    .PARAMETER FillStyle
	        Set the FillStyle, if BackgroundColor is specified.  Default is Solid
	
	    .PARAMETER WrapText
	        Add or remove WrapText property (boolean)
	
	    .PARAMETER AutoFilter
	        Set autofilter for the cells
	
	        This currently only works for $True. It won't turn off Autofilter with $False.
	
	    .PARAMETER AutoFit
	        Apply auto fit to cells
	
	    .PARAMETER AutoFitMinWidth
	        Minimum width to set autofit with
	
	    .PARAMETER AutoFitMaxWidth
	        Maximum width to set autofit with
	
	    .PARAMETER VerticalAlignment
	        Set the vertical alignment
	
	    .PARAMETER HorizontalAlignment
	        Set the horizontal alignment
	
	    .PARAMETER Border
	        Set a border to the left, right, top, bottom, or all (*).
	
	    .PARAMETER BorderStyle
	        Style for the border. Defaults to Thin
	
	    .PARAMETER BorderColor
	        Color for the border. Defaults to Black
	
	    .PARAMETER Passthru
	        If specified, pass the Worksheet back
	
	    .EXAMPLE
	        #
	        # Create an Excel object to work with
	            $Excel = New-Excel -Path C:\Temp\Demo.xlsx
	
	        #Get the worksheet, format the header as bold, size 14
	            $Excel |
	                Get-WorkSheet |
	                Format-Cell -Header -Bold $True -Size 14
	
	        #Save your changes, re-open the excel file
	            $Excel = $Excel | Save-Excel -Passthru
	
	        #Oops, too big!  Get the worksheet, format the header as size 11
	            $Excel |
	                Get-WorkSheet |
	                Format-Cell -Header -Size 11
	
	            $Excel | Save-Excel -Close
	
	    .EXAMPLE
	        $WorkSheet | Format-Cell -StartRow 2 -StartColumn 1 -EndColumn 1 -Italic $True -Size 10
	
	        # Set the first column, rows 2 through the end to size 10, italic
	
	    .EXAMPLE
	
	        # Get the worksheet
	        # format all the cells (default if nothing specified)
	        # Set autofit between minumum of 5 and maximum of 20
	        $Excel |
	            Get-WorkSheet |
	            Format-Cell -Autofit -AutofitMinWidth 5 -AutofitMaxWidth 20
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelWorksheet])]
	    [cmdletbinding(DefaultParameterSetname = 'Range')]
	    param(
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelWorksheet]$WorkSheet,
	
	        [parameter( ParameterSetName = 'Range',
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$StartRow,
	
	        [parameter( ParameterSetName = 'Range',
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$StartColumn,
	
	        [parameter( ParameterSetName = 'Range',
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$EndRow,
	
	        [parameter( ParameterSetName = 'Range',
	                    Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [int]$EndColumn,
	
	        [parameter( ParameterSetName = 'Header',
	                    Mandatory=$true,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [Switch]$Header,
	
	        [boolean]$Bold,
	        [boolean]$Italic,
	        [boolean]$Underline,
	        [int]$Size,
	        [string]$Font,
	
	        [System.Drawing.KnownColor]$Color,
	        [System.Drawing.KnownColor]$BackgroundColor,
	        [OfficeOpenXml.Style.ExcelFillStyle]$FillStyle,
	        [boolean]$WrapText,
	        [String]$NumberFormat,
	
	        [boolean]$AutoFilter,
	        [switch]$Autofit,
	        [double]$AutofitMinWidth,
	        [double]$AutofitMaxWidth,
	
	        [OfficeOpenXml.Style.ExcelVerticalAlignment]$VerticalAlignment,
	        [OfficeOpenXml.Style.ExcelHorizontalAlignment]$HorizontalAlignment,
	
	        [validateset('Left','Right','Top','Bottom','*')]
	        [string[]]$Border,
	        [OfficeOpenXml.Style.ExcelBorderStyle]$BorderStyle,
	        [System.Drawing.KnownColor]$BorderColor,
	
	        [switch]$Passthru
	    )
	    Begin
	    {
	
	        if($PSBoundParameters.ContainsKey('BorderColor'))
	        {
	            Try
	            {
	                $BorderColorConverted = [System.Drawing.Color]::FromKnownColor($BorderColor)
	            }
	            Catch
	            {
	                Throw "Failed to convert $($BorderColor) to a valid System.Drawing.Color: $_"
	            }
	        }
	
	        if($PSBoundParameters.ContainsKey('Color'))
	        {
	            Try
	            {
	                $ColorConverted = [System.Drawing.Color]::FromKnownColor($Color)
	            }
	            Catch
	            {
	                Throw "Failed to convert $($Color) to a valid System.Drawing.Color: $_"
	            }
	        }
	
	        if($PSBoundParameters.ContainsKey('BackgroundColor'))
	        {
	            Try
	            {
	                $BackgroundColorConverted = [System.Drawing.Color]::FromKnownColor($BackgroundColor)
	                if(-not $PSBoundParameters.ContainsKey('FillStyle'))
	                {
	                    $FillStyle = [OfficeOpenXml.Style.ExcelFillStyle]::Solid
	                }
	            }
	            Catch
	            {
	                Throw "Failed to convert $($BackgroundColor) to a valid System.Drawing.Color: $_"
	            }
	        }
	    }
	    Process
	    {
	        #Get the coordinates
	            $dimension = $WorkSheet.Dimension
	
	            if($PSCmdlet.ParameterSetName -like 'Range')
	            {
	                If(-not $StartRow)
	                {
	                    $StartRow = $dimension.Start.Row
	                }
	                If(-not $StartColumn)
	                {
	                    $StartColumn = $dimension.Start.Column
	                }
	                If(-not $EndRow)
	                {
	                    $EndRow = $dimension.End.Row
	                }
	                If(-not $EndColumn)
	                {
	                    $EndColumn = $dimension.End.Column
	                }
	            }
	            Elseif($PSCmdlet.ParameterSetName -like 'Header')
	            {
	                $StartRow = $dimension.Start.Row
	                $StartColumn = $dimension.Start.Column
	                $EndRow = $dimension.Start.Row
	                $EndColumn = $dimension.End.Column
	            }
	
	            $Start = ConvertTo-ExcelCoordinate -Row $StartRow -Column $StartColumn
	            $End = ConvertTo-ExcelCoordinate -Row $EndRow -Column $EndColumn
	            $RangeCoordinates = "$Start`:$End"
	
	        # Apply the formatting
	            $CellRange = $WorkSheet.Cells[$RangeCoordinates]
	
	            switch ($PSBoundParameters.Keys)
	            {
	                'Bold'                { $CellRange.Style.Font.Bold = $Bold  }
	                'Italic'              { $CellRange.Style.Font.Italic = $Italic  }
	                'Underline'           { $CellRange.Style.Font.UnderLine = $Underline}
	                'Size'                { $CellRange.Style.Font.Size = $Size }
	                'Font'                { $CellRange.Style.Font.Name = $Font }
	                'Color'               { $CellRange.Style.Font.Color.SetColor($ColorConverted) }
	                'BackgroundColor'     {
	                    $CellRange.Style.Fill.PatternType = $FillStyle
	                    $CellRange.Style.Fill.BackgroundColor.SetColor($BackgroundColorConverted)
	                }
	                'WrapText'            { $CellRange.Style.WrapText = $WrapText  }
	                'VerticalAlignment'   { $CellRange.Style.VerticalAlignment = $VerticalAlignment }
	                'HorizontalAlignment' { $CellRange.Style.HorizontalAlignment = $HorizontalAlignment }
	                'AutoFilter'          { $CellRange.AutoFilter = $AutoFilter }
	                'Autofit'         {
	                    #Probably a cleaner way to call this...
	                    try
	                    {
	                        if($PSBoundParameters.ContainsKey('AutofitMaxWidth'))
	                        {
	                            $CellRange.AutoFitColumns($AutofitMinWidth, $AutofitMaxWidth)
	                        }
	                        elseif($PSBoundParameters.ContainsKey('AutofitMinWidth'))
	                        {
	                            $CellRange.AutoFitColumns($AutofitMinWidth)
	                        }
	                        else
	                        {
	                            $CellRange.AutoFitColumns()
	                        }
	                    }
	                    Catch
	                    {
	                        Write-Error $_
	                    }
	                }
	                'Border' {
	                    If($Border -eq '*')
	                    {
	                        $Border = 'Top', 'Bottom', 'Left', 'Right'
	                    }
	                    foreach($Side in @( $Border | Select -Unique ) )
	                    {
	                        if(-not $BorderStyle)
	                        {
	                            $BorderStyle = [OfficeOpenXml.Style.ExcelBorderStyle]::Thin
	                        }
	                        if(-not $BorderColorConverted)
	                        {
	                            $BorderColorConverted = [System.Drawing.Color]::Black
	                        }
	                        $CellRange.Style.Border.$Side.Style = $BorderStyle
	                        $CellRange.Style.Border.$Side.Color.SetColor( $BorderColorConverted )
	                    }
	                }
	                'NumberFormat' {
	                    $CellRange.Style.Numberformat.Format = $NumberFormat
	                }
	            }
	        if($Passthru)
	        {
	            $WorkSheet
	        }
	    }
	}
	
}
#endregion

#region Call-Get-CellValue_ps1
function Call-Get-CellValue_ps1
{
	function Get-CellValue {
	    <#
	    .SYNOPSIS
	        Get cell data from Excel
	
	    .DESCRIPTION
	        Get cell data from Excel
	
	    .PARAMETER Path
	        Path to an xlsx file to get cells from
	
	    .PARAMETER Excel
	        An ExcelPackage to get cells from
	
	    .PARAMETER WorkSheet
	        An Excel WorkSheet to get cells from
	
	    .PARAMETER WorksheetName
	        Optional name of Worksheet to get cells from
	
	    .PARAMETER Header
	        Replacement headers.  Must match order and count of your data's columns
	
	    .PARAMETER Coordinates
	        Excel style coordinates specifying starting cell and final cell (e.g. A1:B2)
	
	        If not specified, we get the dimension for the worksheet and return everything
	
	    .EXAMPLE
	        Get-CellValue -Path C:\temp\Demo.xlsx -Coordinates A2:A2
	
	        #Get the value at column 1, row 2
	
	    .EXAMPLE
	        Get-CellValue -Path C:\temp\Demo.xlsx -Coordinates A2:B3 -Header One, Two
	
	        #Get the values from cells in column one, row two through column two, row three.  Replace headers with One, Two
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [cmdletbinding()]
	    param(
	        [parameter( Position = 1,
	                    ParameterSetName = 'Excel',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [parameter( Position = 1,
	                    ParameterSetName = 'File',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [validatescript({Test-Path $_})]
	        [string]$Path,
	
	        [parameter( Position = 1,
	                    ParameterSetName = 'Worksheet',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelWorksheet]$WorkSheet,
	
	        [validatescript({
	            if( $_ -match "^[a-zA-Z]+[0-9]+:[a-zA-Z]+[0-9]+$" )
	            {
	                $True
	            }
	            else
	            {
	                Throw "'$_' is not a valid coordinate.  See help for 'Coordinates' parameter"
	            }
	
	        })]
	        [string]$Coordinates,
	
	        $WorkSheetName,
	
	        [string[]]$Header
	
	    )
	    Process
	    {
	        Write-Verbose "PSBoundParameters: $($PSBoundParameters | Out-String)"
	        $WSParam = @{}
	        if($PSBoundParameters.ContainsKey( 'WorkSheetName') )
	        {
	            $WSParam.Add('Name',$WorkSheetName)
	        }
	        Try
	        {
	            switch ($PSCmdlet.ParameterSetName)
	            {
	                'Excel'
	                {
	                    $WorkSheets = @( $Excel | Get-Worksheet @WSParam -ErrorAction Stop )
	                }
	                'File'
	                {
	                    $WorkSheets = @( New-Excel -Path $Path -ErrorAction Stop | Get-Worksheet @WSParam -ErrorAction Stop )
	                }
	                'Worksheet'
	                {
	                    $WorkSheets = @( $WorkSheet )
	                }
	            }
	        }
	        Catch
	        {
	            Throw "Could not get worksheets to search: $_"
	        }
	
	        If($WorkSheets.Count -eq 0)
	        {
	            Throw "Something went wrong, we didn't find a worksheet"
	        }
	
	        Foreach($Worksheet in $WorkSheets)
	        {
	            Write-Verbose "Working with worksheet $($Worksheet.Name)"
	            if($PSBoundParameters.ContainsKey('Coordinates'))
	            {
	                Try
	                {
	                    $CellRange = $WorkSheet.Cells.item($Coordinates)
	                }
	                Catch
	                {
	                    Write-Error "Could not get cells from '$($WorkSheet.Name)' for coordinates '$Coordinates'"
	                    Continue
	                }
	            }
	            else
	            {
	                $CellRange = $Worksheet.Cells
	                $Coordinates = $WorkSheet.Dimension.Address
	            }
	
	
	            $ColumnStart = ($($Coordinates -split ":")[0] -replace "[0-9]", "").ToUpperInvariant()
	            $ColumnEnd = ($($Coordinates -split ":")[1] -replace "[0-9]", "").ToUpperInvariant()
	            [int]$RowStart = $($Coordinates -split ":")[0] -replace "[a-zA-Z]", ""
	            [int]$RowEnd = $($Coordinates -split ":")[1] -replace "[a-zA-Z]", ""
	
	            Function Get-ExcelColumnInt
	            {   # http://stackoverflow.com/questions/667802/what-is-the-algorithm-to-convert-an-excel-column-letter-into-its-number
	                [cmdletbinding()]
	                param($ColumnName)
	                [int]$Sum = 0
	                for ($i = 0; $i -lt $ColumnName.Length; $i++)
	                {
	                    $sum *= 26
	                    $sum += ($ColumnName[$i] - 65 + 1)
	                }
	                $sum
	                Write-Verbose "Translated $ColumnName to $Sum"
	            }
	
	            $ColumnStart = Get-ExcelColumnInt $ColumnStart
	            $ColumnEnd = Get-ExcelColumnInt $ColumnEnd
	            $Columns = $ColumnEnd - $ColumnStart + 1
	
	            if($Header -and $Header.count -gt 0)
	            {
	                if($Header.count -ne $Columns)
	                {
	                    Write-Error "Found '$columns' columns, provided $($header.count) headers.  You must provide a header for every column."
	                }
	            }
	            else
	            {
	                $Header = @( foreach ($Column in $ColumnStart..$ColumnEnd)
	                {
	                    $worksheet.Cells.Item(1,$Column).Value
	                } )
	            }
	
	            [string[]]$SelectedHeaders = @( $Header | select -Unique )
	
	            Write-Verbose "Found headers $Header"
	
	
	            #Skip headers...
	            if($RowStart -eq 1 -and $RowEnd -ne 1)
	            {
	                $RowStart += 1
	            }
	            foreach($Row in ($RowStart)..$RowEnd)
	            {
	                $RowData = @{}
	                $HeaderCol = 0
	
	                foreach($Column in $ColumnStart..$ColumnEnd)
	                {
	                    $Name  = $Header[$HeaderCol]
	                    $Value = $WorkSheet.Cells.Item($Row,$Column).Value
	                    $HeaderCol++
	
	                    Write-Debug "Row: $Row, Column: $Column, HeaderCol: $HeaderCol, Name: $Name, Value = $Value"
	
	                    #Handle dates, they're too common to overlook... Could use help, not sure if this is the best regex to use?
	                    $Format = $WorkSheet.Cells.Item($Row,$Column).style.numberformat.format
	                    if($Format -match '\w{1,4}/\w{1,2}/\w{1,4}( \w{1,2}:\w{1,2})?')
	                    {
	                        Try
	                        {
	                            $Value = [datetime]::FromOADate($Value)
	                        }
	                        Catch
	                        {
	                            Write-Verbose "Error converting '$Value' to datetime"
	                        }
	                    }
	                    if($RowData.ContainsKey($Name) )
	                    {
	                        Write-Warning "Duplicate header for '$Name' found, with value '$Value', in row $Row"
	                    }
	                    else
	                    {
	                        $RowData.Add($Name, $Value)
	                    }
	                }
	                New-Object -TypeName PSObject -Property $RowData | Select -Property $SelectedHeaders
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Get-Workbook_ps1
function Call-Get-Workbook_ps1
{
	function Get-Workbook {
	    <#
	    .SYNOPSIS
	        Return a Workbook from an ExcelPackage
	
	    .DESCRIPTION
	        Return a Workbook from an ExcelPackage
	
	    .PARAMETER Excel
	        ExcelPackage to extract workbook from
	
	    .EXAMPLE
	        $Excel = New-Excel -Path "C:\Excel.xlsx"
	        $WorkBook = Get-Workbook $Excel
	        $WorkBook
	
	        #Open C:\Excel.xlsx, view the workbook
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelWorkbook])]
	    [cmdletbinding()]
	    param(
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelPackage]$Excel
	    )
	    Process
	    {
	        $Excel.WorkBook
	    }
	}
	
}
#endregion

#region Call-Get-Worksheet_ps1
function Call-Get-Worksheet_ps1
{
	function Get-Worksheet {
	    <#
	    .SYNOPSIS
	        Return an ExcelPackage Worksheet
	
	    .DESCRIPTION
	        Return an ExcelPackage Worksheet
	
	    .PARAMETER Name
	        If specified, return Worksheets named like this
	
	    .PARAMETER Workbook
	        Workbook to extract worksheets from
	
	    .PARAMETER Excel
	        ExcelPackage to extract worksheets from
	
	    .EXAMPLE
	        $Excel = New-Excel -Path "C:\Excel.xlsx"
	        $WorkSheet = $Excel | Get-WorkSheet
	
	        # Open C:\Excel.xlsx, view the worksheets in it
	
	    .EXAMPLE
	        $Workbook | Get-WorkSheet -Name "Worksheet2"
	
	        # Get Worksheet with the name Worksheet2 from $WorkBook
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelWorksheet])]
	    [cmdletbinding(DefaultParameterSetName = "Workbook")]
	    param(
	        [parameter(Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [string]$Name,
	
	        [parameter( ParameterSetName = "Workbook",
	                    Mandatory=$true,
	                    ValueFromPipeline=$True,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelWorkbook]$Workbook,
	
	        [parameter( ParameterSetName = "Excel",
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelPackage]$Excel
	    )
	    Process
	    {
	        $Output = switch ($PSCmdlet.ParameterSetName)
	        {
	            "Workbook"
	            {
	                Write-Verbose "Processing Workbook"
	                $Workbook.Worksheets
	            }
	            "Excel"
	            {
	                Write-Verbose "Processing ExcelPackage"
	                $Excel.Workbook.Worksheets
	            }
	        }
	
	        If($Name)
	        {
	            $FilteredOutput = $Output | Where-Object {$_.Name -like $Name}
	            if($Name -notmatch '\*' -and -not $FilteredOutput)
	            {
	                Write-Error "$Name could not be found. Valid worksheets:`n$($Output | Select -ExpandProperty Name | Out-String)"
	            }
	            else
	            {
	                $FilteredOutput
	            }
	        }
	        else
	        {
	            $Output
	        }
	    }
	}
	
}
#endregion

#region Call-Import-XLSX_ps1
function Call-Import-XLSX_ps1
{
	function Import-XLSX {
	    <#
	    .SYNOPSIS
	        Import data from Excel
	
	    .DESCRIPTION
	        Import data from Excel
	
	    .PARAMETER Path
	        Path to an xlsx file to import
	
	    .PARAMETER Sheet
	        Index or name of Worksheet to import
	
	    .PARAMETER Header
	        Replacement headers.  Must match order and count of your data's properties.
	
	    .PARAMETER RowStart
	        First row to start reading from, typically the header. Default is 1
	
	    .PARAMETER ColumnStart
	        First column to start reading from. Default is 1
	
	    .PARAMETER FirstRowIsData
	        Indicates that the first row is data, not headers.  Must be used with -Header.
	
	    .PARAMETER Text
	        Extract cell text, rather than value.
	
	        For example, if you have a cell with value 5:
	            If the Number Format is '0', the text would be 5
	            If the Number Format is 0.00, the text would be 5.00
	
	    .EXAMPLE
	        Import-XLSX -Path "C:\Excel.xlsx"
	
	        #Import data from C:\Excel.xlsx
	
	    .EXAMPLE
	        Import-XLSX -Path "C:\Excel.xlsx" -Header One, Two, Five
	
	        # Import data from C:\Excel.xlsx
	        # Replace headers with One, Two, Five
	
	    .EXAMPLE
	        Import-XLSX -Path "C:\Excel.xlsx" -Header One, Two, Five -FirstRowIsData -Sheet 2
	
	        # Import data from C:\Excel.xlsx
	        # Assume first row is data
	        # Use headers One, Two, Five
	        # Pull from sheet 2 (sheet 1 is default)
	
	    .EXAMPLE
	       #    A        B        C
	       # 1  Random text to mess with you!
	       # 2  Header1  Header2  Header3
	       # 3  data1    Data2    Data3
	
	       # Your worksheet has data you don't care about in the first row or column
	       # Use the ColumnStart or RowStart parameters to solve this.
	
	       Import-XLSX -Path C:\RandomTextInRow1.xlsx -RowStart 2
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [cmdletbinding()]
	    param(
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [validatescript({Test-Path $_})]
	        [string[]]$Path,
	
	        $Sheet = 1,
	
	        [string[]]$Header,
	
	        [switch]$FirstRowIsData,
	
	        [switch]$Text,
	
	        [int]$RowStart = 1,
	
	        [int]$ColumnStart = 1
	    )
	    Process
	    {
	        foreach($file in $path)
	        {
	            #Resolve relative paths... Thanks Oisin! http://stackoverflow.com/a/3040982/3067642
	            $file = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($file)
	
	            write-verbose "target excel file $($file)"
	
	            Try
	            {
	                $xl = New-Object OfficeOpenXml.ExcelPackage $file
	                $workbook  = $xl.Workbook
	            }
	            Catch
	            {
	                Write-Error "Failed to open '$file':`n$_"
	                continue
	            }
	
	            Try
	            {
	                if( @($workbook.Worksheets).count -eq 0)
	                {
	                    Throw "No worksheets found"
	                }
	                else
	                {
	                    $worksheet = $workbook.Worksheets[$Sheet]
	                    $dimension = $worksheet.Dimension
	
	                    $Rows = $dimension.Rows
	                    $Columns = $dimension.Columns
	
	                    $ColumnEnd = $Columns + $ColumnStart - 1
	                    $RowEnd = $Rows + $RowStart - 1
	                }
	
	            }
	            Catch
	            {
	                Write-Error "Failed to gather Worksheet '$Sheet' data for file '$file':`n$_"
	                continue
	            }
	
	            if($Header -and $Header.count -gt 0)
	            {
	                if($Header.count -ne $Columns)
	                {
	                    Write-Error "Found '$columns' columns, provided $($header.count) headers.  You must provide a header for every column."
	                }
	                Write-Verbose "User defined headers: $Header"
	            }
	            else
	            {
	                $Header = @( foreach ($Column in $ColumnStart..$ColumnEnd)
	                {
	                    if($Text)
	                    {
	                        $worksheet.Cells.Item($RowStart,$Column).Text
	                    }
	                    else
	                    {
	                        $worksheet.Cells.Item($RowStart,$Column).Value
	                    }
	                })
	            }
	
	            [string[]]$SelectedHeaders = @( $Header | select -Unique )
	            Write-Verbose "Found $Rows rows, $Columns columns, with headers:`n$($Header | Out-String)"
	
	            if(-not $FirstRowIsData)
	            {
	                $RowStart++
	            }
	
	            foreach ($Row in $RowStart..$RowEnd)
	            {
	                $RowData = @{}
	
	                foreach ($Column in 0..($Columns - 1))
	                {
	                    $Name  = $Header[$Column]
	                    if($Text)
	                    {
	                        $Value = $worksheet.Cells.Item($Row, ($Column + $ColumnStart)).Text
	                    }
	                    else
	                    {
	                        $Value = $worksheet.Cells.Item($Row, ($Column + $ColumnStart)).Value
	                    }
	
	                    Write-Debug "Row: $Row, Column: $Column, Name: $Name, Value = $Value"
	
	                    #Handle dates, they're too common to overlook... Could use help, not sure if this is the best regex to use?
	                    $Format = $worksheet.Cells.Item($Row, ($Column + $ColumnStart)).style.numberformat.format
	                    if($Format -match '\w{1,4}/\w{1,2}/\w{1,4}( \w{1,2}:\w{1,2})?')
	                    {
	                        Try
	                        {
	                            $Value = [datetime]::FromOADate($Value)
	                        }
	                        Catch
	                        {
	                            Write-Verbose "Error converting '$Value' to datetime"
	                        }
	                    }
	
	                    if($RowData.ContainsKey($Name) )
	                    {
	                        Write-Warning "Duplicate header for '$Name' found, with value '$Value', in row $Row"
	                    }
	                    else
	                    {
	                        $RowData.Add($Name, $Value)
	                    }
	                }
	                New-Object -TypeName PSObject -Property $RowData | Select -Property $SelectedHeaders
	            }
	
	            $xl.Dispose()
	            $xl = $null
	        }
	    }
	}
	
}
#endregion

#region Call-Join-Object_ps1
function Call-Join-Object_ps1
{
	function Join-Object
	{
	    <#
	    .SYNOPSIS
	        Join data from two sets of objects based on a common value
	
	    .DESCRIPTION
	        Join data from two sets of objects based on a common value
	
	        For more details, see the accompanying blog post:
	            http://ramblingcookiemonster.github.io/Join-Object/
	
	        For even more details,  see the original code and discussions that this borrows from:
	            Dave Wyatt's Join-Object - http://powershell.org/wp/forums/topic/merging-very-large-collections
	            Lucio Silveira's Join-Object - http://blogs.msdn.com/b/powershell/archive/2012/07/13/join-object.aspx
	
	    .PARAMETER Left
	        'Left' collection of objects to join.  You can use the pipeline for Left.
	
	        The objects in this collection should be consistent.
	        We look at the properties on the first object for a baseline.
	
	    .PARAMETER Right
	        'Right' collection of objects to join.
	
	        The objects in this collection should be consistent.
	        We look at the properties on the first object for a baseline.
	
	    .PARAMETER LeftJoinProperty
	        Property on Left collection objects that we match up with RightJoinProperty on the Right collection
	
	    .PARAMETER RightJoinProperty
	        Property on Right collection objects that we match up with LeftJoinProperty on the Left collection
	
	    .PARAMETER LeftProperties
	        One or more properties to keep from Left.  Default is to keep all Left properties (*).
	
	        Each property can:
	            - Be a plain property name like "Name"
	            - Contain wildcards like "*"
	            - Be a hashtable like @{Name="Product Name";Expression={$_.Name}}.
	                 Name is the output property name
	                 Expression is the property value ($_ as the current object)
	
	                 Alternatively, use the Suffix or Prefix parameter to avoid collisions
	                 Each property using this hashtable syntax will be excluded from suffixes and prefixes
	
	    .PARAMETER RightProperties
	        One or more properties to keep from Right.  Default is to keep all Right properties (*).
	
	        Each property can:
	            - Be a plain property name like "Name"
	            - Contain wildcards like "*"
	            - Be a hashtable like @{Name="Product Name";Expression={$_.Name}}.
	                 Name is the output property name
	                 Expression is the property value ($_ as the current object)
	
	                 Alternatively, use the Suffix or Prefix parameter to avoid collisions
	                 Each property using this hashtable syntax will be excluded from suffixes and prefixes
	
	    .PARAMETER Prefix
	        If specified, prepend Right object property names with this prefix to avoid collisions
	
	        Example:
	            Property Name                   = 'Name'
	            Suffix                          = 'j_'
	            Resulting Joined Property Name  = 'j_Name'
	
	    .PARAMETER Suffix
	        If specified, append Right object property names with this suffix to avoid collisions
	
	        Example:
	            Property Name                   = 'Name'
	            Suffix                          = '_j'
	            Resulting Joined Property Name  = 'Name_j'
	
	    .PARAMETER Type
	        Type of join.  Default is AllInLeft.
	
	        AllInLeft will have all elements from Left at least once in the output, and might appear more than once
	          if the where clause is true for more than one element in right, Left elements with matches in Right are
	          preceded by elements with no matches.
	          SQL equivalent: outer left join (or simply left join)
	
	        AllInRight is similar to AllInLeft.
	
	        OnlyIfInBoth will cause all elements from Left to be placed in the output, only if there is at least one
	          match in Right.
	          SQL equivalent: inner join (or simply join)
	
	        AllInBoth will have all entries in right and left in the output. Specifically, it will have all entries
	          in right with at least one match in left, followed by all entries in Right with no matches in left,
	          followed by all entries in Left with no matches in Right.
	          SQL equivalent: full join
	
	    .EXAMPLE
	        #
	        #Define some input data.
	
	        $l = 1..5 | Foreach-Object {
	            [pscustomobject]@{
	                Name = "jsmith$_"
	                Birthday = (Get-Date).adddays(-1)
	            }
	        }
	
	        $r = 4..7 | Foreach-Object{
	            [pscustomobject]@{
	                Department = "Department $_"
	                Name = "Department $_"
	                Manager = "jsmith$_"
	            }
	        }
	
	        #We have a name and Birthday for each manager, how do we find their department, using an inner join?
	        Join-Object -Left $l -Right $r -LeftJoinProperty Name -RightJoinProperty Manager -Type OnlyIfInBoth -RightProperties Department
	
	
	            # Name    Birthday             Department
	            # ----    --------             ----------
	            # jsmith4 4/14/2015 3:27:22 PM Department 4
	            # jsmith5 4/14/2015 3:27:22 PM Department 5
	
	    .EXAMPLE
	        #
	        #Define some input data.
	
	        $l = 1..5 | Foreach-Object {
	            [pscustomobject]@{
	                Name = "jsmith$_"
	                Birthday = (Get-Date).adddays(-1)
	            }
	        }
	
	        $r = 4..7 | Foreach-Object{
	            [pscustomobject]@{
	                Department = "Department $_"
	                Name = "Department $_"
	                Manager = "jsmith$_"
	            }
	        }
	
	        #We have a name and Birthday for each manager, how do we find all related department data, even if there are conflicting properties?
	        $l | Join-Object -Right $r -LeftJoinProperty Name -RightJoinProperty Manager -Type AllInLeft -Prefix j_
	
	            # Name    Birthday             j_Department j_Name       j_Manager
	            # ----    --------             ------------ ------       ---------
	            # jsmith1 4/14/2015 3:27:22 PM
	            # jsmith2 4/14/2015 3:27:22 PM
	            # jsmith3 4/14/2015 3:27:22 PM
	            # jsmith4 4/14/2015 3:27:22 PM Department 4 Department 4 jsmith4
	            # jsmith5 4/14/2015 3:27:22 PM Department 5 Department 5 jsmith5
	
	    .EXAMPLE
	        #
	        #Hey!  You know how to script right?  Can you merge these two CSVs, where Path1's IP is equal to Path2's IP_ADDRESS?
	
	        #Get CSV data
	        $s1 = Import-CSV $Path1
	        $s2 = Import-CSV $Path2
	
	        #Merge the data, using a full outer join to avoid omitting anything, and export it
	        Join-Object -Left $s1 -Right $s2 -LeftJoinProperty IP_ADDRESS -RightJoinProperty IP -Prefix 'j_' -Type AllInBoth |
	            Export-CSV $MergePath -NoTypeInformation
	
	    .EXAMPLE
	        #
	        # "Hey Warren, we need to match up SSNs to Active Directory users, and check if they are enabled or not.
	        #  I'll e-mail you an unencrypted CSV with all the SSNs from gmail, what could go wrong?"
	
	        # Import some SSNs.
	        $SSNs = Import-CSV -Path D:\SSNs.csv
	
	        #Get AD users, and match up by a common value, samaccountname in this case:
	        Get-ADUser -Filter "samaccountname -like 'wframe*'" |
	            Join-Object -LeftJoinProperty samaccountname -Right $SSNs `
	                        -RightJoinProperty samaccountname -RightProperties ssn `
	                        -LeftProperties samaccountname, enabled, objectclass
	
	    .NOTES
	        This borrows from:
	            Dave Wyatt's Join-Object - http://powershell.org/wp/forums/topic/merging-very-large-collections/
	            Lucio Silveira's Join-Object - http://blogs.msdn.com/b/powershell/archive/2012/07/13/join-object.aspx
	
	        Changes:
	            Always display full set of properties
	            Display properties in order (left first, right second)
	            If specified, add suffix or prefix to right object property names to avoid collisions
	            Use a hashtable rather than ordereddictionary (avoid case sensitivity)
	
	    .LINK
	        http://ramblingcookiemonster.github.io/Join-Object/
	
	    .FUNCTIONALITY
	        PowerShell Language
	
	    #>
	    [CmdletBinding()]
	    Param
	    (
	        [Parameter(Mandatory=$true,
	                   ValueFromPipeLine = $true)]
	        [object[]] $Left,
	
	        # List to join with $Left
	        [Parameter(Mandatory=$true)]
	        [object[]] $Right,
	
	        [Parameter(Mandatory = $true)]
	        [string] $LeftJoinProperty,
	
	        [Parameter(Mandatory = $true)]
	        [string] $RightJoinProperty,
	
	        [object[]]$LeftProperties = '*',
	
	        # Properties from $Right we want in the output.
	        # Like LeftProperties, each can be a plain name, wildcard or hashtable. See the LeftProperties comments.
	        [object[]]$RightProperties = '*',
	
	        [validateset( 'AllInLeft', 'OnlyIfInBoth', 'AllInBoth', 'AllInRight')]
	        [Parameter(Mandatory=$false)]
	        [string]$Type = 'AllInLeft',
	
	        [string]$Prefix,
	        [string]$Suffix
	    )
	    Begin
	    {
	        function AddItemProperties($item, $properties, $hash)
	        {
	            if ($null -eq $item)
	            {
	                return
	            }
	
	            foreach($property in $properties)
	            {
	                $propertyHash = $property -as [hashtable]
	                if($null -ne $propertyHash)
	                {
	                    $hashName = $propertyHash["name"] -as [string]
	                    $expression = $propertyHash["expression"] -as [scriptblock]
	
	                    $expressionValue = $expression.Invoke($item)[0]
	
	                    $hash[$hashName] = $expressionValue
	                }
	                else
	                {
	                    foreach($itemProperty in $item.psobject.Properties)
	                    {
	                        if ($itemProperty.Name -like $property)
	                        {
	                            $hash[$itemProperty.Name] = $itemProperty.Value
	                        }
	                    }
	                }
	            }
	        }
	
	        function TranslateProperties
	        {
	            [cmdletbinding()]
	            param(
	                [object[]]$Properties,
	                [psobject]$RealObject,
	                [string]$Side)
	
	            foreach($Prop in $Properties)
	            {
	                $propertyHash = $Prop -as [hashtable]
	                if($null -ne $propertyHash)
	                {
	                    $hashName = $propertyHash["name"] -as [string]
	                    $expression = $propertyHash["expression"] -as [scriptblock]
	
	                    $ScriptString = $expression.tostring()
	                    if($ScriptString -notmatch 'param\(')
	                    {
	                        Write-Verbose "Property '$HashName'`: Adding param(`$_) to scriptblock '$ScriptString'"
	                        $Expression = [ScriptBlock]::Create("param(`$_)`n $ScriptString")
	                    }
	
	                    $Output = @{Name =$HashName; Expression = $Expression }
	                    Write-Verbose "Found $Side property hash with name $($Output.Name), expression:`n$($Output.Expression | out-string)"
	                    $Output
	                }
	                else
	                {
	                    foreach($ThisProp in $RealObject.psobject.Properties)
	                    {
	                        if ($ThisProp.Name -like $Prop)
	                        {
	                            Write-Verbose "Found $Side property '$($ThisProp.Name)'"
	                            $ThisProp.Name
	                        }
	                    }
	                }
	            }
	        }
	
	        function WriteJoinObjectOutput($leftItem, $rightItem, $leftProperties, $rightProperties)
	        {
	            $properties = @{}
	
	            AddItemProperties $leftItem $leftProperties $properties
	            AddItemProperties $rightItem $rightProperties $properties
	
	            New-Object psobject -Property $properties
	        }
	
	        #Translate variations on calculated properties.  Doing this once shouldn't affect perf too much.
	        foreach($Prop in @($LeftProperties + $RightProperties))
	        {
	            if($Prop -as [hashtable])
	            {
	                foreach($variation in ('n','label','l'))
	                {
	                    if(-not $Prop.ContainsKey('Name') )
	                    {
	                        if($Prop.ContainsKey($variation) )
	                        {
	                            $Prop.Add('Name',$Prop[$Variation])
	                        }
	                    }
	                }
	                if(-not $Prop.ContainsKey('Name') -or $Prop['Name'] -like $null )
	                {
	                    Throw "Property is missing a name`n. This should be in calculated property format, with a Name and an Expression:`n@{Name='Something';Expression={`$_.Something}}`nAffected property:`n$($Prop | out-string)"
	                }
	
	
	                if(-not $Prop.ContainsKey('Expression') )
	                {
	                    if($Prop.ContainsKey('E') )
	                    {
	                        $Prop.Add('Expression',$Prop['E'])
	                    }
	                }
	
	                if(-not $Prop.ContainsKey('Expression') -or $Prop['Expression'] -like $null )
	                {
	                    Throw "Property is missing an expression`n. This should be in calculated property format, with a Name and an Expression:`n@{Name='Something';Expression={`$_.Something}}`nAffected property:`n$($Prop | out-string)"
	                }
	            }
	        }
	
	        $leftHash = @{}
	        $rightHash = @{}
	
	        # Hashtable keys can't be null; we'll use any old object reference as a placeholder if needed.
	        $nullKey = New-Object psobject
	
	        $bound = $PSBoundParameters.keys -contains "InputObject"
	        if(-not $bound)
	        {
	            [System.Collections.ArrayList]$LeftData = @()
	        }
	    }
	    Process
	    {
	        #We pull all the data for comparison later, no streaming
	        if($bound)
	        {
	            $LeftData = $Left
	        }
	        Else
	        {
	            foreach($Object in $Left)
	            {
	                [void]$LeftData.add($Object)
	            }
	        }
	    }
	    End
	    {
	        foreach ($item in $Right)
	        {
	            $key = $item.$RightJoinProperty
	
	            if ($null -eq $key)
	            {
	                $key = $nullKey
	            }
	
	            $bucket = $rightHash[$key]
	
	            if ($null -eq $bucket)
	            {
	                $bucket = New-Object System.Collections.ArrayList
	                $rightHash.Add($key, $bucket)
	            }
	
	            $null = $bucket.Add($item)
	        }
	
	        foreach ($item in $LeftData)
	        {
	            $key = $item.$LeftJoinProperty
	
	            if ($null -eq $key)
	            {
	                $key = $nullKey
	            }
	
	            $bucket = $leftHash[$key]
	
	            if ($null -eq $bucket)
	            {
	                $bucket = New-Object System.Collections.ArrayList
	                $leftHash.Add($key, $bucket)
	            }
	
	            $null = $bucket.Add($item)
	        }
	
	        $LeftProperties = TranslateProperties -Properties $LeftProperties -Side 'Left' -RealObject $LeftData[0]
	        $RightProperties = TranslateProperties -Properties $RightProperties -Side 'Right' -RealObject $Right[0]
	
	        #I prefer ordered output. Left properties first.
	        [string[]]$AllProps = $LeftProperties
	
	        #Handle prefixes, suffixes, and building AllProps with Name only
	        $RightProperties = foreach($RightProp in $RightProperties)
	        {
	            if(-not ($RightProp -as [Hashtable]))
	            {
	                Write-Verbose "Transforming property $RightProp to $Prefix$RightProp$Suffix"
	                @{
	                    Name="$Prefix$RightProp$Suffix"
	                    Expression=[scriptblock]::create("param(`$_) `$_.'$RightProp'")
	                }
	                $AllProps += "$Prefix$RightProp$Suffix"
	            }
	            else
	            {
	                Write-Verbose "Skipping transformation of calculated property with name $($RightProp.Name), expression:`n$($RightProp.Expression | out-string)"
	                $AllProps += [string]$RightProp["Name"]
	                $RightProp
	            }
	        }
	
	        $AllProps = $AllProps | Select -Unique
	
	        Write-Verbose "Combined set of properties: $($AllProps -join ', ')"
	
	        foreach ( $entry in $leftHash.GetEnumerator() )
	        {
	            $key = $entry.Key
	            $leftBucket = $entry.Value
	
	            $rightBucket = $rightHash[$key]
	
	            if ($null -eq $rightBucket)
	            {
	                if ($Type -eq 'AllInLeft' -or $Type -eq 'AllInBoth')
	                {
	                    foreach ($leftItem in $leftBucket)
	                    {
	                        WriteJoinObjectOutput $leftItem $null $LeftProperties $RightProperties | Select $AllProps
	                    }
	                }
	            }
	            else
	            {
	                foreach ($leftItem in $leftBucket)
	                {
	                    foreach ($rightItem in $rightBucket)
	                    {
	                        WriteJoinObjectOutput $leftItem $rightItem $LeftProperties $RightProperties | Select $AllProps
	                    }
	                }
	            }
	        }
	
	        if ($Type -eq 'AllInRight' -or $Type -eq 'AllInBoth')
	        {
	            foreach ($entry in $rightHash.GetEnumerator())
	            {
	                $key = $entry.Key
	                $rightBucket = $entry.Value
	
	                $leftBucket = $leftHash[$key]
	
	                if ($null -eq $leftBucket)
	                {
	                    foreach ($rightItem in $rightBucket)
	                    {
	                        WriteJoinObjectOutput $null $rightItem $LeftProperties $RightProperties | Select $AllProps
	                    }
	                }
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Join-Worksheet_ps1
function Call-Join-Worksheet_ps1
{
	Function Join-Worksheet {
	    <#
	    .SYNOPSIS
	        Join two worksheets based on a common value
	
	    .DESCRIPTION
	        Join two worksheets based on a common value
	
	        This wraps calls to Get-CellValue, Join-Object, and Export-XLSX.
	
	        BETA NOTE:
	            Minimal manual testing, no Pester tests
	            Might add the option
	
	        NOTE:
	            Each time you call this function, you need to save and re-create your Excel Object.
	            If you attempt to modify the Excel object, save, modify, and save a second time, it will fail.
	            See Save-Excel Passthru parameter for a workaround
	
	            See Join-Object for more details on the join operation
	
	    .PARAMETER Path
	        Path to the file to write joined worksheet to.  We save changes to this.
	
	    .PARAMETER Excel
	        Excel package to write joined worksheet to.  We do not save this.
	
	    .PARAMETER DestinationWorksheetName
	        Name the worksheet you are adding joined data to
	
	    .PARAMETER LeftWorksheet
	        Left worksheet to join
	
	    .PARAMETER RightWorksheet
	        Right worksheet to join
	
	    .PARAMETER LeftJoinColumn
	        Column on left worksheet that we match up with RightJoinColumn on the right worksheet
	
	    .PARAMETER RightJoinColumn
	        Column on right worksheet that we match up with LeftJoinColumn on the left worksheet
	
	    .PARAMETER LeftColumns
	        One or more columns to keep from the left worksheet.  Default is to pull all left columns (*).
	
	        Each property can:
	            - Be a plain property name like "Name"
	            - Contain wildcards like "*"
	            - Be a hashtable like @{Name="Product Name";Expression={$_.Name}}.
	                 Name is the output property name
	                 Expression is the property value ($_ as the current object)
	
	                 Alternatively, use the Suffix or Prefix parameter to avoid collisions
	                 Each property using this hashtable syntax will be excluded from suffixes and prefixes
	
	    .PARAMETER RightColumns
	        One or more columns to keep from right worksheet.  Default is to pull all right columns (*).
	
	        Each property can:
	            - Be a plain property name like "Name"
	            - Contain wildcards like "*"
	            - Be a hashtable like @{Name="Product Name";Expression={$_.Name}}.
	                 Name is the output property name
	                 Expression is the property value ($_ as the current object)
	
	                 Alternatively, use the Suffix or Prefix parameter to avoid collisions
	                 Each property using this hashtable syntax will be excluded from suffixes and prefixes
	
	    .PARAMETER Prefix
	        If specified, prepend right column names with this prefix to avoid collisions
	
	        Example:
	            Column Name                     = 'Name'
	            Suffix                          = 'j_'
	            Resulting Joined Property Name  = 'j_Name'
	
	    .PARAMETER Suffix
	        If specified, append right column names with this suffix to avoid collisions
	
	        Example:
	            Column Name                     = 'Name'
	            Suffix                          = '_j'
	            Resulting Joined Property Name  = 'Name_j'
	
	    .PARAMETER Type
	
	        Type of join.  Default is AllInLeft.
	
	        AllInLeft will have all elements from Left at least once in the output, and might appear more than once
	          if the where clause is true for more than one element in right, Left elements with matches in Right are
	          preceded by elements with no matches.
	          SQL equivalent: outer left join (or simply left join)
	
	        AllInRight is similar to AllInLeft.
	
	        OnlyIfInBoth will cause all elements from Left to be placed in the output, only if there is at least one
	          match in Right.
	          SQL equivalent: inner join (or simply join)
	
	        AllInBoth will have all entries in right and left in the output. Specifically, it will have all entries
	          in right with at least one match in left, followed by all entries in Right with no matches in left,
	          followed by all entries in Left with no matches in Right.
	          SQL equivalent: full join
	
	    .PARAMETER AutoFit
	        If specified, autofit everything
	
	    .PARAMETER PivotRows
	        If specified, add pivot table pivoting on these rows
	
	    .PARAMETER PivotColumns
	        If specified, add pivot table pivoting on these columns
	
	    .PARAMETER PivotValues
	        If specified, add pivot table pivoting on these values
	
	    .PARAMETER ChartType
	        If specified, add pivot chart of this type
	
	    .PARAMETER Table
	        If specified, add table to all cells
	
	    .PARAMETER TableStyle
	        If specified, add table style
	
	    .PARAMETER Force
	        If specified, and Path parameter is used, remove existing file if it is found
	
	        If force is not specified and an existing XLSX is found, we try to add the worksheet to it
	
	    .PARAMETER Passthru
	        If specified, and Excel parameter is used, return Excel package object
	
	    .EXAMPLE
	
	        #Define some input data.
	
	            $l = 1..5 | Foreach-Object {
	                [pscustomobject]@{
	                    Name = "jsmith$_"
	                    Birthday = (Get-Date).adddays(-1)
	                }
	            }
	
	            $r = 4..7 | Foreach-Object{
	                [pscustomobject]@{
	                    Department = "Department $_"
	                    Name = "Department $_"
	                    Manager = "jsmith$_"
	                }
	            }
	
	        #Export it to a spreadsheet with specific worksheet names
	
	            $l | export-xlsx -Path C:\temp\JoinTest.xlsx -WorksheetName Left
	            $r | export-xlsx -Path C:\temp\JoinTest.xlsx -WorksheetName Right
	
	        #Get the worksheets:
	            $Excel = New-Excel -Path C:\temp\JoinTest.xlsx
	            $LeftWorksheet = Get-Worksheet -Excel $Excel -Name 'Left'
	            $RightWorksheet = Get-WorkSheet -Excel $Excel -Name 'Right'
	
	        #We have the data - join it where Left.Name = Right.Manager
	            Join-Worksheet -Path C:\temp\test.xlsx -LeftWorksheet $LeftWorksheet -RightWorksheet $RightWorksheet -LeftJoinColumn Name -RightJoinColumn Manager
	            $Excel | Close-Excel
	
	        #Verify the output:
	            Import-XLSX -Path C:\temp\test.xlsx
	
	            # Name         Birthday              Department   Manager
	            # ----         --------              ----------   -------
	            # jsmith1      4/15/2015 12:30:21 PM
	            # jsmith2      4/15/2015 12:30:21 PM
	            # jsmith3      4/15/2015 12:30:21 PM
	            # Department 4 4/15/2015 12:30:21 PM Department 4 jsmith4
	            # Department 5 4/15/2015 12:30:21 PM Department 5 jsmith5
	
	
	    .NOTES
	        Thanks to Doug Finke for his example
	        The pivot stuff is straight from Doug:
	            https://github.com/dfinke/ImportExcel
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [CmdletBinding(DefaultParameterSetName='Path')]
	    param(
	        [parameter( ParametersetName = 'Path',
	                    Position = 0,
	                    Mandatory=$true )]
	        [ValidateScript({
	            $Parent = Split-Path $_ -Parent
	            if( -not (Test-Path -Path $Parent -PathType Container) )
	            {
	                Throw "Specify a valid path.  Parent '$Parent' does not exist: $_"
	            }
	            $True
	        })]
	        [string]$Path,
	
	        [parameter( ParameterSetName = "Excel",
	                    Position = 0,
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [string]$DestinationWorksheetName = 'WorksheetJoin',
	
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelWorksheet]$LeftWorksheet,
	
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [OfficeOpenXml.ExcelWorksheet]$RightWorksheet,
	
	        [Parameter(Mandatory = $true)]
	        [string]$LeftJoinColumn,
	
	        [Parameter(Mandatory = $true)]
	        [string]$RightJoinColumn,
	
	        [object[]]$LeftColumns,
	        [object[]]$RightColumns,
	        [string]$Prefix,
	        [string]$Suffix,
	
	        [validateset( 'AllInLeft', 'OnlyIfInBoth', 'AllInBoth', 'AllInRight')]
	        [Parameter(Mandatory=$false)]
	        [string]$Type = 'AllInLeft',
	
	        [string[]]$Header,
	
	        [switch]$Table,
	
	        [OfficeOpenXml.Table.TableStyles]$TableStyle = [OfficeOpenXml.Table.TableStyles]"Medium2",
	
	        [switch]$AutoFit,
	
	        [switch]$Force,
	
	        [switch]$Passthru
	    )
	    begin
	    {
	        #Resolve relative paths... Thanks Oisin! http://stackoverflow.com/a/3040982/3067642
	        if($PSBoundParameters.ContainsKey('Path'))
	        {
	            $Path = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($Path)
	        }
	
	        Try
	        {
	            $Left = Get-CellValue -WorkSheet $LeftWorksheet -ErrorAction stop
	        }
	        Catch
	        {
	            Throw "Error getting LeftWorksheet data: $_"
	        }
	
	        Try
	        {
	            $Right = Get-CellValue -WorkSheet $RightWorksheet -ErrorAction stop
	        }
	        Catch
	        {
	            Throw "Error getting RightWorksheet data: $_"
	        }
	
	        $MergeParams = @{
	            Left = $Left
	            Right = $Right
	        }
	
	        Switch($PSBoundParameters.Keys)
	        {
	            'LeftJoinColumn' { $MergeParams.Add('LeftJoinProperty',$PSBoundParameters['LeftJoinColumn'] ) }
	            'RightJoinColumn' { $MergeParams.Add('RightJoinProperty',$PSBoundParameters['RightJoinColumn'] ) }
	            'LeftColumns' { $MergeParams.Add('LeftProperties',$PSBoundParameters['LeftColumns'] ) }
	            'RightColumns' { $MergeParams.Add('RightProperties',$PSBoundParameters['RightColumns'] ) }
	            'Prefix' { $MergeParams.Add('Prefix',$PSBoundParameters['Prefix'] ) }
	            'Suffix' { $MergeParams.Add('Suffix',$PSBoundParameters['Suffix'] ) }
	            'Type' { $MergeParams.Add('Type',$PSBoundParameters['Type'] ) }
	        }
	
	        Try
	        {
	            $Merge = Join-Object @MergeParams -ErrorAction Stop
	        }
	        Catch
	        {
	            Write-Error $_
	            Throw "Error merging data: $_"
	        }
	    }
	    process
	    {
	        $ExportParams = @{ InputObject = $Merge }
	
	        switch ($PSBoundParameters.Keys)
	        {
	            'Excel'      { $ExportParams.Add('Excel',$Excel) }
	            'Path'       { $ExportParams.Add('Path',$Path) }
	            'Header'     { $ExportParams.Add('Header',$Header) }
	            'Table'      { $ExportParams.Add('Table',$Table) }
	            'TableStyle' { $ExportParams.Add('TableStyle',$TableStyle) }
	            'AutoFit'    { $ExportParams.Add('AutoFit',$AutoFit) }
	            'Force'      { $ExportParams.Add('Force',$Force) }
	        }
	
	        Export-XLSX @ExportParams
	        if($PSBoundParameters.ContainsKey('Excel') -and $Passthru)
	        {
	            $Excel
	        }
	    }
	}
	
}
#endregion

#region Call-New-Excel_ps1
function Call-New-Excel_ps1
{
	function New-Excel {
	    <#
	    .SYNOPSIS
	        Create an OfficeOpenXml ExcelPackage to work with
	
	    .DESCRIPTION
	        Create an OfficeOpenXml ExcelPackage to work with
	
	    .PARAMETER Path
	        Path to an xlsx file to open
	
	    .EXAMPLE
	        $Excel = New-Excel -Path "C:\Excel.xlsx"
	        $Excel.Workbook
	
	        #Open C:\Excel.xlsx, view the workbook
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelPackage])]
	    [cmdletbinding()]
	    param(
	        [parameter( Mandatory=$false,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [validatescript({
	            $Parent = Split-Path $_ -Parent
	            if( -not (Test-Path -Path $Parent -PathType Container) )
	            {
	                Throw "Specify a valid path.  Parent '$Parent' does not exist: $_"
	            }
	            $True
	        })]
	        [string]$Path
	    )
	    Process
	    {
	
	        if($path)
	        {
	            #Resolve relative paths... Thanks Oisin! http://stackoverflow.com/a/3040982/3067642
	            $Path = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($Path)
	            Write-Verbose "Creating excel object with path '$path'"
	
	            New-Object OfficeOpenXml.ExcelPackage $Path
	        }
	        else
	        {
	            Write-Verbose "Creating excel object with no specified path"
	            New-Object OfficeOpenXml.ExcelPackage
	        }
	    }
	}
	
}
#endregion

#region Call-Remove-FreePane_ps1
function Call-Remove-FreePane_ps1
{
	function Remove-FreezePane {
	    <#
	    .SYNOPSIS
	        Remove FreezePanes on a specified worksheet
	
	    .DESCRIPTION
	        Remove FreezePanes on a specified worksheet
	
	    .PARAMETER Worksheet
	        Worksheet to remove FreezePanes from
	
	    .PARAMETER Passthru
	        If specified, pass the Worksheet back
	
	    .EXAMPLE
	        $WorkSheet | Remove-FreezePane
	
	        # Remove frozen panes on $WorkSheet
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelWorksheet])]
	    [cmdletbinding()]
	    param(
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelWorksheet]$WorkSheet,
	
	        [switch]$Passthru
	    )
	    Process
	    {
	        $WorkSheet.View.UnFreezePanes()
	        if($Passthru)
	        {
	            $WorkSheet
	        }
	    }
	}
	
}
#endregion

#region Call-Save-Excel_ps1
function Call-Save-Excel_ps1
{
	function Save-Excel {
	    <#
	    .SYNOPSIS
	        Save an OfficeOpenXml ExcelPackage
	
	    .DESCRIPTION
	        Save an OfficeOpenXml ExcelPackage
	
	    .PARAMETER Excel
	        An ExcelPackage object to close
	
	    .PARAMETER Path
	        If specified, save as this path
	
	    .PARAMETER Close
	        If specified, close after saving
	
	    .PARAMETER Passthru
	        If specified, re-create and return the Excel object
	
	    .EXAMPLE
	        Save-Excel -Excel $Excel
	
	        #Save $Excel
	
	    .EXAMPLE
	        Save-Excel -Excel $Excel -Close
	
	        #Save $Excel, close
	
	    .EXAMPLE
	        Save-Excel -Excel $Excel -Path C:\new.xlsx
	
	        #Save $Excel as C:\new.xlsx
	
	    .EXAMPLE
	        $Excel = $Excel | Save-Excel -Passthru
	
	        #Save $Excel, re-open it to continue working with it.
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [OutputType([OfficeOpenXml.ExcelPackage])]
	    [cmdletbinding()]
	    param(
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [parameter( Mandatory=$false,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$false)]
	        [validatescript({
	            $Parent = Split-Path $_ -Parent -ErrorAction SilentlyContinue
	            if( -not (Test-Path -Path $Parent -PathType Container -ErrorAction SilentlyContinue) )
	            {
	                Throw "Specify a valid path.  Parent '$Parent' does not exist: $_"
	            }
	            $True
	        })]
	        [string]$Path,
	
	        [switch]$Close,
	
	        [switch]$Passthru
	    )
	    Process
	    {
	        foreach($xl in $Excel)
	        {
	            Try
	            {
	                if($Path)
	                {
	                    Try
	                    {
	                        #Resolve relative paths... Thanks Oisin! http://stackoverflow.com/a/3040982/3067642
	                        $Path = $ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath($Path)
	                    }
	                    Catch
	                    {
	                        Write-Error "Could not resolve path for '$Path': $_"
	                        continue
	                    }
	
	                    write-verbose "Saving $($xl.File) as $($Path)"
	
	                    $xl.saveas($Path)
	                }
	                else
	                {
	                    write-verbose "Saving $($xl.File)"
	
	                    $xl.save()
	                }
	
	                if($Passthru)
	                {
	                    $OpenPath = $xl.File
	                    $xl.Dispose()
	                    $xl = $Null
	                    New-Excel -Path $OpenPath
	                }
	            }
	            Catch
	            {
	                Write-Error "Error saving file. $_"
	                Continue
	            }
	
	            if($Close)
	            {
	                Try
	                {
	                    write-verbose "Closing $($xl.File)"
	
	                    $xl.Dispose()
	                    $xl = $null
	                }
	                Catch
	                {
	                    Write-Error $_
	                    Continue
	                }
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Search-CellValue_ps1
function Call-Search-CellValue_ps1
{
	function Search-CellValue {
	    <#
	    .SYNOPSIS
	        Find a value in a spreadsheet
	
	    .DESCRIPTION
	        Find a value in a spreadsheet
	
	        Specify an xlsx path, an ExcelPackage object, or a WorkSheet to search, and a ScriptBlock you want to run the cell values against
	
	    .PARAMETER Path
	        Path to an xlsx file to search
	
	    .PARAMETER Excel
	        An ExcelPackage to search
	
	    .PARAMETER WorkSheet
	        An Excel WorkSheet to search
	
	    .PARAMETER WorksheetName
	        Optional name of Worksheet to search
	
	    .PARAMETER FilterScript
	        Scriptblock that we call with Where-Object against every cell value
	
	        $_ would refer to the value of the cell.
	
	    .PARAMETER As
	        How the data should be returned
	
	            Default   WorksheetName, Row, Column, Match data
	            Raw       Return the value only
	            Passthru  Return the cell item
	
	    .EXAMPLE
	        Search-CellValue -Path C:\Temp\Demo.xlsx {$_ -like 'jsmith*'}
	
	        #Find any cell values like jsmith*
	
	    .EXAMPLE
	        Search-CellValue = Get-ExcelValue -Path C:\Temp\Demo.xlsx {$_ -like 'jsmith*'} -As Passthru
	
	        #Returns an OfficeOpenXml.ExcelRangeBase that you can process (e.g. add formatting to manually)
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [cmdletbinding(DefaultParameterSetName = 'Excel')]
	    param(
	        [parameter( Position = 1,
	                    ParameterSetName = 'Excel',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [parameter( Position = 1,
	                    ParameterSetName = 'File',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [validatescript({Test-Path $_})]
	        [string]$Path,
	
	        [parameter( Position = 1,
	                    ParameterSetName = 'Worksheet',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelWorksheet]$WorkSheet,
	
	        [parameter( Mandatory = $True,
	                    Position = 0)]
	        [scriptblock]$FilterScript,
	
	        $WorkSheetName,
	
	        [validateset('Default','Raw','Passthru')]
	        [string]$As = 'Default'
	    )
	
	    Process
	    {
	        Write-Verbose "PSBoundParameters: $($PSBoundParameters | Out-String)"
	        $WSParam = @{}
	        if($PSBoundParameters.ContainsKey( 'WorkSheetName') )
	        {
	            $WSParam.Add('Name',$WorkSheetName)
	        }
	        Try
	        {
	            switch ($PSCmdlet.ParameterSetName)
	            {
	                'Excel'
	                {
	                    $WorkSheets = @( $Excel | Get-Worksheet @WSParam -ErrorAction Stop )
	                }
	                'File'
	                {
	                    $WorkSheets = @( New-Excel -Path $Path -ErrorAction Stop | Get-Worksheet @WSParam -ErrorAction Stop )
	                }
	                'Worksheet'
	                {
	                    $WorkSheets = @( $WorkSheet )
	                }
	            }
	        }
	        Catch
	        {
	            Throw "Could not get worksheets to search: $_"
	        }
	
	        If($WorkSheets.Count -eq 0)
	        {
	            Throw "Something went wrong, we didn't find a worksheet"
	        }
	
	        Foreach($Sheet in $WorkSheets)
	        {
	            $Dimension = $Sheet.Dimension
	            if($IgnoreHeader)
	            {
	                $RowStart = 2
	            }
	            else
	            {
	                $RowStart = $Dimension.Start.Row
	            }
	            $ColumnStart = $Dimension.Start.Column
	            $RowEnd = $Dimension.End.Row
	            $ColumnEnd = $Dimension.End.Column
	
	            Write-Verbose "Searching $($Sheet.Name) over coordinates $RowStart, $ColumnStart through $RowEnd, $ColumnEnd"
	
	            for ($Row = $RowStart; $Row -le $RowEnd; $Row++)
	            {
	                for ($Column = $ColumnStart; $Column -le $ColumnEnd; $Column++)
	                {
	                    $Value = $Sheet.Cells.Item($Row, $Column).Value
	
	                    #Handle dates, they're too common to overlook... Could use help, not sure if this is the best regex to use?
	                    $Format = $Sheet.Cells.Item($Row, $Column).style.numberformat.format
	                    if($Format -match '\w{1,4}/\w{1,2}/\w{1,4}( \w{1,2}:\w{1,2})?')
	                    {
	                        Try
	                        {
	                            $Value = [datetime]::FromOADate($Value)
	                        }
	                        Catch
	                        {
	                            Write-Verbose "Error converting '$Value' to datetime"
	                        }
	                    }
	
	                    $Data = $Null
	                    $Data = $Value | Where-Object -FilterScript $FilterScript
	                    if($Data -ne $Null)
	                    {
	                        Switch ($As)
	                        {
	                            'Raw'
	                            {
	                                $Data
	                            }
	                            'Default'
	                            {
	                                New-Object -TypeName PSObject -Property @{
	                                    WorksheetName = $Sheet.Name
	                                    Row = $Row
	                                    Column = $Column
	                                    Match = $Data
	                                } | Select WorkSheetName, Row, Column, Match
	                            }
	                            'Passthru'
	                            {
	                                $Sheet.Cells.Item($Row, $Column)
	                            }
	                        }
	                    }
	                }
	            }
	
	            if($PSBoundParameters.ContainsKey('Path'))
	            {
	                $Sheet.Dispose()
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Set-CellValue_ps1
function Call-Set-CellValue_ps1
{
	function Set-CellValue {
	    <#
	    .SYNOPSIS
	        Set the value of a specific cell or range
	
	    .DESCRIPTION
	        Set the value of a specific cell or range
	
	        NOTE:
	            Each time you call this function, you need to save and re-create your Excel Object.
	            If you attempt to modify the Excel object, save, modify, and save a second time, it will fail.
	            See Save-Excel Passthru parameter for a workaround
	
	    .PARAMETER CellRange
	        CellRange to set value on.  This is an ExcelRangeBase
	
	        See help for Search-CellValue, with the '-As Passthru' parameter.  This generates an ExcelRangeBase
	
	    .PARAMETER Excel
	        An Excel object to set values in. We do not save this.
	
	    .PARAMETER Path
	        A path to set values in. We save changes to this.
	
	    .PARAMETER Worksheet
	        A worksheet to set values in.
	
	    .PARAMETER WorksheetName
	        A specific worksheet to set values in, otherwise, assume all worksheets from the input object
	
	    .PARAMETER Coordinates
	        Excel style coordinates specifying starting cell and final cell (e.g. A1:B2)
	
	        If not specified, we get the dimension for the worksheet and change everything.
	
	    .PARAMETER Value
	        The value to set cells to.
	
	    .PARAMETER Passthru
	        If specified, passthru the inputobject (Excel, Worksheet, or Cellrange)
	
	    .EXAMPLE
	        Set-CellValue -Path C:\Temp\Demo.xlsx -Coordinates a1:a1 -Value Header1
	
	        #Set the first column header to 'Header1'
	
	    .EXAMPLE
	
	        #
	        # Open an existing XLSX to search and set cells within
	        $Excel = New-Excel -Path C:\Temp\Demo.xlsx
	
	        #Search for any cells like 'jsmith*'.  Set them all to REDACTED
	        $Excel | Search-CellValue {$_ -like 'jsmith*'} -As Passthru | Set-CellValue -Value "REDACTED"
	
	        #Save your changes and close the ExcelPackage
	        $Excel | Save-Excel -Close
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [cmdletbinding(DefaultParametersetName = 'CellRange')]
	    param(
	        [parameter( Position = 0,
	                    ParameterSetName = 'CellRange',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelRangeBase]$CellRange,
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'Excel',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelPackage]$Excel,
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'File',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [validatescript({Test-Path $_})]
	        [string]$Path,
	
	        [parameter( Position = 0,
	                    ParameterSetName = 'Worksheet',
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelWorksheet]$WorkSheet,
	
	        [parameter(ParametersetName = 'Excel')]
	        [parameter(ParametersetName = 'File')]
	        [parameter(ParametersetName = 'Worksheet')]
	        [string]$WorksheetName,
	
	        [parameter(ParametersetName = 'Excel')]
	        [parameter(ParametersetName = 'File')]
	        [parameter(ParametersetName = 'Worksheet')]
	        [validatescript({
	            if( $_ -match "^[a-zA-Z]+[0-9]+:[a-zA-Z]+[0-9]+$" )
	            {
	                $True
	            }
	            else
	            {
	                Throw "'$_' is not a valid coordinate.  See help for 'Coordinates' parameter"
	            }
	
	        })]
	        [string]$Coordinates,
	
	        $Value,
	
	        [parameter(ParametersetName = 'Excel')]
	        [parameter(ParametersetName = 'CellRange')]
	        [parameter(ParametersetName = 'Worksheet')]
	        [switch]$Passthru
	
	    )
	    Process
	    {
	        Write-Verbose "PSBoundParameters: $($PSBoundParameters | Out-String)"
	
	        $WSParam = @{}
	        if($PSBoundParameters.ContainsKey( 'WorkSheetName') )
	        {
	            $WSParam.Add('Name',$WorkSheetName)
	        }
	        Try
	        {
	            switch ($PSCmdlet.ParameterSetName)
	            {
	                'Excel'
	                {
	                    $WorkSheets = @( $Excel | Get-Worksheet @WSParam -ErrorAction Stop )
	                }
	                'File'
	                {
	                    $Excel = New-Excel -Path $Path -ErrorAction Stop
	                    $WorkSheets = @( $Excel | Get-Worksheet @WSParam -ErrorAction Stop )
	                }
	                'Worksheet'
	                {
	                    $WorkSheets = @( $WorkSheet )
	                }
	                'CellRange'
	                {
	                    $WorkSheets = @( $CellRange.Worksheet | Select -First 1 )
	                }
	            }
	        }
	        Catch
	        {
	            Throw "Could not get worksheets to search: $_"
	        }
	
	        If($WorkSheets.Count -eq 0)
	        {
	            Throw "Something went wrong, we didn't find a worksheet"
	        }
	
	
	        foreach($Worksheet in $Worksheets)
	        {
	            if($PSCmdlet.ParameterSetName -notlike 'CellRange')
	            {
	                Write-Verbose "Working with worksheet $($Worksheet.Name)"
	                if($PSBoundParameters.ContainsKey('Coordinates'))
	                {
	                    Try
	                    {
	                        $CellRange = $WorkSheet.Cells.item($Coordinates)
	                    }
	                    Catch
	                    {
	                        Write-Error "Could not get cells from '$($WorkSheet.Name)' for coordinates '$Coordinates'"
	                        Continue
	                    }
	                }
	                else
	                {
	                    $CellRange = $Worksheet.Cells
	                }
	            }
	
	            $CellRange.Value = $Value
	            $StyleName = $null
	            $StyleFormat = $null
	            Try
	            {
	                #Nulls will error, catch them
	                $ThisType = $Null
	                $ThisType = $Value.GetType().FullName
	            }
	            Catch
	            {
	                Write-Verbose "Applying no style to null in range $($CellRange.FullAddress)"
	            }
	
	            Switch -regex ($ThisType)
	            {
	                "double|decimal|single"
	                {
	                    $StyleFormat = "0.00"
	                }
	                "int\d\d$"
	                {
	                    $StyleFormat = "0"
	                }
	                "datetime"
	                {
	                    $StyleFormat = "M/d/yyy h:mm"
	                }
	                default
	                {
	                    #No default yet...
	                }
	            }
	
	            if($StyleFormat)
	            {
	                $CellRange.Style.Numberformat.Format = $StyleFormat
	            }
	        }
	
	        switch($PSCmdlet.ParameterSetName)
	        {
	            'File'
	            {
	                $Excel.save()
	            }
	            'Excel'
	            {
	                if($Passthru) {$Excel}
	            }
	            'Worksheet'
	            {
	                if($Passthru) {$Worksheet}
	            }
	            'CellRange'
	            {
	                if($Passthru) {$CellRange}
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Set-FreezePane_ps1
function Call-Set-FreezePane_ps1
{
	function Set-FreezePane {
	    <#
	    .SYNOPSIS
	        Set FreezePanes on a specified worksheet
	
	    .DESCRIPTION
	        Set FreezePanes on a specified worksheet
	
	    .PARAMETER Worksheet
	        Worksheet to add FreezePanes to
	
	    .PARAMETER Row
	        The first row with live data.
	
	        Examples and outcomes:
	            -Row 2        Freeze row 1
	            -Row 5        Freeze rows 1 through 4
	
	    .PARAMETER Column
	        Examples and outcomes:
	            -Column 2     Freeze column 1
	            -Column 5     Freeze columns 1 through 4
	
	    .PARAMETER Passthru
	        If specified, pass the Worksheet back
	
	    .EXAMPLE
	        $WorkSheet | Set-FreezePane
	
	        #Freeze the top row of $Worksheet (default parameter values handle this)
	
	    .EXAMPLE
	        $WorkSheet | Set-FreezePane -Row 2 -Column 4
	
	        # Freeze the top row and top 3 columns of $Worksheet
	
	    .NOTES
	        Thanks to Doug Finke for his example:
	            https://github.com/dfinke/ImportExcel/blob/master/ImportExcel.psm1
	
	        Thanks to Philip Thompson for an expansive set of examples on working with EPPlus in PowerShell:
	            https://excelpslib.codeplex.com/
	
	    .LINK
	        https://github.com/RamblingCookieMonster/PSExcel
	
	    .FUNCTIONALITY
	        Excel
	    #>
	    [cmdletbinding()]
	    param(
	        [parameter( Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true)]
	        [OfficeOpenXml.ExcelWorksheet]$WorkSheet,
	
	        [int]$Row = 2,
	
	        [int]$Column = 1,
	
	        [switch]$Passthru
	
	    )
	    Process
	    {
	        $WorkSheet.View.FreezePanes($Row, $Column)
	        if($Passthru)
	        {
	            $WorkSheet
	        }
	    }
	}
	
}
#endregion

#region Call-Export-HIPAAControls_ps1
function Call-Export-HIPAAControls_ps1
{
	function Export-HIPAAControls {
	<#
	.SYNOPSIS
	
	.PARAMETER CKL
	
	.PARAMETER Output
	
	.PARAMETER name
	
	.PARAMETER recursive
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.16.2016)
	    -Intial Release
	#>
	    [CmdletBinding()]
	    Param(
	        [object]$file = $(Throw "No CKL Path Provided")#,
	        #[string]$output = $(Throw "No Output folder provided")
	    )
	
	    $matchObject = @()
	    $lines = [System.IO.File]::ReadAllLines($file.FullName)
	    foreach($line in $lines) {
	        if ($line -match '^\s*$') {
	            continue
	        }
	        else {
	            $Private:entry = ($Private:entry = " " | select-object Control, Subcontrol, Check)
	        }
	        if ($line -match '^\d{3}\.\d{3}\s' -and $line -notmatch '^\d{3}\.\d{3}\(') {
	            $Private:entry.Control = $($line.Trim())
	            $controlholder = $($line.Trim())
	        }
	        else {
	            $Private:entry.Control = $controlholder
	        }
	        if ($line -match '\d{3}\.\d{3}\(.+' -and $line -notmatch '\d{3}\.\d{3}\s\w+.+') {
	            $Private:entry.Subcontrol = $($line.Trim())
	            $subcontrolholder = $($line.Trim())
	        }
	        else {
	            $Private:entry.Subcontrol = $subcontrolholder
	        }
	        if ($line -match '^Q:') {
	            if ($line -notmatch '\?$') {
	                Write-Host "Warning"
	            }
	            $Private:entry.Check = $($line.Trim())
	        }
	        if ($Private:entry.Check){
	            $matchObject +=  $Private:entry
	        }
	    }
	
	
	    #$matchObject | Export-Csv -Path "$($output)\HIPAA_Controls.csv" -NoTypeInformation
	    return $matchObject
	}
	
}
#endregion

#region Call-Import-DIACAP_ps1
function Call-Import-DIACAP_ps1
{
	function Import-DIACAP {
	<#
	.SYNOPSIS
	
	.PARAMETER doc
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.15.2016)
	    -Intial Release
	#>
	
	    [CmdletBinding()]
	    Param(
	        [Object]$doc = $(Throw "No object provided")
	    )
	
	    PROCESS {
	        $docColumns = $($doc | Get-Member -MemberType NoteProperty).Name
	        if (!($docColumns -contains "Allocated Assessment ID" -and $docColumns -contains "Allocated Control ID" -and $docColumns -contains "Assessed By" -and $docColumns -contains "Assessment Date" -and $docColumns -contains "Assessment Objectives" -and $docColumns -contains "Assessment Status" -and $docColumns -contains "AssessmentObjectiveID" -and $docColumns -contains "Authorization Package" -and $docColumns -contains "Comments" -and $docColumns -contains "Control Implementation Status" -and $docColumns -contains "Control Name" -and $docColumns -contains "Control Number" -and $docColumns -contains "Impact Code" -and $docColumns -contains "Implementation Details" -and $docColumns -contains "Methods Used")) {
	            Throw "Sanity Check Failure: Columns are missing from DIACAP Control Doc"
	        }
	        return $doc
	    }
	}
	
}
#endregion

#region Call-Join-Controls_ps1
function Call-Join-Controls_ps1
{
	function Join-Controls {
	<#
	.SYNOPSIS
	
	.PARAMETER doc
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.15.2016)
	    -Intial Release
	#>
	
	    [CmdletBinding()]
	    Param(
	        [Object]$controls = $(Throw "No object provided"),
	        [object]$CKL = $(Throw "No object provided"),
	        [switch]$DIACAP,
	        [switch]$RMF
	    )
	
	    PROCESS {
	        if ($DIACAP) {
	            $foundFailedControls = $($ckl | Select IA_Controls -Unique | ForEach-Object {$_.IA_COntrols -replace '\s', ''})
	            if ($foundFailedControls.count -lt 1) {
	                Throw "Merge Selected but found nothing to merge"
	            }
	            foreach($control in $controls){
	                foreach ($failedcon in $foundFailedControls) {
	                    #Write-Host "$($failedcon)  $($control.'control number')"
	                    if($failedcon.split(",") -contains $($control."control number").trim()){
	                        #Write-Host "$($failedcon)  $($control.'control number')"
	                        if($control."Assessment Status" -match "Pass"){
	                            $control."Assessment Status" = "Fail"
	                            $control.Comments = "Various STIG items whose Rule ID's Map to this IA Control Number have failed. Please reference the report exports and the Test Plan for further details."
	                        }
	                    }
	                }
	            }
	            return $controls
	        }
	        if ($RMF) { # Place Holder
	        }
	    }
	}
	
	#$diacapxlsx = Import-XLSX -Path "C:\Users\josh\Google Drive\Work\modules\custom\PSIASTAND\tests\data\Controls\Sample_DODI_8500_2_Controls.xlsx"
	#$controls = Import-DIACAP -doc $diacapxlsx
	#$file = Get-Item -Path "C:\Users\josh\Google Drive\Work\modules\custom\PSIASTAND\tests\data\CKL\CKLv1\Sample04_Win2008R2MS.ckl"
	#$cklxml = Import-XML -fileobj $file
	#$cklfile = Import-CKL -doc $cklxml
	#$filteredCKL = $cklfile | Where-Object{$_.Status -eq "Open"}
	#compressedCKL = Compress-Report -Report $filteredCKL -CKL
	#$finalControls = Join-Controls -Controls $controls -CKL $compressedCKL -DIACAP
	
}
#endregion

#region Call-Get-NessusFile_ps1
function Call-Get-NessusFile_ps1
{
	function Get-NessusFile {
	<#
	.SYNOPSIS
	This function looks in the provided directory(s) and returns all files that end in .nessus
	
	.PARAMETER Path
	The location of the nessus file(s)
	
	.PARAMETER recurse
	This is a switch and tells the function if it should traverse the path that it was given looking for all
	nessus files
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (01.05.2016)
	    -Intial Release
	
	#>
	    [CmdletBinding()]
	    Param(
	        [ValidateNotNull()]
	        [string]$Path = $(Throw "No Path Provided"),
	
	        [Parameter(Mandatory = $false)]
	        [switch]$recursive
	    )
	
	    if($recursive){
	        Try {
	            $Private:listing = & $SafeCommands['Get-ChildItem'] -Path $Path -Filter "*.nessus" -Recurse -ErrorAction Stop -ErrorVariable GETITEM
	        }
	        Catch {
	            if($GETITEM) {
	                Throw "path not found"
	            }
	        }
	    }
	    else {
	        Try {
	            $Private:listing = & $SafeCommands['Get-ChildItem'] -Path $Path -Filter "*.nessus" -ErrorAction Stop -ErrorVariable GETITEM
	        }
	        Catch {
	            if($GETITEM) {
	                Throw "path not found"
	            }
	        }
	    }
	    if(!($Private:listing)){
	        Throw "No Nessus Files Found"
	    }
	    else {
	        return $Private:listing
	    }
	}
	
}
#endregion

#region Call-Import-Nessus_ps1
function Call-Import-Nessus_ps1
{
	function Import-Nessus {
	<#
	.SYNOPSIS
	Imports a nessus file into an object
	
	.PARAMETER doc
	The XML file to parse
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.10.2016)
	    -Intial Release
	#>
	    [CmdletBinding(DefaultparameterSetName="None")]
	    Param (
	        [Parameter(Mandatory=$true,Position=0,HelpMessage="XML Object to parse")]
	        [ValidateNotNull()]
	        [System.Xml.XmlDataDocument]$doc
	    )
	    if(!($doc.NessusClientData_v2)){
	        Throw "$($file.name) is not a nessus file"
	    }
	    $Private:results = @()
	    foreach($Private:ReportHost in $doc.NessusClientData_v2.Report.ReportHost){
	
	        foreach($Private:ReportItemsingle in $Private:ReportHost.ReportItem){
	            $Private:entry = ($Private:entry = " " | select-object "host-ip", "host-fqdn", "netbios-name", port, svc_name, protocol, severity, pluginID, pluginName, pluginFamily, description, fname, plugin_modification_date, plugin_name, plugin_publication_date, plugin_type, risk_factor, script_version, solution, synopsis, plugin_output, Credentialed_Scan)
	            $Private:entry.'host-ip' = $($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "host-ip"} | select -ExpandProperty "#text")
	            $Private:entry.'host-fqdn' = $($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "host-fqdn"} | select -ExpandProperty "#text")
	            $Private:entry.'netbios-name' = $($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "netbios-name"} | select -ExpandProperty "#text")
	            $Private:entry.port = $Private:ReportItemsingle.port
	            $Private:entry.svc_name = $Private:ReportItemsingle.svc_name
	            $Private:entry.protocol = $Private:ReportItemsingle.protocol
	            $Private:entry.severity = $Private:ReportItemsingle.severity
	            $Private:entry.pluginID = $Private:ReportItemsingle.pluginID
	            $Private:entry.pluginName = $Private:ReportItemsingle.pluginName
	            $Private:entry.pluginFamily = $Private:ReportItemsingle.pluginFamily
	            $Private:entry.description = $Private:ReportItemsingle.description
	            $Private:entry.fname = $Private:ReportItemsingle.fname
	            $Private:entry.plugin_modification_date = $Private:ReportItemsingle.plugin_modification_date
	            $Private:entry.plugin_name = $Private:ReportItemsingle.plugin_name
	            $Private:entry.plugin_publication_date = $Private:ReportItemsingle.plugin_publication_date
	            $Private:entry.plugin_type = $Private:ReportItemsingle.plugin_type
	            $Private:entry.risk_factor = $Private:ReportItemsingle.risk_factor
	            $Private:entry.script_version = $Private:ReportItemsingle.script_version
	            $Private:entry.solution = $Private:ReportItemsingle.solution
	            $Private:entry.synopsis = $Private:ReportItemsingle.synopsis
	            $Private:entry.plugin_output = $Private:ReportItemsingle.plugin_output
	            $Private:entry.Credentialed_Scan = $($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "Credentialed_Scan"} | select -ExpandProperty "#text")
	            $Private:results += $Private:entry
	        }
	    }
	    return $Private:results
	}
	
}
#endregion

#region Call-Import-NessusOpenPortsPlugin_ps1
function Call-Import-NessusOpenPortsPlugin_ps1
{
	function Import-NessusOpenPortsPlugin {
	<#
	.SYNOPSIS
	Imports a nessus scan file into an object
	
	.PARAMETER Path
	Path to look for
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (01.05.2016)
	    -Intial Release
	
	#>
	    [CmdletBinding()]
	    Param(
	        [ValidateNotNull()]
	        [Object]$file = $(Throw "No File Object Provided")
	    )
	
	    Try {
	        $ErrorActionPreference = 'Stop'
	        $Private:doc = New-Object System.Xml.XmlDataDocument # This creates a xlm document object
	        $Private:doc.Load($file.fullname)
	    }
	    Catch {
	        Throw "$($file.name) Not an XML Document"
	    }
	    $ErrorActionPreference = 'Continue'
	    if(!($Private:doc.NessusClientData_v2)){ # This checks to see if this is a Nessus xml file
	        Throw "$($file.name) Not a Nessus File"
	    }
	    $Private:results = @()
	    $Private:noPorts = @()
	    foreach($Private:ReportHost in $Private:doc.NessusClientData_v2.Report.ReportHost){
	        if($($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "Credentialed_Scan"} | select -ExpandProperty "#text") -eq "false"){
	            Throw "$($file.name) Not a credentialed Scan"
	        }
	        $Private:Ports = $Private:ReportHost.ReportItem | Where-Object{$_.pluginID -eq 34252}
	        if(!($Private:Ports) -or $Private:Ports.length -lt 1){
	            $Private:Ports = $Private:ReportHost.ReportItem | Where-Object{$_.pluginID -eq 25221}
	            if(!($Private:Ports) -or $Private:Ports.length -lt 1){
	                $Private:noPorts += $($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "host-ip"})
	                continue
	            }
	        }
	
	        foreach($Private:Port in $Private:Ports){
	            $Private:entry = ($Private:entry = " " | select-object Hostname, FGDN, IP, Port, Service, Protocal, Description, Plugin)
	            $Private:entry.Hostname = $($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "netbios-name"} | select -ExpandProperty "#text")
	            $Private:entry.FGDN = $($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "host-fqdn"} | select -ExpandProperty "#text")
	            $Private:entry.IP = $($Private:ReportHost.HostProperties.tag | Where-Object{$_.name -eq "host-ip"} | select -ExpandProperty "#text")
	            $Private:entry.Port = $Private:Port.port
	            $Private:entry.Service = $Private:Port.svc_name
	            $Private:entry.Protocal = $Private:Port.protocol
	            $Private:entry.Description = $Private:Port.plugin_output.trim("`r`n")
	            $Private:entry.Plugin = $Private:Port.pluginID
	            $Private:results += $Private:entry
	        }
	    }
	
	    return $Private:results, $Private:noPorts
	}
	
}
#endregion

#region Call-Invoke-NessusOpenPorts_ps1
function Call-Invoke-NessusOpenPorts_ps1
{
	function Invoke-NessusOpenPorts {
	<#
	.SYNOPSIS
	This module consumes nessus files and output the open ports detected on the host
	
	.PARAMETER Nessu
	The location of the nessus file(s)
	
	.PARAMETER packagename
	The Name of the package
	
	.PARAMETER outPut
	The location you want the output
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	2.0.0 (01.05.2016)
	    -Refactor the code to include better functions, unit testing, and modulized the code base
	1.0.0 ()
	    -Intial Release
	
	#>
	
	    [CmdletBinding(DefaultparameterSetName="None")]
	    Param(
	        [Parameter(Mandatory=$true,Position=0,HelpMessage="Location of Nessus File")]
	        [ValidateNotNull()]
	        [string]$Nessus,
	
	        [Parameter(Mandatory=$true,Position=2,HelpMessage="Provide the name of the package for report generation")]
	        [ValidateNotNull()]
	        [string]$packagename,
	
	        [Parameter(Mandatory=$true,Position=1,HelpMessage="You must provide the folder path for the report")]
	        [ValidateNotNull()]
	        [string]$outPut,
	
	        [Parameter(Mandatory=$false,Position=1,HelpMessage="Recursive switch for get nessus files")]
	        [switch]$recursive
	
	
	    )
	
	    BEGIN {
	        # initialize global variables
	        $script:start = & $script:SafeCommands['Get-Date']
	        $script:dateObject = & $script:SafeCommands['new-object'] system.globalization.datetimeformatinfo
	        $script:_output = $outPut.Trim('"').Trim("'")
	        $script:reportName = "$($packagename)_OpenPorts_$($script:start.Day)$($script:dateObject.GetMonthName($script:start.Month))$($script:start.Year).csv"
	        $script:reportNoPortName = "$($packagename)_NoOpenPorts_$($script:start.Day)$($script:dateObject.GetMonthName($script:start.Month))$($script:start.Year).csv"
	
	        Try {
	            & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - Start Time: $($script:start)"
	            & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - Creating Output Directory: $($script:_output)"
	            $null = Get-OutPutDir -Path $script:_output -ErrorAction Stop -ErrorVariable ERRORBEGINCHECKOUTPUTDIR
	            & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - Looking for Nessus Files"
	            if($recursive) {
	                $script:nessusFileList = GET-NessusFile -Path $NESSUS -recursive -ErrorAction Stop -ErrorVariable ERRORBEGINGETNESSUSFILES
	            }
	            else {
	                $script:nessusFileList = GET-NessusFile -Path $NESSUS -ErrorAction Stop -ErrorVariable ERRORBEGINGETNESSUSFILES
	            }
	            & $script:SafeCommands['Write-Verbose'] -Message "Found $($script:nessusFileList.Count) Nesssus File(s)"
	            & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - End time: $(& $script:SafeCommands['Get-Date'])"
	        }
	        Catch {
	            & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - Something has gone wrong"
	            if($ERRORBEGINCHECKOUTPUTDIR) {
	                & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - Could not create output directory at $($script:_output)"
	                & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - Running Time Before Error: $(Get-Timediff -start $script:start -end $(& $script:SafeCommands['Get-Date']))"
	                Throw $ERRORBEGINCHECKOUTPUTDIR[1]
	            }
	            if($ERRORBEGINGETNESSUSFILES) {
	                & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - Cannot find $($Nessus)"
	                & $script:SafeCommands['Write-Verbose'] -Message "BEGIN BLOCK - Running Time Before Error: $(Get-Timediff -start $script:start -end $(& $script:SafeCommands['Get-Date']))"
	                Throw $ERRORBEGINGETNESSUSFILES
	            }
	        }
	    }
	    Process {
	        Try {
	            & $script:SafeCommands['Write-Verbose'] -Message "PROCESS BLOCK - Start Time: $(& $script:SafeCommands['Get-Date'])"
	            & $script:SafeCommands['Write-Verbose'] -Message "PROCESS BLOCK - Starting to process Nessus Files"
	            $Script:compiledNessusObjReal = @()
	            $Script:noportsDetectedReal = @()
	            foreach($script:file in $script:nessusFileList) {
	                & $script:SafeCommands['Write-Verbose'] -Message "PROCESS BLOCK - Processing: $($script:file.Name)"
	                $Script:compiledNessusObj, $Script:noportsDetected = $(Import-NessusOpenPortsPlugin -file $script:file -ErrorAction Stop -ErrorVariable ERRORPROCESSPROCESSNESSUSFILE)
	                $Script:compiledNessusObjReal += $Script:compiledNessusObj
	                $Script:noportsDetectedReal += $Script:noportsDetected
	            }
	            & $script:SafeCommands['Write-Verbose'] -Message "PROCESS BLOCK - End Time: $(& $script:SafeCommands['Get-Date'])"
	        }
	        Catch{
	            & $script:SafeCommands['Write-Verbose'] -Message "PROCESS BLOCK - Something has gone wrong"
	            if($ERRORPROCESSPROCESSNESSUSFILE) {
	                & $script:SafeCommands['Write-Verbose'] -Message "PROCESS BLOCK - $($script:file.FullName) did not validate as a proper Nessus File"
	                & $script:SafeCommands['Write-Verbose'] -Message "PROCESS BLOCK - Running Time Before Error: $(Get-Timediff -start $script:start -end $(& $script:SafeCommands['Get-Date']))"
	                Throw $ERRORPROCESSPROCESSNESSUSFILE[1]
	            }
	        }
	    }
	    END {
	        $Script:end = & $script:SafeCommands['Get-Date']
	        Try{
	            & $script:SafeCommands['Write-Verbose'] -Message "END BLOCK - Start Time: $(& $script:SafeCommands['Get-Date'])"
	            & $script:SafeCommands['Write-Verbose'] -Message "END BLOCK - Exporting Open Ports to: $($script:_output)\$script:reportName"
	            $Script:compiledNessusObjReal | Export-Csv -Path "$($script:_output)\$script:reportName" -NoTypeInformation -ErrorAction Stop -ErrorVariable ERRORENDCREATECSVREPORT
	            if($Script:noportsDetectedReal) {
	                $Script:noportsDetectedReal | Export-Csv -Path "$($script:_output)\$script:reportNoPortName" -NoTypeInformation -ErrorAction Stop -ErrorVariable ERRORENDCREATECSVREPORT
	            }
	            & $script:SafeCommands['Write-Verbose'] -Message "END BLOCK - End Time: $(& $script:SafeCommands['Get-Date'])"
	            & $script:SafeCommands['Write-Verbose'] -Message "END BLOCK - Total Script Run Time: $(Get-Timediff -start $script:start -end $Script:end)"
	        }
	        Catch{
	            & $script:SafeCommands['Write-Verbose'] -Message  "END BLOCK - Something has gone wrong"
	            if($ERRORENDCREATECSVREPORT) {
	                & $script:SafeCommands['Write-Verbose'] -Message "END BLOCK - Could not create Report"
	                & $script:SafeCommands['Write-Verbose'] -Message "PROCESS BLOCK - Running Time Before Error: $(Get-Timediff -start $script:start -end $Script:end))"
	                Throw $ERRORENDCREATECSVREPORT
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-Export-CombinedReports_ps1
function Call-Export-CombinedReports_ps1
{
	function Export-CombinedReports {
	<#
	.SYNOPSIS
	This function loads Nessus and CKL files and outputs a combined CKL report and a nessus report in human readable form
	
	.PARAMETER CKLFILES
	Path to the CKL Files. We process from the CKL files
	because they are in a standard format. We can import both v1 and v2
	CKL files
	
	.PARAMETER NESSUS
	Path to the nessus Files.
	
	.PARAMETER Output
	This is the path where we output the reports
	
	.PARAMETER name
	This is the name/project/package that is being processed
	
	.PARAMETER xlsx
	This is a switch that allows you to output to xlsx instead of csv
	
	.PARAMETER Recursive
	Recursively find CKL and Nessus files
	
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.10.2016)
	    -Intial Release
	
	#>
	
	    [CmdletBinding(DefaultparameterSetName="None")]
	    Param(
	        [Parameter(Mandatory=$false,Position=0,HelpMessage="You must provide the folder path to the CKL files to process")]
	        [Alias('Folder', 'location', 'CKL')]
	        [string]$CKLFILES,
	
	        [Parameter(Mandatory=$false,Position=1,HelpMessage="You must provide the location of the .nessus files to process")]
	        [ValidateNotNull()]
	        [Alias('A', 'SCAN','ACAS')]
	        [string]$NESSUS,
	
	        [Parameter(Mandatory=$false,Position=2,HelpMessage="You must provide the folder path to be used for the output. If the location provided does not exsist it will be created")]
	        [ValidateNotNull()]
	        [Alias('OUT', 'outlocation', 'O')]
	        [string]$Output = $(Throw "No output path given"),
	
	        [Parameter(Mandatory=$false,Position=3,HelpMessage="You must provide a name for the report that will be created.")]
	        [ValidateNotNull()]
	        [Alias('Report','N')]
	        [string]$name,
	
	        [Parameter(Mandatory=$false,Position=4,HelpMessage="Switch to designate output in excel. defualts to csv")]
	        [switch]$xlsx,
	
	        [Parameter(Mandatory=$false,Position=5,HelpMessage="Switch for recursive look for files")]
	        [Alias('R')]
	        [switch]$Recursive
	    )
	
	    BEGIN {
	        if (!$CKLFILES -and !$NESSUS) { # Check to see if ckl or nessus paths where defined. if neither are defined throw an error
	            Throw "No paths defined"
	        }
	
	        if ($CKLFILES) { # Check for CKL file(s) path
	            if ((Test-Path -Path $CKLFILES)) { # Check path
	                if ($Recursive) { # check for recursion
	                    $Private:cfiles = Get-ChildItem -Path $CKLFILES -Filter "*.ckl" -Recurse
	                }
	                else {
	                    $Private:cfiles = Get-ChildItem -Path $CKLFILES -Filter "*.ckl"
	                }
	                if (!$Private:cfiles) { # check to see if files are returned
	                    Throw "No CKL Files Found"
	                }
	            }
	            else { # path does not exist
	                Throw "CKL path does not exist"
	            }
	        }
	
	        if ($NESSUS) { # Check for Nessus file(s) path
	            if ((Test-Path -Path $NESSUS)) { # Check path
	                if ($Recursive) { # check for recursion
	                    $Private:nessusfiles = Get-ChildItem -Path $NESSUS -Filter "*.nessus" -Recurse
	                }
	                else {
	                    $Private:nessusfiles = Get-ChildItem -Path $NESSUS -Filter "*.nessus"
	                }
	                if (!$Private:nessusfiles) { # check to see if files are returned
	                    Throw "No Nessus Files Found"
	                }
	            }
	            else { # path does not exist
	                Throw "NESSUS path does not exist"
	            }
	        }
	    }
	    PROCESS {
	        if ($CKLFILES) { # if ckl path provided
	            $Private:compiledCKLReport = @() # Compiled CKL
	            $Private:cklversioncheck = 0 # Version check mismatched CKL version files will not work correctly
	            foreach ($Private:file in $Private:cfiles) {
	                Try {
	                    $Private:xml = Import-XML -fileobj $Private:file -erroraction stop # Import XML
	                    $Private:ckl = import-ckl -doc $Private:xml -erroraction stop # Import CKL from XML
	                    if ($Private:cklversioncheck -eq 0) { # Set CKL Version Level
	                        $Private:cklversioncheck = $Private:ckl[0].StigViewer_Version
	                    }
	                    elseif ($Private:ckl[0].StigViewer_Version -ne $Private:cklversioncheck) { # Check returned CKL version against approved CKL Version
	                        Throw "$($Private:file.name) CKL Version mismatch error"
	                    }
	                    $Private:compiledCKLReport += $Private:ckl
	                }
	                Catch {
	                    Throw "$($Private:file.name) CKL file failed to process"
	                }
	            }
	        }
	        if ($NESSUS) { # if Nessus path provided
	            $Private:compilednessusreport = @() # Compiled Nessus
	            foreach ($Private:file in $Private:nessusfiles) {
	                $Private:xml = Import-XML -fileobj $Private:file -erroraction stop # Import XML
	                $Private:nessusobj = Import-Nessus -doc $Private:xml # Import Nessus from XML
	                $Private:compilednessusreport += $Private:nessusobj
	            }
	            foreach($Private:nobj in $Private:compilednessusreport) {
	                $Private:nobj.description = $(if($($Private:nobj.description).length -gt 32768){$($Private:nobj.description).SubString(0,1000)}else{$Private:nobj.description})
	                $Private:nobj.solution = $(if($($Private:nobj.solution).length -gt 32768){$($Private:nobj.solution).SubString(0,1000)}else{$Private:nobj.solution})
	                $Private:nobj.synopsis = $(if($($Private:nobj.synopsis).length -gt 32768){$($Private:nobj.synopsis).SubString(0,1000)}else{$Private:nobj.synopsis})
	                $Private:nobj.plugin_output = $(if($($Private:nobj.plugin_output).length -gt 32768){$($Private:nobj.plugin_output).SubString(0,1000)}else{$Private:nobj.plugin_output})
	            }
	        }
	    }
	    END {
	        if ($xlsx) {
	            if ($Private:compiledCKLReport) {
	                Export-XLSX -Path "$($Output)\$($name)_CKL.xlsx" -InputObject $Private:compiledCKLReport
	            }
	            if ($Private:compilednessusreport) {
	                Export-XLSX -Path "$($Output)\$($name)_Nessus.xlsx" -InputObject $Private:compilednessusreport
	            }
	        }
	        else {
	            if ($Private:compiledCKLReport) {
	                Export-Csv -Path "$($Output)\$($name)_CKL.csv" -InputObject $Private:compiledCKLReport
	            }
	            if ($Private:compilednessusreport) {
	                Export-Csv -Path "$($Output)\$($name)_Nessus.csv" -InputObject $Private:compilednessusreport
	            }
	        }
	    }
	}
	
	
}
#endregion

#region Call-Export-RiskElements_ps1
function Call-Export-RiskElements_ps1
{
	function Export-RiskElements {
	<#
	.SYNOPSIS
	Imports files containing RISK elements and outputs a unique list of the elements
	
	.PARAMETER CKLFILES
	
	.PARAMETER NESSUS
	
	.PARAMETER DIACAP
	
	.PARAMETER RMF
	
	.PARAMETER Name
	
	.PARAMETER Output
	
	.PARAMETER mergecontrol
	
	.PARAMETER recursive
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.15.2016)
	    -Intial Release
	#>
	    [CmdletBinding(DefaultparameterSetName="None")]
	    Param(
	        [Parameter(Mandatory=$false,HelpMessage="Please provide the folder path to the CKL files to process")]
	        [string]$CKLFILES = $null,
	
	        [Parameter(Mandatory=$false,HelpMessage="Please provide the location of the .nessus files to process")]
	        [string]$NESSUS = $null,
	
	        [Parameter(Mandatory=$false,HelpMessage="Please provide the location of the 8500 controls file to process")]
	        [string]$DIACAP = $null,
	
	        [Parameter(Mandatory=$false,HelpMessage="Please provide the location of the RMF controls file to process")]
	        [string]$RMF = $null,
	
	        [Parameter(Mandatory=$false,HelpMessage="Please provide the name of IS (Information System) or package name")]
	        [string]$Name = $(Throw "No Name was provided"),
	
	        [Parameter(Mandatory=$false,HelpMessage="You must provide the folder path to be used for the output. If the location provided does not exsist it will be created")]
	        [string]$Output = $(Throw "No output path given"),
	
	        [Parameter(Mandatory=$false,HelpMessage="Switch to merge IA controls that fail from the CKL into the Control import")]
	        [switch]$mergecontrol,
	
	        [Parameter(Mandatory=$false,HelpMessage="Switch to recursivly look for risk element files")]
	        [switch]$recursive
	    )
	
	    BEGIN {
	        if (!$CKLFILES -and !$NESSUS -and !$DIACAP -and !$RMF){Throw "Nothing to process"}
	        if ($DIACAP -and $RMF) { # check to see if DIACAP and RMF are specified
	            Throw "Both DIACAP and RMF Specified. Please select DIACAP OR RMF"
	        }
	
	        if ($recursive) { # recursive loop for files
	            if ($CKLFILES) {
	                if(!(Test-Path -Path $CKLFILES)) {Throw "CKL Path not found"}
	                $cfiles = Get-ChildItem -Path $CKLFILES -Filter "*.ckl" -Recurse
	                if ($cfiles.count -lt 1) {Throw "No CKL files found"}
	            }
	            if ($NESSUS) {
	                if(!(Test-Path -Path $NESSUS)) {Throw "Nessus Path not found"}
	                $nFiles = Get-ChildItem -Path $NESSUS -Filter "*.nessus" -Recurse
	                if ($nfiles.count -lt 1) {Throw "No NESSUS files found"}
	            }
	        }
	        else {
	            if ($CKLFILES) {
	                if(!(Test-Path -Path $CKLFILES)) {Throw "CKL Path not found"}
	                $cfiles = Get-ChildItem -Path $CKLFILES -Filter "*.ckl"
	                if ($cfiles.count -lt 1) {Throw "No CKL files found"}
	            }
	            if ($NESSUS) {
	                if(!(Test-Path -Path $NESSUS)) {Throw "Nessus Path not found"}
	                $nFiles = Get-ChildItem -Path $NESSUS -Filter "*.nessus"
	                if ($nfiles.count -lt 1) {Throw "No NESSUS files found"}
	            }
	        }
	
	        if ($DIACAP) {
	            $controlfile = Get-Item -Path $DIACAP
	            if ($controlfile.count -lt 1) {Throw "No DIACAP files found"}
	        }
	        if ($RMF) {
	            $controlfile = Get-Item -Path $RMF
	            if ($controlfile.count -lt 1) {Throw "No RMF files found"}
	        }
	    }
	    PROCESS {
	
	        if($CKLFILES) { # if CKL
	            Try {
	                $compiledCKLObj = @()
	                foreach ($file in $cfiles) { # Process CKL Files
	                    $xml = Import-XML -fileobj $file
	                    $ckl = Import-CKL -doc $xml
	                    $compiledCKLObj += $ckl
	                } # End For loop
	                $filteredcompiledCKLObj = $compiledCKLObj | Where-Object{$_.Status -match "Open"}
	                $compressedcompiledCKLObj = Compress-Report -report $filteredcompiledCKLObj -ckl
	                $riskelementCKLObj = ConvertTo-RiskElements -report $compressedcompiledCKLObj -ckl
	            }
	            Catch{
	                Throw "$($file.name) CKL failed to process"
	            }
	        } # end if CKL
	
	        if ($NESSUS) { # If Nessus
	            Try {
	                $compiledNessusObj = @()
	                foreach ($file in $nFiles) { # Process Nessus Files
	                    $xml = Import-XML -fileobj $file
	                    $nes = Import-Nessus -doc $xml
	                    $compiledNessusObj += $nes
	                } # end for loop
	               $filteredcompiledNessusObj = $compiledNessusObj | Where-Object{$_.risk_factor -notmatch "None"}
	               $compressedcompiledNessusObj = Compress-Report -report $filteredcompiledNessusObj -nessus
	               $riskelementNessusObj = ConvertTo-RiskElements -report $compressedcompiledNessusObj -nessus
	            }
	            Catch {
	                Throw "$($file.name) Nessus failed to process"
	            }
	        } # end if Nessus
	
	        if ($DIACAP) { # If DIACAP
	            Try {
	                $IAControlXLSX = Import-XLSX -Path $($controlfile.FullName)
	                $IAControl = Import-DIACAP -doc $IAControlXLSX
	                if ($mergecontrol) {
	                    $finalControl = Join-Controls -controls $IAControl -ckl $compressedcompiledCKLObj -DIACAP
	                }
	                else {
	                    $finalControl = $IAControl
	                }
	                $filteredfinalControl = $finalControl | Where-Object{$_."Assessment Status" -match "Fail"}
	                $riskelementControl = ConvertTo-RiskElements -report $filteredfinalControl -diacap
	            }
	            Catch {
	                Throw "$($controlfile.Name) IA Controls failed to process"
	            }
	        } # end if DIACAP
	
	        if ($RMF) { # If RMF
	            Try {
	            }
	            Catch {
	            }
	        } # end if RMF
	    }
	    END {
	        $riskelements = $null
	        if ($riskelementCKLObj) {
	            $riskelements += $riskelementCKLObj
	        }
	        if ($riskelementNessusObj) {
	            $riskelements += $riskelementNessusObj
	        }
	        if ($riskelementControl) {
	            $riskelements += $riskelementControl
	        }
	
	        Export-XLSX -PATH "$($Output)\$($name)_Risk.xlsx" -InputObject $riskelements
	    }
	}
	
}
#endregion

#region Call-Get-Compliance_ps1
function Call-Get-Compliance_ps1
{
	function Get-Compliance {
	<#
	.SYNOPSIS
	
	.PARAMETER CKL
	
	.PARAMETER Output
	
	.PARAMETER name
	
	.PARAMETER recursive
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.16.2016)
	    -Intial Release
	#>
	
	    [CmdletBinding()]
	    Param(
	        [string]$ckl = $(Throw "No CKL Path Provided"),
	        [string]$output = $(Throw "No Output folder provided"),
	        [String]$name = $(Throw "No Name provided"),
	        [switch]$recursive
	    )
	
	    BEGIN {
	        #weighted Values
	        $highweight = 0.6
	        $medweight = 0.35
	        $lowweight = 0.05
	
	        if ($recursive) {
	            if(!(Test-Path -Path $ckl)) {Throw "CKL Path not found"}
	            $cfiles = Get-ChildItem -Path $ckl -Filter "*.ckl" -Recurse
	            if ($cfiles.count -lt 1) {Throw "No CKL files found"}
	        }
	        else {
	            if(!(Test-Path -Path $ckl)) {Throw "CKL Path not found"}
	            $cfiles = Get-ChildItem -Path $ckl -Filter "*.ckl"
	            if ($cfiles.count -lt 1) {Throw "No CKL files found"}
	        }
	    }
	    PROCESS {
	        Try {
	            $compiledCKLObj = @()
	            foreach ($file in $cfiles) { # Process CKL Files
	                $xml = Import-XML -fileobj $file
	                $cklfile = Import-CKL -doc $xml
	                $compiledCKLObj += $cklfile
	            } # End For loop
	        }
	        Catch{
	            Throw "$($file.name) CKL failed to process"
	        }
	        $stiglist = $($compiledCKLObj | Select STIG_Title -Unique | ForEach-Object{$($_.STIG_Title).trim()})
	        $complianceReport = @()
	        foreach ($stig in $stiglist) {
	            $current = $($compiledCKLObj | Where-Object {$_.STIG_Title -eq $stig})
	            $Private:entry = ($Private:entry = " " | select-object STIG, Systems, System_Count, High_Count_Finding, MED_Count_Finding, LOW_Count_Finding, High_Total, MED_Total, LOW_Total, Total_Checks, Total_Points, Lost_Points, Compliance_Percentage, Compliant)
	            $Private:entry.STIG = $stig
	            $Private:entry.Systems = $((($current | Select AssetName -Unique).AssetName) -Join "`n`r")
	            $Private:entry.System_Count = $((($current | Select AssetName -Unique).AssetName).count)
	            $Private:entry.High_Count_Finding = $((($current | Where-Object {$_.Severity -eq "High" -and $_.Status -eq "Open" }).Status).count)
	            $Private:entry.MED_Count_Finding = $((($current | Where-Object {$_.Severity -eq "Medium" -and $_.Status -eq "Open" }).Status).count)
	            $Private:entry.LOW_Count_Finding = $((($current | Where-Object {$_.Severity -eq "Low" -and $_.Status -eq "Open" }).Status).count)
	            $Private:entry.High_Total = $((($current | Where-Object {$_.Severity -eq "High"}).Severity).count)
	            $Private:entry.MED_Total = $((($current | Where-Object {$_.Severity -eq "Medium"}).Severity).count)
	            $Private:entry.LOW_Total = $((($current | Where-Object {$_.Severity -eq "Low"}).Severity).count)
	            $Private:entry.Total_Checks = $(($current).count)
	            $Private:entry.Total_Points = ($Private:entry.High_Total * $highweight) + ($Private:entry.MED_Total * $medweight) + ($Private:entry.LOW_Total * $lowweight)
	            $Private:entry.Lost_Points = ($Private:entry.High_Count_Finding * $highweight) + ($Private:entry.MED_Count_Finding * $medweight) + ($Private:entry.LOW_Count_Finding * $lowweight)
	            $Private:entry.Compliance_Percentage = $((($Private:entry.Total_Points) - ($Private:entry.Lost_Points)) / ($Private:entry.Total_Points))
	            if ($Private:entry.Compliance_Percentage -lt .75 -or $Private:entry.High_Count_Finding -gt 0) {
	                $Private:entry.Compliant = "FALSE"
	            }
	            else {
	                $Private:entry.Compliant = "TRUE"
	            }
	            $complianceReport += $Private:entry
	        }
	
	    }
	    END {
	        Export-XLSX -Path "$($output)\$($name)_STIG_Compliance_Report.xlsx" -InputObject $complianceReport
	    }
	}
	#$($ness.NessusClientData_v2.Policy.Preferences.ServerPreferences.preference | Where-Object {$_.Name -eq "Plugin_Set"}).value
	
}
#endregion

#region Call-Update-Controls_ps1
function Call-Update-Controls_ps1
{
	function Update-Controls {
	<#
	.SYNOPSIS
	
	.PARAMETER path
	
	.PARAMETER CKL
	
	.PARAMETER Output
	
	.PARAMETER name
	
	.PARAMETER diacap
	
	.PARAMETER rmf
	
	.PARAMETER recursive
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.16.2016)
	    -Intial Release
	#>
	
	    [CmdletBinding()]
	    Param(
	        [string]$path = $(Throw "No path Provided"),
	        [string]$ckl = $(Throw "No CKL Path Provided"),
	        [string]$output = $(Throw "No Output folder provided"),
	        [String]$name = $(Throw "No Name provided"),
	        [switch]$diacap,
	        [switch]$rmf,
	        [switch]$recursive
	    )
	
	    BEGIN {
	        if (!$DIACAP -and !$RMF) {Throw "No report type selected"}
	        if ($DIACAP -and $RMF) {Throw "Both DIACAP and RMF Selected"}
	        if ($recursive) {
	            if(!(Test-Path -Path $ckl)) {Throw "CKL Path not found"}
	            $cfiles = Get-ChildItem -Path $ckl -Filter "*.ckl" -Recurse
	            if ($cfiles.count -lt 1) {Throw "No CKL files found"}
	        }
	        else {
	            if(!(Test-Path -Path $ckl)) {Throw "CKL Path not found"}
	            $cfiles = Get-ChildItem -Path $ckl -Filter "*.ckl"
	            if ($cfiles.count -lt 1) {Throw "No CKL files found"}
	        }
	        if ($DIACAP) {
	            $controlfile = Get-Item -Path $path
	            if ($controlfile.count -lt 1) {Throw "No DIACAP files found"}
	        }
	        if ($RMF) {
	            $controlfile = Get-Item -Path $path
	            if ($controlfile.count -lt 1) {Throw "No RMF files found"}
	        }
	    }
	    PROCESS {
	        Try {
	            $compiledCKLObj = @()
	            foreach ($file in $cfiles) { # Process CKL Files
	                $xml = Import-XML -fileobj $file
	                $cklfile = Import-CKL -doc $xml
	                $compiledCKLObj += $cklfile
	            } # End For loop
	            $filteredcompiledCKLObj = $compiledCKLObj | Where-Object{$_.Status -match "Open"}
	            $compressedcompiledCKLObj = Compress-Report -report $filteredcompiledCKLObj -ckl
	        }
	        Catch{
	            Throw "$($file.name) CKL failed to process"
	        }
	        if ($DIACAP) { # If DIACAP
	            Try {
	                $IAControlXLSX = Import-XLSX -Path $($controlfile.FullName)
	                $IAControl = Import-DIACAP -doc $IAControlXLSX
	                $finalControl = Join-Controls -controls $IAControl -ckl $compressedcompiledCKLObj -DIACAP
	            }
	            Catch {
	                Throw "$($controlfile.Name) IA Controls failed to process"
	            }
	        } # end if DIACAP
	
	        if ($RMF) { # If RMF
	            Try {
	            }
	            Catch {
	            }
	        } # end if RMF
	    }
	    END {
	        if ($DIACAP) {
	            Export-XLSX -Path "$($output)\$($name)_8500.2_Controls.xlsx" -InputObject $finalControl
	        }
	        else {
	            Export-XLSX -Path "$($output)\$($name)_RMF_Controls.xlsx" -InputObject $finalControl
	        }
	    }
	}
	
}
#endregion

#region Call-Update-TestPlan_ps1
function Call-Update-TestPlan_ps1
{
	function Update-TestPlan {
	<#
	.SYNOPSIS
	
	.PARAMETER CKL
	
	.PARAMETER testplan
	
	.PARAMETER Output
	
	.PARAMETER name
	
	.PARAMETER recursive
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.1 (02.19.2016)
	    - Added -replace "r\d+_rule" to strip r#_rule from rule ID. This portion of the rule ID details the revision of the rule and due
	        to MCCAST being behind on import the STIGS this will cause Items to not match
	
	1.0.0 (02.16.2016)
	    -Intial Release
	#>
	
	    [CmdletBinding()]
	    Param(
	        [string]$ckl = $(Throw "No CKL Path provided"),
	        [string]$testplan = $(Throw "No Testplan provided"),
	        [string]$output = $(Throw "No Output folder provided"),
	        [String]$name = $(Throw "No Name provided"),
	        [int]$version = 1,
	        [switch]$recursive
	    )
	
	    BEGIN {
	        if ($recursive) {
	            if(!(Test-Path -Path $ckl)) {Throw "CKL Path not found"}
	            $cfiles = Get-ChildItem -Path $ckl -Filter "*.ckl" -Recurse
	            if ($cfiles.count -lt 1) {Throw "No CKL files found"}
	        }
	        else {
	            if(!(Test-Path -Path $ckl)) {Throw "CKL Path not found"}
	            $cfiles = Get-ChildItem -Path $ckl -Filter "*.ckl"
	            if ($cfiles.count -lt 1) {Throw "No CKL files found"}
	        }
	        if(!(Test-Path -Path $testplan)) {Throw "Testplan not found"}
	        else {$testplanimport = Import-XLSX -Path $testplan}
	        if ($testplanimport.count -lt 1) {Throw "Testplan count is less than 1. Please check testplan"}
	    }
	    PROCESS {
	        Try {
	            $compiledCKLObj = @()
	            foreach ($file in $cfiles) { # Process CKL Files
	                $xml = Import-XML -fileobj $file
	                $cklfile = Import-CKL -doc $xml
	                $compiledCKLObj += $cklfile
	            } # End For loop
	        }
	        Catch{
	            Throw "$($file.name) CKL failed to process"
	            exit
	        }
	        $((($current | Select AssetName -Unique).AssetName))
	        if ($version -eq 1) {
	            #Try {
	                #$listofassets = $((($testplanimport | Select "Hardware Name" -Unique)."Hardware Name") | ForEach-Object {$_.trim()}) # for Later use
	                $listofimportassets = $((($compiledCKLObj | Select "AssetName" -Unique)."AssetName") | ForEach-Object {$_.trim()})
	                foreach ($assetname in $listofimportassets) {
	                    $findings = $($compiledCKLObj | Where-Object {$_."AssetName" -match $assetname})
	                    $importlist = $($testplanimport | Where-Object {$_."Hardware Name" -match $assetname})
	                    foreach ($finding in $findings) {
	                        $rowintestplan = $importlist | Where-Object {$_."Rule ID" -match $(($finding.Rule_ID) -replace "r\d+_rule")}
	                        if ($rowintestplan) {
	                            $rowintestplan."Implementation Result" = $(if($finding.STATUS -match "NotAfinding"){"Pass"}elseif($finding.STATUS -match "open"){"Fail"}else{$($finding.STATUS)})
	                            $rowintestplan."Implementer Comments" = $($finding.FINDING_DETAILS)
	                        }
	                    }
	                }
	            #}
	        #Catch {
	        #}
	
	        }
	        elseif ($version -eq 2) {
	            #Place holder for Version 2 info
	        }
	        else {
	            Throw "Version unknown"
	        }
	    }
	    END {
	        Export-XLSX -Path "$($output)\$($name)_TestPlan.xlsx" -InputObject $testplanimport
	    }
	}
	
	#Update-TestPlan -ckl "C:\Users\josh\Google Drive\Work\modules\custom\PSIASTAND\tests\data\CKL\CKLv1" -testplan "C:\Users\josh\Google Drive\Work\modules\custom\PSIASTAND\tests\data\MCCAST_TestPlan\MCCAST_TestPlan.xlsx" -output "C:\Users\josh\Google Drive\Work\modules\custom\PSIASTAND\tests\data" -name "APP_OWNER" -version 1
	
}
#endregion

#region Call-Invoke-RiskAlgorithm_ps1
function Call-Invoke-RiskAlgorithm_ps1
{
	function Invoke-RiskAlgorithm {
	<#
	.SYNOPSIS
	
	.PARAMETER risk
	
	.PARAMETER map
	
	.PARAMETER docrisk
	
	.PARAMETER sysrisk
	
	.PARAMETER output
	
	.PARAMETER name
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.17.2016)
	    -Intial Release
	#>
	
	    [CmdletBinding()]
	    Param(
	        [string]$risk = $(Throw "No RISK Path provided"),
	        [string]$map = $(Throw "No MAP provided"),
	        [int]$docrisk = $(Throw "No Documentation level provided"),
	        [int]$sysrisk = $(Throw "No System Knowledge level provided"),
	        [string]$output = $(Throw "No Output folder provided"),
	        [String]$name = $(Throw "No Name provided")
	    )
	
	    BEGIN {
	        $VeryHighweight = 0.5
	        $Highweight = 0.25
	        $Mediumweight = 0.15
	        $lowweight = 0.09
	        $verylowweight = 0.01
	
	        $tech = 0.50
	        $docu = 0.40
	        $sysKno = 0.10
	
	        if ($docrisk -gt 100 -or $docrisk -lt 0 -or $sysrisk -gt 100 -or $sysrisk -lt 0) {Throw "System Knowledge risk or Documentation risk falls outside of 0-100"}
	        if(!(Test-Path -Path $risk)){Throw "Risk path does not exist"}
	        if(!(Test-Path -Path $map)){Throw "Map path does not exist"}
	        $riskelements = Import-XLSX -Path $risk
	        $riskmap = Import-XLSX -Path $map
	        $riskmapnamelist = $(($riskmap | Select name).name)
	        foreach ($element in $riskelements) {
	            if (!($riskmapnamelist -contains $($element.name))) {
	                Throw "$($element.name) is not mapped"
	            }
	        }
	
	        foreach ($element in $riskelements) {
	            $mapping = $riskmap | Where-Object {$_.Name -eq $($element.name)}
	            $element."Assessed Risk Level" = $($mapping."Assessed Risk Level")
	            $element."Quantitative Values" = $($mapping."Quantitative Values")
	        }
	        $VeryHigh = $riskelements | Where-Object {$_."Assessed Risk Level" -eq "Very High"}
	        $High = $riskelements | Where-Object {$_."Assessed Risk Level" -eq "High"}
	        $Medium = $riskelements | Where-Object {$_."Assessed Risk Level" -eq "Medium"}
	        $Low = $riskelements | Where-Object {$_."Assessed Risk Level" -eq "Low"}
	        $VeryLow = $riskelements | Where-Object {$_."Assessed Risk Level" -eq "Very Low"}
	
	        if ($VeryHigh) {
	            $VeryHighCount = $VeryHigh.count
	            $num = $VeryHigh."Quantitative Values"
	            $VeryHighAVG = Get-Average -array $num
	        }
	        else {
	            $VeryHighCount = 0
	            $VeryHighAVG = 0
	        }
	        if ($High) {
	            $HighCount = $High.count
	            $num = $High."Quantitative Values"
	            $HighAVG = Get-Average -array $num
	        }
	        else {
	            $HighCount = 0
	            $HighAVG = 0
	        }
	        if ($Medium) {
	            $MediumCount = $Medium.count
	            $num = $Medium."Quantitative Values"
	            $MediumAVG = Get-Average -array $num
	        }
	        else {
	            $MediumCount = 0
	            $MediumAVG = 0
	        }
	        if ($Low) {
	            $LowCount = $Low.Count
	            $num = $Low."Quantitative Values"
	            $LowAVG = Get-Average -array $num
	        }
	        else {
	            $LowCount = 0
	            $LowAVG = 0
	        }
	        if ($VeryLow) {
	            $VeryLowCount = $VeryLow.Count
	            $num = $VeryLow."Quantitative Values"
	            $VeryLowAVG = Get-Average -array $num
	        }
	        else {
	            $VeryLowCount = 0
	            $VeryLowAVG = 0
	        }
	    }
	    PROCESS {
	        $results = ($results = " " | select-object "Technical Review", "Overall Documentation", "Knowledge of the System", "VERY HIGH", "HIGH", "MEDIUM", "LOW", "VERY LOW", "AVG VERY HIGH", "AVG HIGH", "AVG MEDIUM", "AVG LOW", "AVG VERY LOW", "Quantitative Value", "Risk Level")
	        $results."Technical Review" = $(($VeryHighAVG * $VeryHighweight) + ($HighAVG * $Highweight) + ($MediumAVG * $Mediumweight) + ($LowAVG * $lowweight) + ($VeryLowAVG * $verylowweight))
	        $results."Overall Documentation" = $docrisk
	        $results."Knowledge of the System" = $sysrisk
	        $results."VERY HIGH" = $VeryHighCount
	        $results."HIGH" = $HighCount
	        $results."MEDIUM" = $MediumCount
	        $results."LOW" = $LowCount
	        $results."VERY LOW" = $VeryLowCount
	        $results."AVG VERY HIGH" = $VeryHighAVG
	        $results."AVG HIGH" = $HighAVG
	        $results."AVG MEDIUM" = $MediumAVG
	        $results."AVG LOW" = $LowCount
	        $results."AVG VERY LOW" = $VeryLowAVG
	        $results."Quantitative Value" = $(($results."Technical Review" * $tech) + ($results."Overall Documentation" * $docu) + ($results."Knowledge of the System" * $sysKno))
	        $results."Risk Level" = $(if($results."Quantitative Value" -gt 67){"HIGH"}elseif($results."Quantitative Value" -lt 68 -and $results."Quantitative Value" -gt 32){"MEDIUM"}else{"LOW"})
	    }
	    END {
	        Export-XLSX -Path "$($output)\$($name)_Risk_Algorithm_Report.xlsx" -InputObject $results
	        Export-XLSX -Path "$($output)\$($name)_Risk_Report.xlsx" -InputObject $riskelements
	    }
	}
	
	#Invoke-RiskAlgorithm -risk "C:\Users\josh\Google Drive\Work\modules\custom\PSIASTAND\tests\data\Mock_APP\APP_OWNER_Risk.xlsx" -map "C:\Users\josh\Google Drive\Work\modules\custom\PSIASTAND\tests\data\Risk_Mapping\Sample_Risk_Map.xlsx" -docrisk 45 -sysrisk 45 -output "C:\Users\josh\Google Drive\Work\modules\custom\PSIASTAND\tests\data" -name "APP_OWNER"
	
}
#endregion

#region Call-New-CVSS3_ps1
function Call-New-CVSS3_ps1
{
	function New-CVSS3 () {
	<#
	.SYNOPSIS
	    Creates a CVSS version 3 object containing all the algorithms and function required to automate analysis
	
	.PARAMETER none
	
	.EXAMPLE
	    $cvss = init-CVSS3()
	
	.LINK
	
	.VERSION
	    1.0.0 (04.12.2016)
	        -Intial Release
	#>
	
	# Constants used in the formula
	
	$CVSS = @{}
	
	$CVSS.CVSSVersionIdentifier = "CVSS:3.0"
	$CVSS.exploitabilityCoefficient = 8.22
	$CVSS.scopeCoefficient = 1.08
	
	# A regular expression to validate that a CVSS 3.0 vector string is well formed. It checks metrics and metric
	# values. It does not check that a metric is specified more than once and it does not check that all base
	# metrics are present. These checks need to be performed separately.
	
	$CVSS.vectorStringRegex_30 = New-Object System.Text.RegularExpressions.Regex '^CVSS:3\.0\/((AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])\/)*(AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])$', 'IgnoreCase'
	
	# Associative arrays mapping each metric value to the constant defined in the CVSS scoring formula in the CVSS v3.0
	# specification.
	
	$CVSS.Weight = @{
	  AV =   @{ N = 0.85;  A = 0.62;  L = 0.55;  P = 0.2;};
	  AC =   @{ H = 0.44;  L = 0.77;};
	  PR =   @{ U =       @{N = 0.85;  L = 0.62;  H = 0.27;};         # These values are used if Scope is Unchanged
	            C =       @{N = 0.85;  L = 0.68;  H = 0.5;};           # These values are used if Scope is Changed
	         };        
	  UI =   @{ N = 0.85;  R = 0.62;};
	  S =    @{ U = 6.42;  C = 7.52;};                             # Note: not defined as constants in specification
	  CIA =  @{ N = 0;     L = 0.22;  H = 0.56;};                   # C, I and A have the same weights
	
	  E =    @{ X = 1;     U = 0.91;  P = 0.94;  F = 0.97;  H = 1;};
	  RL =   @{ X = 1;     O = 0.95;  T = 0.96;  W = 0.97;  U = 1;};
	  RC =   @{ X = 1;     U = 0.92;  R = 0.96;  C = 1;};
	
	  CIAR = @{ X = 1;     L = 0.5;   M = 1;     H = 1.5;};           # CR, IR and AR have the same weights
	}
	
	# Severity rating bands, as defined in the CVSS v3.0 specification.
	
	$CVSS.severityRatings  = @( 
	                          @{ name = "None";     bottom = 0.0; top =  0.0;},
	                          @{ name = "Low";      bottom = 0.1; top =  3.9;},
	                          @{ name = "Medium";   bottom = 4.0; top =  6.9;},
	                          @{ name = "High";     bottom = 7.0; top =  8.9;},
	                          @{ name = "Critical"; bottom = 9.0; top = 10.0;} 
	                         )
	
	<# ** CVSS.severityRating **
	 *
	 * Given a CVSS score, returns the name of the severity rating as defined in the CVSS standard.
	 * The input needs to be a number between 0.0 to 10.0, to one decimal place of precision.
	 *
	 * The following error values may be returned instead of a severity rating name:
	 *   NaN (JavaScript "Not a Number") - if the input is not a number.
	 *   undefined - if the input is a number that is not within the range of any defined severity rating.
	#>
	
	Add-Member -InputObject $CVSS -MemberType ScriptMethod -name 'severityRating' -value {
	    Param($score)
	    
	    $severityRatingLength = $this.severityRatings.length
	
	    $validatedScore = [convert]::ToDecimal($score)
	
	    #if (isNaN($validatedScore)) {
	    #    return $validatedScore
	    #}
	
	    for ($i = 0; $i -lt $severityRatingLength; $i++) {
	        if ($score -ge $this.severityRatings[$i].bottom -and $score -le $this.severityRatings[$i].top) {
	        return $this.severityRatings[$i].name
	        }
	    }
	
	    return $null
	}
	
	<# ** CVSS.roundUp1 **
	 *
	 * Rounds up the number passed as a parameter to 1 decimal place and returns the result.
	 *
	 * Standard JavaScript errors thrown when arithmetic operations are performed on non-numbers will be returned if the
	 * given input is not a number.
	#>
	
	
	Add-Member -InputObject $CVSS ScriptMethod roundUp1 {
	    Param($d)
	    return [math]::ceiling($d * 10) / 10
	}
	
	<# ** CVSS.calculateCVSSFromMetrics **
	 *
	 * Takes Base, Temporal and Environmental metric values as individual parameters. Their values are in the short format
	 * defined in the CVSS v3.0 standard definition of the Vector String. For example, the AttackComplexity parameter
	 * should be either "H" or "L".
	 *
	 * Returns Base, Temporal and Environmental scores, severity ratings, and an overall Vector String. All Base metrics
	 * are required to generate this output. All Temporal and Environmental metric values are optional. Any that are not
	 * passed default to "X" ("Not Defined").
	 *
	 * The output is an object which always has a property named "success".
	 *
	 * If no errors are encountered, success is Boolean "true", and the following other properties are defined containing
	 * scores, severities and a vector string:
	 *   baseMetricScore, baseSeverity,
	 *   temporalMetricScore, temporalSeverity,
	 *   environmentalMetricScore, environmentalSeverity,
	 *   vectorString
	 *
	 * If errors are encountered, success is Boolean "false", and the following other properties are defined:
	 *   errorType - a string indicating the error. Either:
	 *                 "MissingBaseMetric", if at least one Base metric has not been defined; or
	 *                 "UnknownMetricValue", if at least one metric value is invalid.
	 *   errorMetrics - an array of strings representing the metrics at fault. The strings are abbreviated versions of the
	 *                  metrics, as defined in the CVSS v3.0 standard definition of the Vector String.
	 *
	#>
	
	Add-Member -InputObject $CVSS ScriptMethod calculateCVSSFromMetrics {
	    Param(
	        $AttackVector,
	        $AttackComplexity,
	        $PrivilegesRequired,
	        $UserInteraction,
	        $Scope,
	        $Confidentiality,
	        $Integrity,
	        $Availability,
	        $ExploitCodeMaturity,
	        $RemediationLevel,
	        $ReportConfidence,
	        $ConfidentialityRequirement,
	        $IntegrityRequirement,
	        $AvailabilityRequirement,
	        $ModifiedAttackVector,
	        $ModifiedAttackComplexity,
	        $ModifiedPrivilegesRequired,
	        $ModifiedUserInteraction,
	        $ModifiedScope,
	        $ModifiedConfidentiality,
	        $ModifiedIntegrity,
	        $ModifiedAvailability
	    )
	   
	  # If input validation fails, this array is populated with strings indicating which metrics failed validation.
	  [System.Collections.ArrayList]$badMetrics = @()
	
	  # ENSURE ALL BASE METRICS ARE DEFINED
	  #
	  # We need values for all Base Score metrics to calculate scores.
	  # If any Base Score parameters are undefined, create an array of missing metrics and return it with an error.
	
	  if ($AttackVector -eq $null -or $AttackVector -eq "") {$badMetrics.Add("AV")}
	  if ($AttackComplexity -eq $null -or $AttackComplexity -eq "") {$badMetrics.Add("AC")}
	  if ($PrivilegesRequired -eq $null -or $PrivilegesRequired -eq "") {$badMetrics.Add("PR")}
	  if ($UserInteraction -eq $null -or $UserInteraction -eq "") {$badMetrics.Add("UI")}
	  if ($Scope -eq $null -or $Scope -eq "") {$badMetrics.Add("S")}
	  if ($Confidentiality -eq $null -or $Confidentiality -eq "") {$badMetrics.Add("C")}
	  if ($Integrity -eq $null -or $Integrity -eq "") {$badMetrics.Add("I")}
	  if ($Availability -eq $null -or $Availability -eq "") {$badMetrics.Add("A")}
	  
	  if ($badMetrics.Count -gt 0) {
	    return @{ Success = $false; errorType = "MissingBaseMetric"; errorMetrics = $badMetrics; }
	  }
	  
	  # STORE THE METRIC VALUES THAT WERE PASSED AS PARAMETERS
	  #
	  # Temporal and Environmental metrics are optional, so set them to "X" ("Not Defined") if no value was passed.
	
	  $AV = $AttackVector
	  $AC = $AttackComplexity
	  $PR = $PrivilegesRequired
	  $UI = $UserInteraction
	  $S  = $Scope
	  $C  = $Confidentiality
	  $I  = $Integrity
	  $A  = $Availability
	
	  $E =   if ($ExploitCodeMaturity){$ExploitCodeMaturity}else{"X"}
	  $RL =  if ($RemediationLevel){$RemediationLevel}else{"X"}
	  $RC =  if ($ReportConfidence){$ReportConfidence}else{"X"}
	
	  $CR =  if ($ConfidentialityRequirement){$ConfidentialityRequirement}else{"X"}
	  $IR =  if ($IntegrityRequirement){$IntegrityRequirement}else{"X"}
	  $AR =  if ($AvailabilityRequirement) {$AvailabilityRequirement}else{"X"}
	  $MAV = if ($ModifiedAttackVector){$ModifiedAttackVector}else{"X"}
	  $MAC = if ($ModifiedAttackComplexity){$ModifiedAttackComplexity}else{"X"}
	  $MPR = if ($ModifiedPrivilegesRequired){$ModifiedPrivilegesRequired}else{"X"}
	  $MUI = if ($ModifiedUserInteraction){$ModifiedUserInteraction}else{"X"}
	  $MS =  if ($ModifiedScope){$ModifiedScope}else{"X"}
	  $MC =  if ($ModifiedConfidentiality){$ModifiedConfidentiality}else{"X"}
	  $MI =  if ($ModifiedIntegrity){$ModifiedIntegrity}else{"X"}
	  $MA =  if ($ModifiedAvailability){$ModifiedAvailability}else{"X"}
	
	  # CHECK VALIDITY OF METRIC VALUES
	  #
	  # Use the Weight object to ensure that, for every metric, the metric value passed is valid.
	  # If any invalid values are found, create an array of their metrics and return it with an error.
	  #
	  # The Privileges Required (PR) weight depends on Scope, but when checking the validity of PR we must not assume
	  # that the given value for Scope is valid. We therefore always look at the weights for Unchanged Scope when
	  # performing this check. The same applies for validation of Modified Privileges Required (MPR).
	  #
	  # The Weights object does not contain "X" ("Not Defined") values for Environmental metrics because we replace them
	  # with their Base metric equivalents later in the function. For example, an MAV of "X" will be replaced with the
	  # value given for AV. We therefore need to explicitly allow a value of "X" for Environmental metrics.
	
	  if (!$this.Weight.AV.ContainsKey($AV))   { $badMetrics.Add("AV") }
	  if (!$this.Weight.AC.ContainsKey($AC))   { $badMetrics.Add("AC") }
	  if (!$this.Weight.PR.U.ContainsKey($PR)) { $badMetrics.Add("PR") }
	  if (!$this.Weight.UI.ContainsKey($UI))   { $badMetrics.Add("UI") }
	  if (!$this.Weight.S.ContainsKey($S))     { $badMetrics.Add("S") }
	  if (!$this.Weight.CIA.ContainsKey($C))   { $badMetrics.Add("C") }
	  if (!$this.Weight.CIA.ContainsKey($I))   { $badMetrics.Add("I") }
	  if (!$this.Weight.CIA.ContainsKey($A))   { $badMetrics.Add("A") }
	
	  if (!$this.Weight.E.ContainsKey($E))     { $badMetrics.Add("E") }
	  if (!$this.Weight.RL.ContainsKey($RL))   { $badMetrics.Add("RL") }
	  if (!$this.Weight.RC.ContainsKey($RC))   { $badMetrics.Add("RC") }
	
	  if (!($CR  -eq "X" -or $this.Weight.CIAR.ContainsKey($CR)))  { $badMetrics.Add("CR") }
	  if (!($IR  -eq "X" -or $this.Weight.CIAR.ContainsKey($IR)))  { $badMetrics.Add("IR") }
	  if (!($AR  -eq "X" -or $this.Weight.CIAR.ContainsKey($AR)))  { $badMetrics.Add("AR") }
	  if (!($MAV -eq "X" -or $this.Weight.AV.ContainsKey($MAV)))   { $badMetrics.Add("MAV") }
	  if (!($MAC -eq "X" -or $this.Weight.AC.ContainsKey($MAC)))   { $badMetrics.Add("MAC") }
	  if (!($MPR -eq "X" -or $this.Weight.PR.U.ContainsKey($MPR))) { $badMetrics.Add("MPR") }
	  if (!($MUI -eq "X" -or $this.Weight.UI.ContainsKey($MUI)))   { $badMetrics.Add("MUI") }
	  if (!($MS  -eq "X" -or $this.Weight.S.ContainsKey($MS)))     { $badMetrics.Add("MS") }
	  if (!($MC  -eq "X" -or $this.Weight.CIA.ContainsKey($MC)))   { $badMetrics.Add("MC") }
	  if (!($MI  -eq "X" -or $this.Weight.CIA.ContainsKey($MI)))   { $badMetrics.Add("MI") }
	  if (!($MA  -eq "X" -or $this.Weight.CIA.ContainsKey($MA)))   { $badMetrics.Add("MA") }
	  
	  if ($badMetrics.Count > 0) {
	    return @{ Success = $false; errorType = "UnknownMetricValue"; errorMtrics = $badMetrics}
	  }
	
	  # GATHER WEIGHTS FOR ALL METRICS
	
	  $metricWeightAV  = $this.Weight.AV[$AV]
	  $metricWeightAC  = $this.Weight.AC[$AC]
	  $metricWeightPR  = $this.Weight.PR[$S][$PR]  # PR depends on the value of Scope (S).
	  $metricWeightUI  = $this.Weight.UI[$UI]
	  $metricWeightS   = $this.Weight.S[$S]
	  $metricWeightC   = $this.Weight.CIA[$C]
	  $metricWeightI   = $this.Weight.CIA[$I]
	  $metricWeightA   = $this.Weight.CIA[$A]
	
	  $metricWeightE   = $this.Weight.E[$E]
	  $metricWeightRL  = $this.Weight.RL[$RL]
	  $metricWeightRC  = $this.Weight.RC[$RC]
	
	  # For metrics that are modified versions of Base Score metrics, e.g. Modified Attack Vector, use the value of
	  # the Base Score metric if the modified version value is "X" ("Not Defined").
	  $metricWeightCR  = $this.Weight.CIAR[$CR]
	  $metricWeightIR  = $this.Weight.CIAR[$IR]
	  $metricWeightAR  = $this.Weight.CIAR[$AR]
	  $metricWeightMAV = $this.Weight.AV[$(if ($MAV -ne "X") {$MAV} else {$AV})]
	  $metricWeightMAC = $this.Weight.AC[$(if ($MAC -ne "X") {$MAC} else {$AC})]
	  $metricWeightMPR = $this.Weight.PR[$(if ($MS  -ne "X") {$MS} else {$S})][$(if ($MPR -ne "X") {$MPR} else {$PR})]  # Depends on MS.
	  $metricWeightMUI = $this.Weight.UI[$(if ($MUI -ne "X") {$MUI} else {$UI})]
	  $metricWeightMS  = $this.Weight.S[$(if ($MS -ne "X") {$MS} else {$S})]
	  $metricWeightMC  = $this.Weight.CIA[$(if ($MC  -ne "X") {$MC} else {$C})]
	  $metricWeightMI  = $this.Weight.CIA[$(if ($MI  -ne "X") {$MI} else {$I})]
	  $metricWeightMA  = $this.Weight.CIA[$(if ($MA  -ne "X") {$MA} else {$A})]
	
	  
	  # CALCULATE THE CVSS BASE SCORE
	
	  $baseScore
	  $impactSubScore
	  $exploitabalitySubScore = $this.exploitabilityCoefficient * $metricWeightAV * $metricWeightAC * $metricWeightPR * $metricWeightUI
	  $impactSubScoreMultiplier = (1 - ((1 - $metricWeightC) * (1 - $metricWeightI) * (1 - $metricWeightA)))
	
	  if ($S -eq 'U') {
	    $impactSubScore = $metricWeightS * $impactSubScoreMultiplier
	  } else {
	    $impactSubScore = $metricWeightS * ($impactSubScoreMultiplier - 0.029) - 3.25 * [math]::Pow($impactSubScoreMultiplier - 0.02, 15)
	  }
	
	  if ($impactSubScore -le 0) {
	    $baseScore = 0
	  } else {
	    if ($S -eq 'U') {
	      $baseScore = $this.roundUp1([math]::Min(($exploitabalitySubScore + $impactSubScore), 10))
	    } else {
	      $baseScore = $this.roundUp1([math]::Min(($exploitabalitySubScore + $impactSubScore) * $this.scopeCoefficient, 10))
	    }
	  }
	
	  # CALCULATE THE CVSS TEMPORAL SCORE
	  
	  $temporalScore = $this.roundUp1($baseScore * $metricWeightE * $metricWeightRL * $metricWeightRC)
	  
	  # CALCULATE THE CVSS ENVIRONMENTAL SCORE
	  #
	  # - envExploitabalitySubScore recalculates the Base Score Exploitability sub-score using any modified values from the
	  #   Environmental metrics group in place of the values specified in the Base Score, if any have been defined.
	  # - envAdjustedImpactSubScore recalculates the Base Score Impact sub-score using any modified values from the
	  #   Environmental metrics group in place of the values specified in the Base Score, and any additional weightings
	  #   given in the Environmental metrics group.
	
	  $envScore
	  $envModifiedImpactSubScore
	  $envModifiedExploitabalitySubScore = $this.exploitabilityCoefficient * $metricWeightMAV * $metricWeightMAC * $metricWeightMPR * $metricWeightMUI
	
	  $envImpactSubScoreMultiplier = [math]::Min(1 - (
	                                                 (1 - $metricWeightMC * $metricWeightCR) *
	                                                 (1 - $metricWeightMI * $metricWeightIR) *
	                                                 (1 - $metricWeightMA * $metricWeightAR)), 0.915)
	
	  if ($MS -eq "U" -or ($MS -eq "X" -and $S -eq "U")) {
	    $envModifiedImpactSubScore = $metricWeightMS * $envImpactSubScoreMultiplier
	    $envScore = $this.roundUp1($this.roundUp1([math]::Min($envModifiedImpactSubScore + $envModifiedExploitabalitySubScore), 10) * $metricWeightE * $metricWeightRL * $metricWeightRC)
	    } else {
	    $envModifiedImpactSubScore = $metricWeightMS * ($envImpactSubScoreMultiplier - 0.029) - 3.25 * [math]::Pow($envImpactSubScoreMultiplier - 0.02, 15)
	    $envScore = $this.roundUp1($this.roundUp1([math]::Min($this.scopeCoefficient * ($envModifiedImpactSubScore + $envModifiedExploitabalitySubScore), 10)) * $metricWeightE * $metricWeightRL * $metricWeightRC)
	  }
	
	  if ($envModifiedImpactSubScore -le 0) {
	    $envScore = 0;
	  }
	  
	  # CONSTRUCT THE VECTOR STRING
	  
	  $vectorString = $this.CVSSVersionIdentifier +
	    "/AV:" + $AV +
	    "/AC:" + $AC +
	    "/PR:" + $PR +
	    "/UI:" + $UI +
	    "/S:"  + $S +
	    "/C:"  + $C +
	    "/I:"  + $I +
	    "/A:"  + $A
	
	  if ($E  -ne "X")  {$vectorString = $vectorString + "/E:" + $E}
	  if ($RL -ne "X")  {$vectorString = $vectorString + "/RL:" + $RL}
	  if ($RC -ne "X")  {$vectorString = $vectorString + "/RC:" + $RC}
	
	  if ($CR  -ne "X") {$vectorString = $vectorString + "/CR:" + $CR}
	  if ($IR  -ne "X") {$vectorString = $vectorString + "/IR:"  + $IR}
	  if ($AR  -ne "X") {$vectorString = $vectorString + "/AR:"  + $AR}
	  if ($MAV -ne "X") {$vectorString = $vectorString + "/MAV:" + $MAV}
	  if ($MAC -ne "X") {$vectorString = $vectorString + "/MAC:" + $MAC}
	  if ($MPR -ne "X") {$vectorString = $vectorString + "/MPR:" + $MPR}
	  if ($MUI -ne "X") {$vectorString = $vectorString + "/MUI:" + $MUI}
	  if ($MS  -ne "X") {$vectorString = $vectorString + "/MS:"  + $MS}
	  if ($MC  -ne "X") {$vectorString = $vectorString + "/MC:"  + $MC}
	  if ($MI  -ne "X") {$vectorString = $vectorString + "/MI:"  + $MI}
	  if ($MA  -ne "X") {$vectorString = $vectorString + "/MA:"  + $MA}
	
	
	  # Return an object containing the scores for all three metric groups, and an overall vector string.
	  
	  return @{
	    Success = $true;
	    baseMetricScore = $(([math]::Round($baseScore, 1), [system.midpointrounding]::AwayFromZero)[0].ToString());
	    baseSeverity = $this.severityRating( $(([math]::Round($baseScore, 1), [System.MidpointRounding]::AwayFromZero)[0].ToString()));
	
	    temporalMetricScore = $(([math]::Round($temporalScore, 1), [system.midpointrounding]::AwayFromZero)[0].ToString());
	    temporalSeverity = $this.severityRating( $(([math]::Round($temporalScore, 1), [System.MidpointRounding]::AwayFromZero)[0].ToString()));
	
	    environmentalMetricScore = $(([math]::Round($envScore, 1), [system.midpointrounding]::AwayFromZero)[0].ToString());
	    environmentalSeverity = $this.severityRating( $(([math]::Round($envScore, 1), [System.MidpointRounding]::AwayFromZero)[0].ToString()));
	
	    vectorString = $vectorString
	  }
	
	}
	
	<# ** CVSS.calculateCVSSFromVector **
	 *
	 * Takes Base, Temporal and Environmental metric values as a single string in the Vector String format defined
	 * in the CVSS v3.0 standard definition of the Vector String.
	 *
	 * Returns Base, Temporal and Environmental scores, severity ratings, and an overall Vector String. All Base metrics
	 * are required to generate this output. All Temporal and Environmental metric values are optional. Any that are not
	 * passed default to "X" ("Not Defined").
	 *
	 * See the comment for the CVSS.calculateCVSSFromMetrics function for details on the function output. In addition to
	 * the error conditions listed for that function, this function can also return:
	 *   "MalformedVectorString", if the Vector String passed is does not conform to the format in the standard; or
	 *   "MultipleDefinitionsOfMetric", if the Vector String is well formed but defines the same metric (or metrics),
	 *                                  more than once.
	#>
	
	Add-Member -InputObject $CVSS -MemberType ScriptMethod -name 'calculateCVSSFromVector' -value {
	    Param($vectorString)
	    $metricValues = @{
	    AV = $null; AC =  $null; PR =  $null; UI =  $null; S =  $null;
	    C =   $null; I =   $null; A =   $null;
	    E =   $null; RL =  $null; RC =  $null;
	    CR =  $null; IR =  $null; AR =  $null;
	    MAV = $null; MAC = $null; MPR = $null; MUI = $null; MS = $null;
	    MC =  $null; MI =  $null; MA =  $null
	  }
	
	  # If input validation fails, this array is populated with strings indicating which metrics failed validation.
	  [System.Collections.ArrayList]$badMetrics = @()
	
	  if (!($this.vectorStringRegex_30.IsMatch($vectorString))) {
	    return @{ Success = $false; errorType = "MalformedVectorString"}
	  }
	
	  # Add 1 to the length of the CVSS Identifier to include the first slash after the Identifer
	  # So that when the split happens a $null value is not created 
	
	  $metricNameValue = $vectorString.Substring($this.CVSSVersionIdentifier.length + 1).split("/") #-join ",").Trim(",").split(",")
	
	  foreach($i in $metricNameValue) {
	    if ($metricNameValue.Contains($i)) { # Validating Input
	
	      $singleMetric = $i.split(":")
	      
	      if ($metricValues[$singleMetric[0]] -eq $null) {
	        $metricValues[$singleMetric[0]] = $singleMetric[1]
	      } else {
	        $badMetrics.Add($singleMetric[0]);
	      }
	    }
	  }
	
	  if ($badMetrics.Count -gt 0) {
	    return @{ Success = $false; errorType = "MultipleDefinitionsOfMetric"; errorMetrics = $badMetrics }
	  }
	  
	  return $this.calculateCVSSFromMetrics(
	    $metricValues.AV,  $metricValues.AC,  $metricValues.PR,  $metricValues.UI,  $metricValues.S,
	    $metricValues.C,   $metricValues.I,   $metricValues.A,
	    $metricValues.E,   $metricValues.RL,  $metricValues.RC,
	    $metricValues.CR,  $metricValues.IR,  $metricValues.AR,
	    $metricValues.MAV, $metricValues.MAC, $metricValues.MPR, $metricValues.MUI, $metricValues.MS,
	    $metricValues.MC,  $metricValues.MI,  $metricValues.MA)
	
	}
	
	#$object = New-Object -TypeName PSObject -Property $CVSS
	
	#return $object
	return $CVSS
	}
	
}
#endregion

#region Call-Invoke-SqliteBulkCopy_ps1
function Call-Invoke-SqliteBulkCopy_ps1
{
	function Invoke-SQLiteBulkCopy {
	<#
	.SYNOPSIS
	    Use a SQLite transaction to quickly insert data
	
	.DESCRIPTION
	    Use a SQLite transaction to quickly insert data.  If we run into any errors, we roll back the transaction.
	
	    The data source is not limited to SQL Server; any data source can be used, as long as the data can be loaded to a DataTable instance or read with a IDataReader instance.
	
	.PARAMETER DataSource
	    Path to one ore more SQLite data sources to query
	
	.PARAMETER Force
	    If specified, skip the confirm prompt
	
	.PARAMETER  NotifyAfter
		The number of rows to fire the notification event after transferring.  0 means don't notify.  Notifications hit the verbose stream (use -verbose to see them)
	
	.PARAMETER QueryTimeout
	    Specifies the number of seconds before the queries time out.
	
	.PARAMETER SQLiteConnection
	    An existing SQLiteConnection to use.  We do not close this connection upon completed query.
	
	.PARAMETER ConflictClause
	    The conflict clause to use in case a conflict occurs during insert. Valid values: Rollback, Abort, Fail, Ignore, Replace
	
	    See https://www.sqlite.org/lang_conflict.html for more details
	
	.EXAMPLE
	    #
	    #Create a table
	        Invoke-SqliteQuery -DataSource "C:\Names.SQLite" -Query "CREATE TABLE NAMES (
	            fullname VARCHAR(20) PRIMARY KEY,
	            surname TEXT,
	            givenname TEXT,
	            BirthDate DATETIME)"
	
	    #Build up some fake data to bulk insert, convert it to a datatable
	        $DataTable = 1..10000 | %{
	            [pscustomobject]@{
	                fullname = "Name $_"
	                surname = "Name"
	                givenname = "$_"
	                BirthDate = (Get-Date).Adddays(-$_)
	            }
	        } | Out-DataTable
	
	    #Copy the data in within a single transaction (SQLite is faster this way)
	        Invoke-SQLiteBulkCopy -DataTable $DataTable -DataSource $Database -Table Names -NotifyAfter 1000 -ConflictClause Ignore -Verbose
	
	.INPUTS
	    System.Data.DataTable
	
	.OUTPUTS
	    None
	        Produces no output
	
	.NOTES
	    This function borrows from:
	        Chad Miller's Write-Datatable
	        jbs534's Invoke-SQLBulkCopy
	        Mike Shepard's Invoke-BulkCopy from SQLPSX
	
	.LINK
	    https://github.com/RamblingCookieMonster/Invoke-SQLiteQuery
	
	.LINK
	    New-SQLiteConnection
	
	.LINK
	    Invoke-SQLiteBulkCopy
	
	.LINK
	    Out-DataTable
	
	.FUNCTIONALITY
	    SQL
	#>
	    [cmdletBinding( DefaultParameterSetName = 'Datasource',
	                    SupportsShouldProcess = $true,
	                    ConfirmImpact = 'High' )]
	    param(
	        [parameter( Position = 0,
	                    Mandatory = $true,
	                    ValueFromPipeline = $false,
	                    ValueFromPipelineByPropertyName= $false)]
	        [System.Data.DataTable]
	        $DataTable,
	
	        [Parameter( ParameterSetName='Datasource',
	                    Position=1,
	                    Mandatory=$true,
	                    ValueFromRemainingArguments=$false,
	                    HelpMessage='SQLite Data Source required...' )]
	        [Alias('Path','File','FullName','Database')]
	        [validatescript({
	            #This should match memory, or the parent path should exist
	            if ( $_ -match ":MEMORY:" -or (Test-Path $_) ) {
	                $True
	            }
	            else {
	                Throw "Invalid datasource '$_'.`nThis must match :MEMORY:, or must exist"
	            }
	        })]
	        [string]
	        $DataSource,
	
	        [Parameter( ParameterSetName = 'Connection',
	                    Position=1,
	                    Mandatory=$true,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [Alias( 'Connection', 'Conn' )]
	        [System.Data.SQLite.SQLiteConnection]
	        $SQLiteConnection,
	
	        [parameter( Position=2,
	                    Mandatory = $true)]
	        [string]
	        $Table,
	
	        [Parameter( Position=3,
	                     Mandatory=$false,
	                     ValueFromPipeline=$false,
	                     ValueFromPipelineByPropertyName=$false,
	                     ValueFromRemainingArguments=$false)]
	        [ValidateSet("Rollback","Abort","Fail","Ignore","Replace")]
	        [string]
	        $ConflictClause,
	
	        [int]
	        $NotifyAfter = 0,
	
	        [switch]
	        $Force,
	
	        [Int32]
	        $QueryTimeout = 600
	
	    )
	
	    Write-Verbose "Running Invoke-SQLiteBulkCopy with ParameterSet '$($PSCmdlet.ParameterSetName)'."
	
	    Function CleanUp
	    {
	        [cmdletbinding()]
	        param($conn, $com, $BoundParams)
	        #Only dispose of the connection if we created it
	        if($BoundParams.Keys -notcontains 'SQLiteConnection')
	        {
	            $conn.Close()
	            $conn.Dispose()
	            Write-Verbose "Closed connection"
	        }
	        $com.Dispose()
	    }
	
	    function Get-ParameterName
	    {
	        [CmdletBinding()]
	        Param(
	            [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
	            [string[]]$InputObject,
	
	            [Parameter(ValueFromPipelineByPropertyName = $true)]
	            [string]$Regex = '(\W+)',
	
	            [Parameter(ValueFromPipelineByPropertyName = $true)]
	            [string]$Separator = '_'
	        )
	
	        Process{
	            $InputObject | ForEach-Object {
	                if($_ -match $Regex){
	                    $Groups = @($_ -split $Regex | Where-Object {$_})
	                    for($i = 0; $i -lt $Groups.Count; $i++){
	                        if($Groups[$i] -match $Regex){
	                            $Groups[$i] = ($Groups[$i].ToCharArray() | ForEach-Object {[string][int]$_}) -join $Separator
	                        }
	                    }
	                    $Groups -join $Separator
	                } else {
	                    $_
	                }
	            }
	        }
	    }
	
	    function New-SqliteBulkQuery {
	        [CmdletBinding()]
	        Param(
	            [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true)]
	            [string]$Table,
	
	            [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true)]
	            [string[]]$Columns,
	
	            [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true)]
	            [string[]]$Parameters,
	
	            [Parameter(ValueFromPipelineByPropertyName = $true)]
	            [string]$ConflictClause = ''
	        )
	
	        Begin{
	            $EscapeSingleQuote = "'","''"
	            $Delimeter = ", "
	            $QueryTemplate = "INSERT{0} INTO {1} ({2}) VALUES ({3})"
	        }
	
	        Process{
	            $fmtConflictClause = if($ConflictClause){" OR $ConflictClause"}
	            $fmtTable = "'{0}'" -f ($Table -replace $EscapeSingleQuote)
	            $fmtColumns = ($Columns | ForEach-Object { "'{0}'" -f ($_ -replace $EscapeSingleQuote) }) -join $Delimeter
	            $fmtParameters = ($Parameters | ForEach-Object { "@$_"}) -join $Delimeter
	
	            $QueryTemplate -f $fmtConflictClause, $fmtTable, $fmtColumns, $fmtParameters
	        }
	    }
	
	    #Connections
	        if($PSBoundParameters.Keys -notcontains "SQLiteConnection")
	        {
	            $ConnectionString = "Data Source={0}" -f $DataSource
	            $SQLiteConnection = New-Object System.Data.SQLite.SQLiteConnection -ArgumentList $ConnectionString
	            $SQLiteConnection.ParseViaFramework = $true #Allow UNC paths, thanks to Ray Alex!
	        }
	
	        Write-Debug "ConnectionString $($SQLiteConnection.ConnectionString)"
	        Try
	        {
	            if($SQLiteConnection.State -notlike "Open")
	            {
	                $SQLiteConnection.Open()
	            }
	            $Command = $SQLiteConnection.CreateCommand()
	            $CommandTimeout = $QueryTimeout
	            $Transaction = $SQLiteConnection.BeginTransaction()
	        }
	        Catch
	        {
	            Throw $_
	        }
	
	    write-verbose "DATATABLE IS $($DataTable.gettype().fullname) with value $($Datatable | out-string)"
	    $RowCount = $Datatable.Rows.Count
	    Write-Verbose "Processing datatable with $RowCount rows"
	
	    if ($Force -or $PSCmdlet.ShouldProcess("$($DataTable.Rows.Count) rows, with BoundParameters $($PSBoundParameters | Out-String)", "SQL Bulk Copy"))
	    {
	        #Get column info...
	            $Columns = $DataTable.Columns | Select -ExpandProperty ColumnName
	            $ColumnTypeHash = @{}
	            $ColumnToParamHash = @{}
	            $Index = 0
	            foreach($Col in $DataTable.Columns)
	            {
	                $Type = Switch -regex ($Col.DataType.FullName)
	                {
	                    # I figure we create a hashtable, can act upon expected data when doing insert
	                    # Might be a better way to handle this...
	                    '^(|\ASystem\.)Boolean$' {"BOOLEAN"} #I know they're fake...
	                    '^(|\ASystem\.)Byte\[\]' {"BLOB"}
	                    '^(|\ASystem\.)Byte$'  {"BLOB"}
	                    '^(|\ASystem\.)Datetime$'  {"DATETIME"}
	                    '^(|\ASystem\.)Decimal$' {"REAL"}
	                    '^(|\ASystem\.)Double$' {"REAL"}
	                    '^(|\ASystem\.)Guid$' {"TEXT"}
	                    '^(|\ASystem\.)Int16$'  {"INTEGER"}
	                    '^(|\ASystem\.)Int32$'  {"INTEGER"}
	                    '^(|\ASystem\.)Int64$' {"INTEGER"}
	                    '^(|\ASystem\.)UInt16$'  {"INTEGER"}
	                    '^(|\ASystem\.)UInt32$'  {"INTEGER"}
	                    '^(|\ASystem\.)UInt64$' {"INTEGER"}
	                    '^(|\ASystem\.)Single$' {"REAL"}
	                    '^(|\ASystem\.)String$' {"TEXT"}
	                    Default {"BLOB"} #Let SQLite handle the rest...
	                }
	
	                #We ref columns by their index, so add that...
	                $ColumnTypeHash.Add($Index,$Type)
	
	                # Parameter names can only be alphanumeric: https://www.sqlite.org/c3ref/bind_blob.html
	                # So we have to replace all non-alphanumeric chars in column name to use it as parameter later.
	                # This builds hashtable to correlate column name with parameter name.
	                $ColumnToParamHash.Add($Col.ColumnName, (Get-ParameterName $Col.ColumnName))
	
	                $Index++
	            }
	
	        #Build up the query
	            if ($PSBoundParameters.ContainsKey('ConflictClause'))
	            {
	                $Command.CommandText = New-SqliteBulkQuery -Table $Table -Columns $ColumnToParamHash.Keys -Parameters $ColumnToParamHash.Values -ConflictClause $ConflictClause
	            }
	            else
	            {
	                $Command.CommandText = New-SqliteBulkQuery -Table $Table -Columns $ColumnToParamHash.Keys -Parameters $ColumnToParamHash.Values
	            }
	
	            foreach ($Column in $Columns)
	            {
	                $param = New-Object System.Data.SQLite.SqLiteParameter $ColumnToParamHash[$Column]
	                [void]$Command.Parameters.Add($param)
	            }
	
	            for ($RowNumber = 0; $RowNumber -lt $RowCount; $RowNumber++)
	            {
	                $row = $Datatable.Rows[$RowNumber]
	                for($col = 0; $col -lt $Columns.count; $col++)
	                {
	                    # Depending on the type of thid column, quote it
	                    # For dates, convert it to a string SQLite will recognize
	                    switch ($ColumnTypeHash[$col])
	                    {
	                        "BOOLEAN" {
	                            $Command.Parameters[$ColumnToParamHash[$Columns[$col]]].Value = [int][boolean]$row[$col]
	                        }
	                        "DATETIME" {
	                            Try
	                            {
	                                $Command.Parameters[$ColumnToParamHash[$Columns[$col]]].Value = $row[$col].ToString("yyyy-MM-dd HH:mm:ss")
	                            }
	                            Catch
	                            {
	                                $Command.Parameters[$ColumnToParamHash[$Columns[$col]]].Value = $row[$col]
	                            }
	                        }
	                        Default {
	                            $Command.Parameters[$ColumnToParamHash[$Columns[$col]]].Value = $row[$col]
	                        }
	                    }
	                }
	
	                #We have the query, execute!
	                    Try
	                    {
	                        [void]$Command.ExecuteNonQuery()
	                    }
	                    Catch
	                    {
	                        #Minimal testing for this rollback...
	                            Write-Verbose "Rolling back due to error:`n$_"
	                            $Transaction.Rollback()
	
	                        #Clean up and throw an error
	                            CleanUp -conn $SQLiteConnection -com $Command -BoundParams $PSBoundParameters
	                            Throw "Rolled back due to error:`n$_"
	                    }
	
	                if($NotifyAfter -gt 0 -and $($RowNumber % $NotifyAfter) -eq 0)
	                {
	                    Write-Verbose "Processed $($RowNumber + 1) records"
	                }
	            }
	    }
	
	    #Commit the transaction and clean up the connection
	        $Transaction.Commit()
	        CleanUp -conn $SQLiteConnection -com $Command -BoundParams $PSBoundParameters
	
	}
	
}
#endregion

#region Call-Invoke-SqliteQuery_ps1
function Call-Invoke-SqliteQuery_ps1
{
	function Invoke-SqliteQuery {
	    <#
	    .SYNOPSIS
	        Runs a SQL script against a SQLite database.
	
	    .DESCRIPTION
	        Runs a SQL script against a SQLite database.
	
	        Paramaterized queries are supported.
	
	        Help details below borrowed from Invoke-Sqlcmd, may be inaccurate here.
	
	    .PARAMETER DataSource
	        Path to one ore more SQLite data sources to query
	
	    .PARAMETER Query
	        Specifies a query to be run.
	
	    .PARAMETER InputFile
	        Specifies a file to be used as the query input to Invoke-SqliteQuery. Specify the full path to the file.
	
	    .PARAMETER QueryTimeout
	        Specifies the number of seconds before the queries time out.
	
	    .PARAMETER As
	        Specifies output type - DataSet, DataTable, array of DataRow, PSObject or Single Value
	
	        PSObject output introduces overhead but adds flexibility for working with results: http://powershell.org/wp/forums/topic/dealing-with-dbnull/
	
	    .PARAMETER SqlParameters
	        Hashtable of parameters for parameterized SQL queries.  http://blog.codinghorror.com/give-me-parameterized-sql-or-give-me-death/
	
	        Limited support for conversions to SQLite friendly formats is supported.
	            For example, if you pass in a .NET DateTime, we convert it to a string that SQLite will recognize as a datetime
	
	        Example:
	            -Query "SELECT ServerName FROM tblServerInfo WHERE ServerName LIKE @ServerName"
	            -SqlParameters @{"ServerName = "c-is-hyperv-1"}
	
	    .PARAMETER SQLiteConnection
	        An existing SQLiteConnection to use.  We do not close this connection upon completed query.
	
	    .PARAMETER AppendDataSource
	        If specified, append the SQLite data source path to PSObject or DataRow output
	
	    .INPUTS
	        DataSource
	            You can pipe DataSource paths to Invoke-SQLiteQuery.  The query will execute against each Data Source.
	
	    .OUTPUTS
	       As PSObject:     System.Management.Automation.PSCustomObject
	       As DataRow:      System.Data.DataRow
	       As DataTable:    System.Data.DataTable
	       As DataSet:      System.Data.DataTableCollectionSystem.Data.DataSet
	       As SingleValue:  Dependent on data type in first column.
	
	    .EXAMPLE
	
	        #
	        # First, we create a database and a table
	            $Query = "CREATE TABLE NAMES (fullname VARCHAR(20) PRIMARY KEY, surname TEXT, givenname TEXT, BirthDate DATETIME)"
	            $Database = "C:\Names.SQLite"
	
	            Invoke-SqliteQuery -Query $Query -DataSource $Database
	
	        # We have a database, and a table, let's view the table info
	            Invoke-SqliteQuery -DataSource $Database -Query "PRAGMA table_info(NAMES)"
	
	                cid name      type         notnull dflt_value pk
	                --- ----      ----         ------- ---------- --
	                  0 fullname  VARCHAR(20)        0             1
	                  1 surname   TEXT               0             0
	                  2 givenname TEXT               0             0
	                  3 BirthDate DATETIME           0             0
	
	        # Insert some data, use parameters for the fullname and birthdate
	            $query = "INSERT INTO NAMES (fullname, surname, givenname, birthdate) VALUES (@full, 'Cookie', 'Monster', @BD)"
	            Invoke-SqliteQuery -DataSource $Database -Query $query -SqlParameters @{
	                full = "Cookie Monster"
	                BD   = (get-date).addyears(-3)
	            }
	
	        # Check to see if we inserted the data:
	            Invoke-SqliteQuery -DataSource $Database -Query "SELECT * FROM NAMES"
	
	                fullname       surname givenname BirthDate
	                --------       ------- --------- ---------
	                Cookie Monster Cookie  Monster   3/14/2012 12:27:13 PM
	
	        # Insert another entry with too many characters in the fullname.
	        # Illustrate that SQLite data types may be misleading:
	            Invoke-SqliteQuery -DataSource $Database -Query $query -SqlParameters @{
	                full = "Cookie Monster$('!' * 20)"
	                BD   = (get-date).addyears(-3)
	            }
	
	            Invoke-SqliteQuery -DataSource $Database -Query "SELECT * FROM NAMES"
	
	                fullname              surname givenname BirthDate
	                --------              ------- --------- ---------
	                Cookie Monster        Cookie  Monster   3/14/2012 12:27:13 PM
	                Cookie Monster![...]! Cookie  Monster   3/14/2012 12:29:32 PM
	
	    .EXAMPLE
	        Invoke-SqliteQuery -DataSource C:\NAMES.SQLite -Query "SELECT * FROM NAMES" -AppendDataSource
	
	            fullname       surname givenname BirthDate             Database
	            --------       ------- --------- ---------             --------
	            Cookie Monster Cookie  Monster   3/14/2012 12:55:55 PM C:\Names.SQLite
	
	        # Append Database column (path) to each result
	
	    .EXAMPLE
	        Invoke-SqliteQuery -DataSource C:\Names.SQLite -InputFile C:\Query.sql
	
	        # Invoke SQL from an input file
	
	    .EXAMPLE
	        $Connection = New-SQLiteConnection -DataSource :MEMORY:
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "CREATE TABLE OrdersToNames (OrderID INT PRIMARY KEY, fullname TEXT);"
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "INSERT INTO OrdersToNames (OrderID, fullname) VALUES (1,'Cookie Monster');"
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "PRAGMA STATS"
	
	        # Execute a query against an existing SQLiteConnection
	            # Create a connection to a SQLite data source in memory
	            # Create a table in the memory based datasource, verify it exists with PRAGMA STATS
	
	    .EXAMPLE
	        $Connection = New-SQLiteConnection -DataSource :MEMORY:
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "CREATE TABLE OrdersToNames (OrderID INT PRIMARY KEY, fullname TEXT);"
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "INSERT INTO OrdersToNames (OrderID, fullname) VALUES (1,'Cookie Monster');"
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "INSERT INTO OrdersToNames (OrderID) VALUES (2);"
	
	        # We now have two entries, only one has a fullname.  Despite this, the following command returns both; very un-PowerShell!
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "SELECT * FROM OrdersToNames" -As DataRow | Where{$_.fullname}
	
	            OrderID fullname
	            ------- --------
	                  1 Cookie Monster
	                  2
	
	        # Using the default -As PSObject, we can get PowerShell-esque behavior:
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "SELECT * FROM OrdersToNames" | Where{$_.fullname}
	
	            OrderID fullname
	            ------- --------
	                  1 Cookie Monster
	
	    .LINK
	        https://github.com/RamblingCookieMonster/Invoke-SQLiteQuery
	
	    .LINK
	        New-SQLiteConnection
	
	    .LINK
	        Invoke-SQLiteBulkCopy
	
	    .LINK
	        Out-DataTable
	
	    .LINK
	        https://www.sqlite.org/datatype3.html
	
	    .LINK
	        https://www.sqlite.org/lang.html
	
	    .LINK
	        http://www.sqlite.org/pragma.html
	
	    .FUNCTIONALITY
	        SQL
	    #>
	
	    [CmdletBinding( DefaultParameterSetName='Src-Que' )]
	    [OutputType([System.Management.Automation.PSCustomObject],[System.Data.DataRow],[System.Data.DataTable],[System.Data.DataTableCollection],[System.Data.DataSet])]
	    param(
	        [Parameter( ParameterSetName='Src-Que',
	                    Position=0,
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false,
	                    HelpMessage='SQLite Data Source required...' )]
	        [Parameter( ParameterSetName='Src-Fil',
	                    Position=0,
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false,
	                    HelpMessage='SQLite Data Source required...' )]
	        [Alias('Path','File','FullName','Database')]
	        [validatescript({
	            #This should match memory, or the parent path should exist
	            $Parent = Split-Path $_ -Parent
	            if(
	                $_ -match ":MEMORY:|^WHAT$" -or
	                ( $Parent -and (Test-Path $Parent))
	            ){
	                $True
	            }
	            else {
	                Throw "Invalid datasource '$_'.`nThis must match :MEMORY:, or '$Parent' must exist"
	            }
	        })]
	        [string[]]
	        $DataSource,
	
	        [Parameter( ParameterSetName='Src-Que',
	                    Position=1,
	                    Mandatory=$true,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [Parameter( ParameterSetName='Con-Que',
	                    Position=1,
	                    Mandatory=$true,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [string]
	        $Query,
	
	        [Parameter( ParameterSetName='Src-Fil',
	                    Position=1,
	                    Mandatory=$true,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [Parameter( ParameterSetName='Con-Fil',
	                    Position=1,
	                    Mandatory=$true,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [ValidateScript({ Test-Path $_ })]
	        [string]
	        $InputFile,
	
	        [Parameter( Position=2,
	                    Mandatory=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [Int32]
	        $QueryTimeout=600,
	
	        [Parameter( Position=3,
	                    Mandatory=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [ValidateSet("DataSet", "DataTable", "DataRow","PSObject","SingleValue")]
	        [string]
	        $As="PSObject",
	
	        [Parameter( Position=4,
	                    Mandatory=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [System.Collections.IDictionary]
	        $SqlParameters,
	
	        [Parameter( Position=5,
	                    Mandatory=$false )]
	        [switch]
	        $AppendDataSource,
	
	        [Parameter( Position=6,
	                    Mandatory=$false )]
	        [validatescript({Test-Path $_ })]
	        [string]$AssemblyPath = $SQLiteAssembly,
	
	        [Parameter( ParameterSetName = 'Con-Que',
	                    Position=7,
	                    Mandatory=$true,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [Parameter( ParameterSetName = 'Con-Fil',
	                    Position=7,
	                    Mandatory=$true,
	                    ValueFromPipeline=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [Alias( 'Connection', 'Conn' )]
	        [System.Data.SQLite.SQLiteConnection]
	        $SQLiteConnection
	    )
	
	    Begin
	    {
	        #Assembly, should already be covered by psm1
	            Try
	            {
	                [void][System.Data.SQLite.SQLiteConnection]
	            }
	            Catch
	            {
	                if( -not ($Library = Add-Type -path $SQLiteAssembly -PassThru -ErrorAction stop) )
	                {
	                    Throw "This module requires the ADO.NET driver for SQLite:`n`thttp://system.data.sqlite.org/index.html/doc/trunk/www/downloads.wiki"
	                }
	            }
	
	        if ($InputFile)
	        {
	            $filePath = $(Resolve-Path $InputFile).path
	            $Query =  [System.IO.File]::ReadAllText("$filePath")
	        }
	
	        Write-Verbose "Running Invoke-SQLiteQuery with ParameterSet '$($PSCmdlet.ParameterSetName)'.  Performing query '$Query'"
	
	        If($As -eq "PSObject")
	        {
	            #This code scrubs DBNulls.  Props to Dave Wyatt
	            $cSharp = @'
                using System;
                using System.Data;
                using System.Management.Automation;

                public class DBNullScrubber
                {
                    public static PSObject DataRowToPSObject(DataRow row)
                    {
                        PSObject psObject = new PSObject();

                        if (row != null && (row.RowState & DataRowState.Detached) != DataRowState.Detached)
                        {
                            foreach (DataColumn column in row.Table.Columns)
                            {
                                Object value = null;
                                if (!row.IsNull(column))
                                {
                                    value = row[column];
                                }

                                psObject.Properties.Add(new PSNoteProperty(column.ColumnName, value));
                            }
                        }

                        return psObject;
                    }
                }
'@
	
	            Try
	            {
	                Add-Type -TypeDefinition $cSharp -ReferencedAssemblies 'System.Data','System.Xml' -ErrorAction stop
	            }
	            Catch
	            {
	                If(-not $_.ToString() -like "*The type name 'DBNullScrubber' already exists*")
	                {
	                    Write-Warning "Could not load DBNullScrubber.  Defaulting to DataRow output: $_"
	                    $As = "Datarow"
	                }
	            }
	        }
	
	        #Handle existing connections
	        if($PSBoundParameters.Keys -contains "SQLiteConnection")
	        {
	            if($SQLiteConnection.State -notlike "Open")
	            {
	                Try
	                {
	                    $SQLiteConnection.Open()
	                }
	                Catch
	                {
	                    Throw $_
	                }
	            }
	
	            if($SQLiteConnection.state -notlike "Open")
	            {
	                Throw "SQLiteConnection is not open:`n$($SQLiteConnection | Out-String)"
	            }
	
	            $DataSource = @("WHAT")
	        }
	    }
	    Process
	    {
	        foreach($DB in $DataSource)
	        {
	
	            if($PSBoundParameters.Keys -contains "SQLiteConnection")
	            {
	                $Conn = $SQLiteConnection
	            }
	            else
	            {
	                if(Test-Path $DB)
	                {
	                    Write-Verbose "Querying existing Data Source '$DB'"
	                }
	                else
	                {
	                    Write-Verbose "Creating andn querying Data Source '$DB'"
	                }
	
	                $ConnectionString = "Data Source={0}" -f $DB
	
	                $conn = New-Object System.Data.SQLite.SQLiteConnection -ArgumentList $ConnectionString
	                $conn.ParseViaFramework = $true #Allow UNC paths, thanks to Ray Alex!
	                Write-Debug "ConnectionString $ConnectionString"
	
	                Try
	                {
	                    $conn.Open()
	                }
	                Catch
	                {
	                    Write-Error $_
	                    continue
	                }
	            }
	
	            $cmd = $Conn.CreateCommand()
	            $cmd.CommandText = $Query
	            $cmd.CommandTimeout = $QueryTimeout
	
	            if ($SqlParameters -ne $null)
	            {
	                $SqlParameters.GetEnumerator() |
	                    ForEach-Object {
	                        If ($_.Value -ne $null)
	                        {
	                            if($_.Value -is [datetime]) { $_.Value = $_.Value.ToString("yyyy-MM-dd HH:mm:ss") }
	                            $cmd.Parameters.AddWithValue("@$($_.Key)", $_.Value)
	                        }
	                        Else
	                        {
	                            $cmd.Parameters.AddWithValue("@$($_.Key)", [DBNull]::Value)
	                        }
	                    } > $null
	            }
	
	            $ds = New-Object system.Data.DataSet
	            $da = New-Object System.Data.SQLite.SQLiteDataAdapter($cmd)
	
	            Try
	            {
	                [void]$da.fill($ds)
	                if($PSBoundParameters.Keys -notcontains "SQLiteConnection")
	                {
	                    $conn.Close()
	                }
	                $cmd.Dispose()
	            }
	            Catch
	            {
	                $Err = $_
	                if($PSBoundParameters.Keys -notcontains "SQLiteConnection")
	                {
	                    $conn.Close()
	                }
	                switch ($ErrorActionPreference.tostring())
	                {
	                    {'SilentlyContinue','Ignore' -contains $_} {}
	                    'Stop' {     Throw $Err }
	                    'Continue' { Write-Error $Err}
	                    Default {    Write-Error $Err}
	                }
	            }
	
	            if($AppendDataSource)
	            {
	                #Basics from Chad Miller
	                $Column =  New-Object Data.DataColumn
	                $Column.ColumnName = "Datasource"
	                $ds.Tables[0].Columns.Add($Column)
	
	                Try
	                {
	                    #Someone better at regular expression, feel free to tackle this
	                    $Conn.ConnectionString -match "Data Source=(?<DataSource>.*);"
	                    $Datasrc = $Matches.DataSource.split(";")[0]
	                }
	                Catch
	                {
	                    $Datasrc = $DB
	                }
	
	                Foreach($row in $ds.Tables[0])
	                {
	                    $row.Datasource = $Datasrc
	                }
	            }
	
	            switch ($As)
	            {
	                'DataSet'
	                {
	                    $ds
	                }
	                'DataTable'
	                {
	                    $ds.Tables
	                }
	                'DataRow'
	                {
	                    $ds.Tables[0]
	                }
	                'PSObject'
	                {
	                    #Scrub DBNulls - Provides convenient results you can use comparisons with
	                    #Introduces overhead (e.g. ~2000 rows w/ ~80 columns went from .15 Seconds to .65 Seconds - depending on your data could be much more!)
	                    foreach ($row in $ds.Tables[0].Rows)
	                    {
	                        [DBNullScrubber]::DataRowToPSObject($row)
	                    }
	                }
	                'SingleValue'
	                {
	                    $ds.Tables[0] | Select-Object -ExpandProperty $ds.Tables[0].Columns[0].ColumnName
	                }
	            }
	        }
	    }
	}
	
}
#endregion

#region Call-New-SqliteConnection_ps1
function Call-New-SqliteConnection_ps1
{
	function New-SQLiteConnection
	{
	    <#
	    .SYNOPSIS
	        Creates a SQLiteConnection to a SQLite data source
	
	    .DESCRIPTION
	        Creates a SQLiteConnection to a SQLite data source
	
	    .PARAMETER DataSource
	       SQLite Data Source to connect to.
	
	    .PARAMETER Password
	        Specifies A Secure String password to use in the SQLite connection string.
	
	        SECURITY NOTE: If you use the -Debug switch, the connectionstring including plain text password will be sent to the debug stream.
	
	    .PARAMETER ReadOnly
	        If specified, open SQLite data source as read only
	
	    .PARAMETER Open
	        We open the connection by default.  You can use this parameter to create a connection without opening it.
	
	    .OUTPUTS
	        System.Data.SQLite.SQLiteConnection
	
	    .EXAMPLE
	        $Connection = New-SQLiteConnection -DataSource C:\NAMES.SQLite
	        Invoke-SQLiteQuery -SQLiteConnection $Connection -query $Query
	
	        # Connect to C:\NAMES.SQLite, invoke a query against it
	
	    .EXAMPLE
	        $Connection = New-SQLiteConnection -DataSource :MEMORY:
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "CREATE TABLE OrdersToNames (OrderID INT PRIMARY KEY, fullname TEXT);"
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "INSERT INTO OrdersToNames (OrderID, fullname) VALUES (1,'Cookie Monster');"
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "PRAGMA STATS"
	
	        # Create a connection to a SQLite data source in memory
	        # Create a table in the memory based datasource, verify it exists with PRAGMA STATS
	
	        $Connection.Close()
	        $Connection.Open()
	        Invoke-SqliteQuery -SQLiteConnection $Connection -Query "PRAGMA STATS"
	
	        #Close the connection, open it back up, verify that the ephemeral data no longer exists
	
	    .LINK
	        https://github.com/RamblingCookieMonster/Invoke-SQLiteQuery
	
	    .LINK
	        Invoke-SQLiteQuery
	
	    .FUNCTIONALITY
	        SQL
	
	    #>
	    [cmdletbinding()]
	    [OutputType([System.Data.SQLite.SQLiteConnection])]
	    param(
	        [Parameter( Position=0,
	                    Mandatory=$true,
	                    ValueFromPipeline=$true,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false,
	                    HelpMessage='SQL Server Instance required...' )]
	        [Alias( 'Instance', 'Instances', 'ServerInstance', 'Server', 'Servers','cn','Path','File','FullName','Database' )]
	        [ValidateNotNullOrEmpty()]
	        [string[]]
	        $DataSource,
	
	        [Parameter( Position=2,
	                    Mandatory=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [System.Security.SecureString]
	        $Password,
	
	        [Parameter( Position=3,
	                    Mandatory=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [Switch]
	        $ReadOnly,
	
	        [Parameter( Position=4,
	                    Mandatory=$false,
	                    ValueFromPipelineByPropertyName=$true,
	                    ValueFromRemainingArguments=$false )]
	        [bool]
	        $Open = $True
	    )
	    Process
	    {
	        foreach($DataSRC in $DataSource)
	        {
	            Write-Verbose "Querying Data Source '$DataSRC'"
	            [string]$ConnectionString = "Data Source=$DataSRC;"
	            if ($Password)
	            {
	                $BSTR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password)
	                $PlainPassword = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BSTR)
	                $ConnectionString += "Password=$PlainPassword;"
	            }
	            if($ReadOnly)
	            {
	                $ConnectionString += "Read Only=True;"
	            }
	
	            $conn = New-Object System.Data.SQLite.SQLiteConnection -ArgumentList $ConnectionString
	            $conn.ParseViaFramework = $true #Allow UNC paths, thanks to Ray Alex!
	            Write-Debug "ConnectionString $ConnectionString"
	
	            if($Open)
	            {
	                Try
	                {
	                    $conn.Open()
	                }
	                Catch
	                {
	                    Write-Error $_
	                    continue
	                }
	            }
	
	            write-Verbose "Created SQLiteConnection:`n$($Conn | Out-String)"
	
	            $Conn
	        }
	    }
	}
	
}
#endregion

#region Call-Out-DataTable_ps1
function Call-Out-DataTable_ps1
{
	function Out-DataTable
	{
	<#
	.SYNOPSIS
	    Creates a DataTable for an object
	
	.DESCRIPTION
	    Creates a DataTable based on an object's properties.
	
	.PARAMETER InputObject
	    One or more objects to convert into a DataTable
	
	.PARAMETER NonNullable
	    A list of columns to set disable AllowDBNull on
	
	.INPUTS
	    Object
	        Any object can be piped to Out-DataTable
	
	.OUTPUTS
	   System.Data.DataTable
	
	.EXAMPLE
	    $dt = Get-psdrive | Out-DataTable
	
	    # This example creates a DataTable from the properties of Get-psdrive and assigns output to $dt variable
	
	.EXAMPLE
	    Get-Process | Select Name, CPU | Out-DataTable | Invoke-SQLBulkCopy -ServerInstance $SQLInstance -Database $Database -Table $SQLTable -force -verbose
	
	    # Get a list of processes and their CPU, create a datatable, bulk import that data
	
	.NOTES
	    Adapted from script by Marc van Orsouw and function from Chad Miller
	    Version History
	    v1.0  - Chad Miller - Initial Release
	    v1.1  - Chad Miller - Fixed Issue with Properties
	    v1.2  - Chad Miller - Added setting column datatype by property as suggested by emp0
	    v1.3  - Chad Miller - Corrected issue with setting datatype on empty properties
	    v1.4  - Chad Miller - Corrected issue with DBNull
	    v1.5  - Chad Miller - Updated example
	    v1.6  - Chad Miller - Added column datatype logic with default to string
	    v1.7  - Chad Miller - Fixed issue with IsArray
	    v1.8  - ramblingcookiemonster - Removed if($Value) logic.  This would not catch empty strings, zero, $false and other non-null items
	                                  - Added perhaps pointless error handling
	
	.LINK
	    https://github.com/RamblingCookieMonster/PowerShell
	
	.LINK
	    Invoke-SQLBulkCopy
	
	.LINK
	    Invoke-Sqlcmd2
	
	.LINK
	    New-SQLConnection
	
	.FUNCTIONALITY
	    SQL
	#>
	    [CmdletBinding()]
	    [OutputType([System.Data.DataTable])]
	    param(
	        [Parameter( Position=0,
	                    Mandatory=$true,
	                    ValueFromPipeline = $true)]
	        [PSObject[]]$InputObject,
	
	        [string[]]$NonNullable = @()
	    )
	
	    Begin
	    {
	        $dt = New-Object Data.datatable
	        $First = $true
	
	        function Get-ODTType
	        {
	            param($type)
	
	            $types = @(
	                'System.Boolean',
	                'System.Byte[]',
	                'System.Byte',
	                'System.Char',
	                'System.Datetime',
	                'System.Decimal',
	                'System.Double',
	                'System.Guid',
	                'System.Int16',
	                'System.Int32',
	                'System.Int64',
	                'System.Single',
	                'System.UInt16',
	                'System.UInt32',
	                'System.UInt64')
	
	            if ( $types -contains $type ) {
	                Write-Output "$type"
	            }
	            else {
	                Write-Output 'System.String'
	            }
	        } #Get-Type
	    }
	    Process
	    {
	        foreach ($Object in $InputObject)
	        {
	            $DR = $DT.NewRow()
	            foreach ($Property in $Object.PsObject.Properties)
	            {
	                $Name = $Property.Name
	                $Value = $Property.Value
	
	                #RCM: what if the first property is not reflective of all the properties?  Unlikely, but...
	                if ($First)
	                {
	                    $Col = New-Object Data.DataColumn
	                    $Col.ColumnName = $Name
	
	                    #If it's not DBNull or Null, get the type
	                    if ($Value -isnot [System.DBNull] -and $Value -ne $null)
	                    {
	                        $Col.DataType = [System.Type]::GetType( $(Get-ODTType $property.TypeNameOfValue) )
	                    }
	
	                    #Set it to nonnullable if specified
	                    if ($NonNullable -contains $Name )
	                    {
	                        $col.AllowDBNull = $false
	                    }
	
	                    try
	                    {
	                        $DT.Columns.Add($Col)
	                    }
	                    catch
	                    {
	                        Write-Error "Could not add column $($Col | Out-String) for property '$Name' with value '$Value' and type '$($Value.GetType().FullName)':`n$_"
	                    }
	                }
	
	                Try
	                {
	                    #Handle arrays and nulls
	                    if ($property.GetType().IsArray)
	                    {
	                        $DR.Item($Name) = $Value | ConvertTo-XML -As String -NoTypeInformation -Depth 1
	                    }
	                    elseif($Value -eq $null)
	                    {
	                        $DR.Item($Name) = [DBNull]::Value
	                    }
	                    else
	                    {
	                        $DR.Item($Name) = $Value
	                    }
	                }
	                Catch
	                {
	                    Write-Error "Could not add property '$Name' with value '$Value' and type '$($Value.GetType().FullName)'"
	                    continue
	                }
	
	                #Did we get a null or dbnull for a non-nullable item?  let the user know.
	                if($NonNullable -contains $Name -and ($Value -is [System.DBNull] -or $Value -eq $null))
	                {
	                    write-verbose "NonNullable property '$Name' with null value found: $($object | out-string)"
	                }
	
	            }
	
	            Try
	            {
	                $DT.Rows.Add($DR)
	            }
	            Catch
	            {
	                Write-Error "Failed to add row '$($DR | Out-String)':`n$_"
	            }
	
	            $First = $false
	        }
	    }
	
	    End
	    {
	        Write-Output @(,$dt)
	    }
	
	} #Out-DataTable
	
}
#endregion

#region Call-Export-CKL_ps1
function Call-Export-CKL_ps1
{
	function Export-CKL {
	<#
	.SYNOPSIS
	This Script takes our trackers and converts them to CKL files
	
	.PARAMETER Path
	Path to the STIG Viewer Export (CSV or XLSX) file. Do not end the path with a \
	The files located at the path need to be specially formated following the IVV Process
	Created by Joshua Magady
	
	.PARAMETER Out
	Path to place the generated CKL
	
	.PARAMETER version
	the version of ckl we want to create
	
	.PARAMETER Recursive
	switch to indicate if we want to travers all the child directorys
	
	
	.EXAMPLE
	Export-CKL -Path C:\files -Out C:\Results -Version 1
	
	Export-CKL -Path C:\files -Out C:\Results -Version 1 -Recursive
	
	Export-CKL -Path C: -Out C:\Results -Version 1 -Recursive
	
	.LINK
	
	.VERSION
	1.0.0 (02.10.2016)
	    -Intial Release
	
	#>
	
	    [CmdletBinding()]
	    Param(
	        [string]$Path = $(Throw "No Path provided"),
	        [string]$Out = $(Throw "No output path provided"),
	        [int]$version = $(Throw "No Version provided"),
	        [switch]$Recursive
	    )
	
	    BEGIN {
	        if ($version -eq 1){ # Needs to be updated to support version 2 of the STIG Viewer
	            $stigViewerVersion = "DISA STIG Viewer : 1.2.0"
	            $headMappers = [ordered]@{ # Change the value of the hastable key values to match the headers of the sheet your importing # Maybe needed [ordered]
	                "Vuln_Num"="Vuln ID"
	                "Severity"="Severity"
	                "Group_Title"="Group Title"
	                "Rule_ID"="Rule ID"
	                "Rule_Ver"="STIG ID"
	                "Rule_Title"="Rule Title"
	                "Vuln_Discuss"="Discussion"
	                "IA_Controls"="IA Controls"
	                "Check_Content"="Check Content"
	                "Fix_Text"="Fix Text"
	                "False_Positives"="False Positives"
	                "False_Negatives"="False Negatives"
	                "Documentable"="Documentable"
	                "Mitigations"="Mitigations"
	                "Potential_Impact"="Potential Impact"
	                "Third_Party_Tools"="Third Party Tools"
	                "Mitigation_Control"="Mitigation Control"
	                "Responsibility"="Responsibility"
	                "Security_Override_Guidance"="Severity Override Guidance"
	                "Check_Content_Ref"="Check Content Reference"
	                "Class"="Classification"
	                "STIGRef"="STIG"
	                "TargetKey"="VMS Asset Posture"
	                # "CCI_REF"="CCI Data"  -- Removed this Attribute
	                "STATUS"="Status"
	                # These Below can be equal to $null
	                "FINDING_DETAILS"="Notes"
	                "COMMENTS"= "Comments"
	                "SEVERITY_OVERRIDE"= "Severity Override"
	                "SEVERITY_JUSTIFICATION"= "Severity Override Justification"
	            }
	        }
	        Else{
	            $stigViewerVersion = "DISA STIG Viewer : 1.2.0"
	            $headMappers = [ordered]@{ # Change the value of the hastable key values to match the headers of the sheet your importing # Maybe needed [ordered]
	                "Vuln_Num"="Vuln ID"
	                "Severity"="Severity"
	                "Group_Title"="Group Title"
	                "Rule_ID"="Rule ID"
	                "Rule_Ver"="STIG ID"
	                "Rule_Title"="Rule Title"
	                "Vuln_Discuss"="Discussion"
	                "IA_Controls"="IA Controls"
	                "Check_Content"="Check Content"
	                "Fix_Text"="Fix Text"
	                "False_Positives"="False Positives"
	                "False_Negatives"="False Negatives"
	                "Documentable"="Documentable"
	                "Mitigations"="Mitigations"
	                "Potential_Impact"="Potential Impact"
	                "Third_Party_Tools"="Third Party Tools"
	                "Mitigation_Control"="Mitigation Control"
	                "Responsibility"="Responsibility"
	                "Security_Override_Guidance"="Severity Override Guidance"
	                "Check_Content_Ref"="Check Content Reference"
	                "Class"="Classification"
	                "STIGRef"="STIG"
	                "TargetKey"="VMS Asset Posture"
	                # "CCI_REF"="CCI Data"  -- Removed this Attribute
	                "STATUS"="Status"
	                # These Below can be equal to $null
	                "FINDING_DETAILS"="Notes"
	                "COMMENTS"= "Comments"
	                "SEVERITY_OVERRIDE"= "Severity Override"
	                "SEVERITY_JUSTIFICATION"= "Severity Override Justification"
	            }
	        }
	    }
	    PROCESS {
	        if ($Recursive) {
	            $Private:files = Get-ChildItem -Path "$($Path)\*" -Include "*.xlsx","*.csv" -Recurse # Get files recursively
	        }
	        Else {
	            $Private:files = Get-ChildItem -Path "$($Path)\*" -Include "*.xlsx","*.csv" # get files non recursively
	        }
	    }
	    END {
	        if (!$Private:files) {
	            Throw "No Files Found"
	        }
	        foreach ($Private:file in $Private:files) { # Loop through the found files
	            $Private:filehostname = $($Private:file.name).split("_")[0] # Pull hostname from the file (Requires the file to be name <hostname>_<STIG NAME>.<csv or xlsx>)
	            $Private:filename = "$($($Private:file.name).Split(".")[0]).ckl" # Create new file name
	            if($file.extension -like ".csv"){ # Checks if the file is a csv
	                $Private:importfile = Import-Csv -Path $file.FullName
	            }
	            Elseif($file.extension -like ".xlsx") { # Checks if the file is an xlsx
	                $Private:importfile = Import-XLSX -Path $file.FullName
	            }
	            Else {
	                Throw "An error has occured"
	            }
	            ConvertTo-CKL -Obj $Private:importfile -version $stigViewerVersion -hostn $Private:filehostname -map $headMappers -ofile "$($Out)\$($Private:filename)" # Create and Write the ckl file
	        }
	    }
	}
	
}
#endregion

#region Call-Get-STIGCompliance_ps1
function Call-Get-STIGCompliance_ps1
{
	
}
#endregion

#region Call-ConvertTo-CKL_ps1
function Call-ConvertTo-CKL_ps1
{
	function ConvertTo-CKL { # Builds XML Document
	<#
	.SYNOPSIS
	Imports csv or xlsx file and converts it to a CKLv1 file (Requires CKL v1 export)
	
	.PARAMETER Path
	Path to look for
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.09.2016)
	    -Intial Release
	
	#>
	    Param(
	        [Object]$Obj,
	        [string]$version,
	        [string]$hostn = "HOST",
	        [string]$ip = "IP",
	        [string]$mac = "MAC",
	        [string]$type = "Computing",
	        [Object]$map,
	        [string]$ofile
	    )
	
	    $Private:params = "version=`"1.0`" encoding=`"UTF-8`" standalone=`"yes`""
	    $Private:w = New-Object system.xml.xmltextwriter($ofile, $null)
	    $Private:w.Formatting = [System.xml.formatting]::Indented # sets the fomrating option for the writter
	    $Private:w.WriteProcessingInstruction("xml", $Private:params) # Starts XML Document
	    # Start or XML Data
	    $Private:w.WriteStartElement("CHECKLIST") # Root Element Checklist
	    $Private:w.WriteStartElement("SV_VERSION") # Stig Viewer Version Element
	    $Private:w.WriteString($version) # Writes the version string into the SV_Version element
	    $Private:w.WriteEndElement() # End SV_Version Element
	    $Private:w.WriteStartElement("ASSET") # ASSET Element
	    $Private:w.WriteStartElement("ASSET_TYPE") # Asset Type Element
	    $Private:w.WriteString($type) # Sets Asset type element data
	    $Private:w.WriteEndElement() # End of ASSET_TYPE Element HOST_NAME
	    $Private:w.WriteStartElement("HOST_NAME") # HOST_NAME Element
	    $Private:w.WriteString($hostn) # Sets host_name elemnt data
	    $Private:w.WriteEndElement() # End Host_Name Element HOST_IP
	    $Private:w.WriteStartElement("HOST_IP") # Host_IP Element
	    $Private:w.WriteString($ip) # Sets HOST_IP Data
	    $Private:w.WriteEndElement() # End HOST_IP Element HOST_MAC
	    $Private:w.WriteStartElement("HOST_MAC") # HOST_MAC Element
	    $Private:w.WriteString($mac) # HOST_MAC Data
	    $Private:w.WriteEndElement() # End HOST_MAC Element HOST_GUID
	    $Private:w.WriteStartElement("HOST_GUID") # HOST_GUID Element
	    $Private:w.WriteEndElement() # End HOST_GUID Element TARGET_KEY
	    $Private:w.WriteStartElement("TARGET_KEY") # TARGET_KEY Element
	    $Private:w.WriteEndElement() # end TARGET_KEY Element ASSET_VAL
	    $Private:w.WriteStartElement("ASSET_VAL") # ASSET_VAL Element
	    $Private:w.WriteStartElement("AV_NAME") # AV_NAME Element
	    $Private:w.WriteAttributeString("xmlns:xsi","http://www.w3.org/2001/XMLSchema-instance") # Write AV_NAME Element Atribute
	    $Private:w.WriteAttributeString("xmlns:xs","http://www.w3.org/2001/XMLSchema") # Write AV_NAME Element Atribute
	    $Private:w.WriteAttributeString("xsi:type","xs:string") # Write AV_NAME Element Atribute
	    $Private:w.WriteString("Role") # AV_NAME DATA
	    $Private:w.WriteEndElement() # End AV_NAME Element
	    $Private:w.WriteStartElement("AV_DATA") # AV_DATA Element
	    $Private:w.WriteAttributeString("xmlns:xsi","http://www.w3.org/2001/XMLSchema-instance") # Write AV_DATA Element Atribute
	    $Private:w.WriteAttributeString("xmlns:xs","http://www.w3.org/2001/XMLSchema") # Write AV_DATA Element Atribute
	    $Private:w.WriteAttributeString("xsi:type","xs:string")# Write AV_DATA Element Atribute
	    $Private:w.WriteString("Role") # AV_DATA DATA
	    $Private:w.WriteEndElement() # End AV_DATA Element
	    $Private:w.WriteEndElement() # End ASSET_VAL Element
	    $Private:w.WriteEndElement() # End ASSET Element STIG_INFO
	    $Private:w.WriteStartElement("STIG_INFO") # STIG_INFO Element STIG_TITLE
	    $Private:w.WriteStartElement("STIG_TITLE") # STIG_TITLE Element
	    $Private:w.WriteString($($Obj[0].("STIG"))) # STIG_TITLE Data
	    $Private:w.WriteEndElement() # End STIG_TITLE Element
	    $Private:w.WriteEndElement() # End STIG_INFO Element
	    foreach($Private:row in $Obj){
	        $Private:w.WriteStartElement("VULN") # Start of VULN Element
	
	        # STIG DATA  Not_Applicable
	        foreach($Private:key in $map.Keys){ # Loop through the Mapping hashtable
	            if($Private:key -eq "Status" -or $Private:key -eq "FINDING_DETAILS" -or $Private:key -eq "COMMENTS" -or $Private:key -eq "SEVERITY_OVERRIDE" -or $Private:key -eq "SEVERITY_JUSTIFICATION"){
	                $Private:w.WriteStartElement($Private:key) # Write Element
	                if($Private:key -eq "Status"){
	                    if($Private:row.($($map.$Private:key)).tolower() -like "NotAFinding"){
	                        $Private:row.($($map.$Private:key)) = "NotAFinding"
	                    }
	                    elseif($Private:row.($($map.$Private:key)).tolower() -like "Not_Reviewed"){
	                        $Private:row.($($map.$Private:key)) = "Not_Reviewed"
	                    }
	                    elseif($Private:row.($($map.$Private:key)).tolower() -like "Open"){
	                        $Private:row.($($map.$Private:key)) = "Open"
	                    }
	                    elseif($Private:row.($($map.$Private:key)).tolower() -like "pass" -or $Private:row.($($map.$Private:key)).tolower() -like "passed"){ #if Status eq pass or passed
	                        $Private:row.($($map.$Private:key)) = "NotAFinding"
	                    }
	                    elseif($Private:row.($($map.$Private:key)).tolower() -like "fail" -or $Private:row.($($map.$Private:key)).tolower() -like "failed"){ # if Status eq fail or failed
	                        $Private:row.($($map.$Private:key)) = "Open"
	                    }
	                    elseif($Private:row.($($map.$Private:key)).tolower() -like "na" -or $Private:row.($($map.$Private:key)).tolower() -like "n/a" -or $Private:row.($($map.$Private:key)).tolower() -like "n\a" -or $Private:row.($($map.$Private:key)).tolower() -like "not applicable"){ # if status eq not applicable
	                        $Private:row.($($map.$Private:key)) = "Not_Applicable"
	                    }
	                }
	                if($Private:row.($($map.$Private:key))){ # if Has Data
	                    $Private:w.WriteString($($Private:row.($($map.$Private:key)))) # Write Data
	                    $Private:w.WriteEndElement() # Write End Element
	                }
	                else{ # if no datae
	                    $Private:w.WriteEndElement() # Write End Element
	                } # End Data Check
	                continue
	            } # End if checking for keys that dont belong under STIG_DATA Elements
	
	            $Private:w.WriteStartElement("STIG_DATA") # Start of STIG Data Element
	
	            $Private:w.WriteStartElement("VULN_ATTRIBUTE") # Start of VULN_ATTRIBUTE Element
	            $Private:w.WriteString($Private:key) # Write VULN_ATTRIBUTE Data
	            $Private:w.WriteEndElement() # End VULN_ATTRIBUTE Element
	
	            $Private:w.WriteStartElement("ATTRIBUTE_DATA") # Start of ATTRIBUTE_DATA Element
	            if($Private:key -eq "Documentable"){
	                $Private:w.WriteString($($Private:row.($($map.$Private:key)))) # write ATTRIBUTE_DATA Data
	                $Private:w.WriteEndElement() # End ATTRIBUTE_DATA Element
	                $Private:w.WriteEndElement() # End of STIG DATA Element
	                continue
	            }
	            if($Private:row.($($map.$Private:key))){ # if ATTRIBUTE_DATA Has Data
	                $Private:w.WriteString($($Private:row.($($map.$Private:key)))) # write ATTRIBUTE_DATA Data
	                $Private:w.WriteEndElement() # End ATTRIBUTE_DATA Element
	            }
	            else{ # if ATTRIBUTE_DATA does not have Data
	                $Private:w.WriteEndElement() # End ATTRIBUTE_DATA Element
	            }
	            $Private:w.WriteEndElement() # End of STIG DATA Element
	
	        } # End for Each key in mapping
	
	        $Private:w.WriteEndElement() # End of VULN Element
	    } # End of Foreach row in obj
	    # Finish Document
	    $Private:w.Flush()
	    $Private:w.Close()
	    #return $Private:sw # Return XML string
	}
	
}
#endregion

#region Call-import-ckl_ps1
function Call-import-ckl_ps1
{
	function import-ckl {
	<#
	.SYNOPSIS
	Imports a  STIG Viewer cklv2 file into an object
	
	.PARAMETER doc
	The file to look for
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (01.23.2016)
	    -Intial Release
	#>
	    [CmdletBinding(DefaultparameterSetName="None")]
	    Param (
	        [Parameter(Mandatory=$true,Position=0,HelpMessage="XML Object to parse")]
	        [ValidateNotNull()]
	        [System.Xml.XmlDataDocument]$doc
	    )
	
	    if ($doc.CHECKLIST) { # Perform verious checks to determin if its a ckl file and what type it is
	        if ($doc.CHECKLIST.VULN) {
	            $Private:cklversion = 1
	        }
	        elseif ($doc.CHECKLIST.STIGS) {
	            $Private:cklversion = 2
	        }
	        else{
	            Throw "unable to determin CKL file version"
	        }
	    }
	    else {
	        Throw "Not a CKL formated file"
	    }
	
	    $Private:results = @() # list of entries we will be returning
	
	    # Decide how we will process this CKL file
	    if ($Private:cklversion -eq 1) {
	        if(!($doc.CHECKLIST.ASSET.HOST_NAME)){
	            Throw "$($file.name) no hostname"
	        }
	        foreach($Private:vuln in $doc.CHECKLIST.VULN){
	            $Private:entry = ($Private:entry = " " | select-object STIG_Title, AssetName, Vuln_Num, Severity, Group_Title, Rule_ID, Rule_Ver, Rule_Title, Vuln_Discuss, IA_Controls, Check_Content, Fix_Text, False_Positives, False_Negatives, Documentable, Mitigations, Potential_Impact, Third_Party_Tools, Mitigation_Control, Responsibility, Security_Override_Guidance, Check_Content_Ref, Class, STIGRef, TargetKey, Status, Finding_Details, Comments, Severity_Override, Severity_Justification, StigViewer_Version)
	            $Private:entry.STIG_Title = $doc.CHECKLIST.STIG_INFO.STIG_TITLE
	            $Private:entry.AssetName = $doc.CHECKLIST.ASSET.HOST_NAME
	            $Private:entry.Vuln_Num = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Vuln_Num"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Severity = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Severity"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Group_Title = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Group_Title"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Rule_ID = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Rule_ID"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Rule_Ver = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Rule_Ver"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Rule_Title = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Rule_Title"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Vuln_Discuss = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Vuln_Discuss"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.IA_Controls = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "IA_Controls"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Check_Content = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Check_Content"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Fix_Text = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Fix_Text"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.False_Positives = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "False_Positives"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.False_Negatives = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "False_Negatives"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Documentable = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Documentable"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Mitigations = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Mitigations"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Potential_Impact = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Potential_Impact"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Third_Party_Tools = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Third_Party_Tools"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Mitigation_Control = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Mitigation_Control"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Responsibility = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Responsibility"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Security_Override_Guidance = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Security_Override_Guidance"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Check_Content_Ref = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Check_Content_Ref"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Class = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "Class"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.STIGRef = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "STIGRef"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.TargetKey = $Private:vuln.STIG_DATA | Where-Object{$_.VULN_ATTRIBUTE -eq "TargetKey"} | Select -ExpandProperty Attribute_Data
	            $Private:entry.Status = $Private:vuln.STATUS
	            $Private:entry.Finding_Details = $Private:vuln.FINDING_DETAILS
	            $Private:entry.Comments = $Private:vuln.COMMENTS
	            $Private:entry.Severity_Override = $Private:vuln.SEVERITY_OVERRIDE
	            $Private:entry.Severity_Justification = $Private:vuln.SEVERITY_JUSTIFICATION
	            $Private:entry.StigViewer_Version = $Private:cklversion
	            $Private:results += $Private:entry
	        } # Foreach
	    return $Private:results
	    }
	    elseif ($Private:cklversion -eq 2) {
	        if (!($doc.CHECKLIST.ASSET.HOST_NAME)) { # Check for a hostname, if not fail.
	            Throw "$($file.name) no hostname"
	        }
	
	        foreach ($Private:stig in $doc.CHECKLIST.STIGS.ISTIG) { # Run through each STIG contained in the CKL
	
	            foreach ($Private:vuln in $Private:stig.VULN) {
	                $Private:entry = ($Private:entry = " " | select-object ASSET_TYPE, HOST_NAME, HOST_IP, HOST_MAC, HOST_GUID, HOST_FQDN, TECH_AREA, TARGET_KEY, version, classification, stigid, description, filename, releaseinfo, title, uuid, notice, source, Vuln_Num, Severity, Group_Title, Rule_ID, Rule_Ver, Rule_Title, Vuln_Discuss, IA_Controls, Check_Content, Fix_Text, False_Positives, False_Negatives, Documentable, Mitigations, Potential_Impact, Third_Party_Tools, Mitigation_Control, Responsibility, Security_Override_Guidance, Check_Content_Ref, Class, STIGRef, TargetKey, CCI_REF, Status, Finding_Details, Comments, Severity_Override, Severity_Justification, StigViewer_Version) # Setup the entry object
	                $Private:entry.ASSET_TYPE = $Private:doc.CHECKLIST.ASSET.ASSET_TYPE
	                $Private:entry.HOST_NAME = $Private:doc.CHECKLIST.ASSET.HOST_NAME
	                $Private:entry.HOST_IP = $Private:doc.CHECKLIST.ASSET.HOST_IP
	                $Private:entry.HOST_MAC = $Private:doc.CHECKLIST.ASSET.HOST_MAC
	                $Private:entry.HOST_GUID = $Private:doc.CHECKLIST.ASSET.HOST_GUID
	                $Private:entry.HOST_FQDN = $Private:doc.CHECKLIST.ASSET.HOST_FQDN
	                $Private:entry.TECH_AREA = $Private:doc.CHECKLIST.ASSET.TECH_AREA
	                $Private:entry.TARGET_KEY = $Private:doc.CHECKLIST.ASSET.TARGET_KEY
	                $Private:entry.version = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "version"}).SID_DATA
	                $Private:entry.classification = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "classification"}).SID_DATA
	                $Private:entry.stigid = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "stigid"}).SID_DATA
	                $Private:entry.description = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "description"}).SID_DATA
	                $Private:entry.filename = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "filename"}).SID_DATA
	                $Private:entry.releaseinfo = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "releaseinfo"}).SID_DATA
	                $Private:entry.title = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "title"}).SID_DATA
	                $Private:entry.uuid = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "uuid"}).SID_DATA
	                $Private:entry.notice = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "notice"}).SID_DATA
	                $Private:entry.source = $($Private:stig.STIG_INFO.SI_DATA | Where-Object {$_.SID_NAME -eq "source"}).SID_DATA
	                $Private:entry.Vuln_Num = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Vuln_Num"}).ATTRIBUTE_DATA
	                $Private:entry.Severity = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Severity"}).ATTRIBUTE_DATA
	                $Private:entry.Group_Title = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Group_Title"}).ATTRIBUTE_DATA
	                $Private:entry.Rule_ID = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Rule_ID"}).ATTRIBUTE_DATA
	                $Private:entry.Rule_Ver = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Rule_Ver"}).ATTRIBUTE_DATA
	                $Private:entry.Rule_Title = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Rule_Title"}).ATTRIBUTE_DATA
	                $Private:entry.Vuln_Discuss = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Vuln_Discuss"}).ATTRIBUTE_DATA
	                $Private:entry.IA_Controls = $($Private:vuln.STIG_DATA.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "IA_Controls"}).ATTRIBUTE_DATA
	                $Private:entry.Check_Content = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Check_Content"}).ATTRIBUTE_DATA
	                $Private:entry.Fix_Text = $($Private:vuln.STIG_DATA.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Fix_Text"}).ATTRIBUTE_DATA
	                $Private:entry.False_Positives = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "False_Positives"}).ATTRIBUTE_DATA
	                $Private:entry.False_Negatives = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "False_Negatives"}).ATTRIBUTE_DATA
	                $Private:entry.Documentable = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Documentable"}).ATTRIBUTE_DATA
	                $Private:entry.Mitigations = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Mitigations"}).ATTRIBUTE_DATA
	                $Private:entry.Potential_Impact = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Potential_Impact"}).ATTRIBUTE_DATA
	                $Private:entry.Third_Party_Tools = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Third_Party_Tools"}).ATTRIBUTE_DATA
	                $Private:entry.Mitigation_Control = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Mitigation_Control"}).ATTRIBUTE_DATA
	                $Private:entry.Responsibility = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Responsibility"}).ATTRIBUTE_DATA
	                $Private:entry.Security_Override_Guidance = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Security_Override_Guidance"}).ATTRIBUTE_DATA
	                $Private:entry.Check_Content_Ref = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Check_Content_Ref"}).ATTRIBUTE_DATA
	                $Private:entry.Class = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "Class"}).ATTRIBUTE_DATA
	                $Private:entry.STIGRef = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "STIGRef"}).ATTRIBUTE_DATA
	                $Private:entry.TargetKey = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "TargetKey"}).ATTRIBUTE_DATA
	                $Private:entry.CCI_REF = $($Private:vuln.STIG_DATA | Where-Object {$_.VULN_ATTRIBUTE -eq "CCI_REF"}).ATTRIBUTE_DATA
	                $Private:entry.Status = $Private:vuln.STATUS
	                $Private:entry.Finding_Details = $Private:vuln.Finding_Details
	                $Private:entry.Comments = $Private:vuln.COMMENTS
	                $Private:entry.Severity_Override = $Private:vuln.Severity_Override
	                $Private:entry.Severity_Justification = $Private:vuln.Severity_Justification
	                $Private:entry.StigViewer_Version = $Private:cklversion
	                $Private:results += $Private:entry
	
	            }
	        }
	
	        return $Private:results
	    }
	    else {
	        Throw "should not be here...this is weird"
	    }
	
	}
	
	
}
#endregion

#region Call-Compress-Report_ps1
function Call-Compress-Report_ps1
{
	function Compress-Report {
	<#
	.SYNOPSIS
	
	.PARAMETER report
	
	.PARAMETER Identifer
	
	.PARAMETER ckl
	
	.PARAMETER nessus
	
	.PARAMETER diacap
	
	.PARAMETER rmf
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.15.2016)
	    -Intial Release
	#>
	
	    [CmdletBinding()]
	    Param(
	        [Object]$report = $(Throw "No report Provided"),
	        [switch]$ckl,
	        [switch]$nessus,
	        [switch]$diacap,
	        [switch]$rmf
	    )
	    PROCESS{
	        if(!$ckl -and !$nessus -and !$diacap -and !$rmf){Throw "Report Type not selected"}
	        if ($ckl) {
	            Try{
	                $Private:results = @()
	                foreach($Private:reportObj in $report){
	                    $Private:reportObjHolding = $Private:results | Where-Object{$_.STIG_Title -eq $Private:reportObj.STIG_Title -and $_.Group_Title -eq $Private:reportObj.Group_Title -and $_.Vuln_Num -eq $Private:reportObj.Vuln_Num}
	                    # Check if the object has already been created
	                    if($Private:reportObjHolding){
	                        if(!($Private:reportObjHolding.AssetName.split(",") -contains $Private:reportObj.AssetName)){
	                            $Private:reportObjHolding.AssetName += ","+$Private:reportObj.AssetName
	                            $Private:reportObjHolding.vuln_count ++
	                            #$Private:reportObjHolding.AssetName = $($Private:reportObjHolding.AssetName -join ",")
	                            if(!($Private:reportObjHolding.Finding_Details)){
	                                $Private:reportObjHolding.Finding_Details = $Private:reportObj.Finding_Details
	                            }
	                        }
	                    } # IF Obj
	                    else{
	                        $Private:entry = ($Private:entry = " " | select-object STIG_Title, AssetName, Vuln_Num, Severity, Group_Title, Rule_ID, Rule_Ver, Rule_Title, Vuln_Discuss, IA_Controls, Check_Content, Fix_Text, False_Positives, False_Negatives, Documentable, Mitigations, Potential_Impact, Third_Party_Tools, Mitigation_Control, Responsibility, Security_Override_Guidance, Check_Content_Ref, Class, STIGRef, TargetKey, Status, Finding_Details, Comments, Severity_Override, Severity_Justification, vuln_count)
	                        $Private:entry.STIG_Title = $($Private:reportObj.STIG_Title).trim()
	                        $Private:entry.AssetName = $($Private:reportObj.AssetName).trim()
	                        $Private:entry.Vuln_Num = $($Private:reportObj.Vuln_Num).trim()
	                        $Private:entry.Severity = $($Private:reportObj.Severity).trim()
	                        $Private:entry.Group_Title = $($Private:reportObj.Group_Title).trim()
	                        $Private:entry.Rule_ID = $($Private:reportObj.Rule_ID).trim()
	                        $Private:entry.Rule_Ver = $($Private:reportObj.Rule_Ver).trim()
	                        $Private:entry.Rule_Title = $($Private:reportObj.Rule_Title).trim()
	                        $Private:entry.Vuln_Discuss = $($Private:reportObj.Vuln_Discuss).trim()
	                        $Private:entry.IA_Controls = $($Private:reportObj.IA_Controls).trim()
	                        $Private:entry.Check_Content = $($Private:reportObj.Check_Content).trim()
	                        $Private:entry.Fix_Text = $($Private:reportObj.Fix_Text).trim()
	                        $Private:entry.False_Positives = $($Private:reportObj.False_Positives).trim()
	                        $Private:entry.False_Negatives = $($Private:reportObj.False_Negatives).trim()
	                        $Private:entry.Documentable = $($Private:reportObj.Documentable).trim()
	                        $Private:entry.Mitigations = $($Private:reportObj.Mitigations).trim()
	                        $Private:entry.Potential_Impact = $($Private:reportObj.Potential_Impact).trim()
	                        $Private:entry.Third_Party_Tools = $($Private:reportObj.Third_Party_Tools).trim()
	                        $Private:entry.Mitigation_Control = $($Private:reportObj.Mitigation_Control).trim()
	                        $Private:entry.Responsibility = $($Private:reportObj.Responsibility).trim()
	                        $Private:entry.Security_Override_Guidance = $($Private:reportObj.Security_Override_Guidance).trim()
	                        $Private:entry.Check_Content_Ref = $($Private:reportObj.Check_Content_Ref).trim()
	                        $Private:entry.Class = $($Private:reportObj.Class).trim()
	                        $Private:entry.STIGRef = $($Private:reportObj.STIGRef).trim()
	                        $Private:entry.TargetKey = $($Private:reportObj.TargetKey).trim()
	                        $Private:entry.Status = $($Private:reportObj.Status).trim()
	                        $Private:entry.Finding_Details = $($Private:reportObj.Finding_Details).trim()
	                        $Private:entry.Comments = $($Private:reportObj.Comments).trim()
	                        $Private:entry.Severity_Override = $($Private:reportObj.Severity_Override).trim()
	                        $Private:entry.Severity_Justification = $($Private:reportObj.Severity_Justification).trim()
	                        $Private:entry.vuln_count = 1
	                        $Private:results += $Private:entry
	                    }
	                }  # For Loop
	                return $Private:results
	            }
	            CATCH{
	                Throw "Error processing CKL"
	            }
	        } # CKL Report
	
	        if ($nessus) { # START NESSUS
	            TRY { # TRY
	                $Private:results = @()
	                foreach($Private:reportObj in $report){
	                    $Private:reportObjHolding = $Private:results | Where-Object{$_.pluginID -eq $Private:reportObj.pluginID -and $_.pluginName -eq $Private:reportObj.pluginName}
	                    if($Private:reportObj.'netbios-name'){
	                        $Private:AssignedHostname = $Private:reportObj.'netbios-name'
	                    } # if
	                    elseif($Private:reportObj.'host-fqdn'){
	                        $Private:AssignedHostname = $($Private:reportObj.'host-fqdn'.split(".")[0])
	                    } # Elseif
	                    else{
	                        $Private:AssignedHostname = $Private:reportObj.'host-ip'
	                    } # Else
	                    if($Private:reportObjHolding){
	                        if(!($Private:reportObjHolding.AssetName.split(",") -contains $Private:AssignedHostname)){
	                            $Private:reportObjHolding.AssetName += ","+$Private:AssignedHostname
	                            $Private:reportObjHolding.vuln_count ++
	                        }
	                    } # IF
	                    else{
	                        $Private:entry = ($Private:entry = " " | select-object AssetName, port, svc_name, protocol, severity, pluginID, pluginName, pluginFamily, description, fname, plugin_modification_date, plugin_name, plugin_publication_date, plugin_type, risk_factor, script_version, solution, synopsis, plugin_output, vuln_count)
	                        $Private:entry.AssetName = $($Private:AssignedHostname).trim()
	                        $Private:entry.Port = $($Private:reportObj.Port).trim()
	                        $Private:entry.svc_name = $($Private:reportObj.svc_name).trim()
	                        $Private:entry.protocol = $($Private:reportObj.protocol).trim()
	                        $Private:entry.severity = $($Private:reportObj.severity).trim()
	                        $Private:entry.pluginID = $($Private:reportObj.pluginID).trim()
	                        $Private:entry.pluginName = $($Private:reportObj.pluginName).trim()
	                        $Private:entry.pluginFamily = $($Private:reportObj.pluginFamily).trim()
	                        $Private:entry.description = $($Private:reportObj.description).trim()
	                        $Private:entry.fname = $($Private:reportObj.fname).trim()
	                        $Private:entry.plugin_modification_date = $($Private:reportObj.plugin_modification_date).trim()
	                        $Private:entry.plugin_name = $($Private:reportObj.plugin_name).trim()
	                        $Private:entry.plugin_publication_date = $($Private:reportObj.plugin_publication_date).trim()
	                        $Private:entry.plugin_type = $($Private:reportObj.plugin_type).trim()
	                        $Private:entry.risk_factor = $($Private:reportObj.risk_factor).trim()
	                        $Private:entry.script_version = $($Private:reportObj.script_version).trim()
	                        $Private:entry.solution = $($Private:reportObj.solution).trim()
	                        $Private:entry.synopsis = $(if($Private:reportObj.synopsis){$($Private:reportObj.synopsis).trim()})
	                        $Private:entry.plugin_output = $(if($Private:reportObj.plugin_output){$($Private:reportObj.plugin_output).trim()})
	                        $private:entry.vuln_count = 1
	                        $Private:results += $Private:entry
	                    } # else
	                } # foreach
	                return $Private:results
	            } # END TRY
	            CATCH { # CATCH
	                Throw "Error processing Nessus"
	            } # END CATCH
	        } # END IF NESSUS
	
	        if ($diacap) { # START DIACAP
	            TRY{ # TRY
	            } # END TRY
	            CATCH{ # CATCH
	            } # END CATCH
	        } # END IF DIACAP
	
	        if ($rmf) { # Start RMF
	            TRY { # TRY
	            } # END TRY
	            CATCH { # CATCH
	            } # END CATCH
	        } # END IF RMF
	
	    } # End Process block
	} # end function
	
}
#endregion

#region Call-Compress-ZIP_ps1
function Call-Compress-ZIP_ps1
{
	function Compress-ZIP {
	<#
	.SYNOPSIS
	This function takes a folder path and then a destination and will create zip archive
	
	.PARAMETER source
	This is the source folder
	
	.PARAMETER destination
	This is the destiniation for the zip
	
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.14.2016)
	    -Intial Release
	
	#>
	
	    Param(
	        [string]$source = $(Throw "No Source Provided"),
	        [string]$destination = $(Throw "No destination Provided")
	    )
	
	    if (Test-Path -Path $destination) {
	        Throw "$($destination) Already Exist"
	    }
	
	    Add-Type -AssemblyName "system.io.compression.filesystem"
	    [io.compression.zipfile]::CreateFromDirectory($source, $destination)
	}
	
}
#endregion

#region Call-ConvertTo-RiskElements_ps1
function Call-ConvertTo-RiskElements_ps1
{
	function ConvertTo-RiskElements {
	<#
	.SYNOPSIS
	
	.PARAMETER report
	
	.PARAMETER Identifer
	
	.PARAMETER ckl
	
	.PARAMETER nessus
	
	.PARAMETER diacap
	
	.PARAMETER rmf
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.15.2016)
	    -Intial Release
	#>
	
	    [CmdletBinding()]
	    Param(
	        [Object]$report = $(Throw "No report Provided"),
	        [switch]$ckl,
	        [switch]$nessus,
	        [switch]$diacap,
	        [switch]$rmf
	    )
	
	    PROCESS {
	        if(!$ckl -and !$nessus -and !$diacap -and !$rmf){Throw "Report Type not selected"}
	        if ($ckl) {
	                $Private:results = @()
	                foreach($Private:reportObj in $report){
	                $Private:entry = ($Private:entry = " " | select-object Name, Weaknesses, Cat, "IA Control", Count, "Assessed Risk Level", "Quantitative Values")
	                if($Private:reportObj.Vuln_Num){
	                    $Private:entry.name = "$($Private:reportObj.STIG_Title) - ID: $($Private:reportObj.Vuln_Num) - $($Private:reportObj.Rule_Title)"
	                }
	                else{
	                    $Private:entry.name = "$($Private:reportObj.STIG_Title) - $($Private:reportObj.Rule_Title)"
	                }
	                if($Private:reportObj.Vuln_Discuss){
	                    $Private:entry.Weaknesses = "Description:" + "`r`n" + $($Private:reportObj.Vuln_Discuss) + "`r`n" + "Affected System:" + "`r`n" + $($Private:reportObj.AssetName -split "," -join "`r`n")
	                }
	                else{
	                    Throw $ERRORCREATEPOAM = "No Vuln Description for $($Private:reportObj.Vuln_Num) STIG $($Private:reportObj.STIG_Title)"
	                }
	                if($Private:reportObj.Severity){
	                    if($Private:reportObj.Severity -eq 'low'){
	                        $Private:entry.Cat = "III"
	                    }
	                    elseif($Private:reportObj.Severity -eq 'medium'){
	                        $Private:entry.Cat = "II"
	                    }
	                    elseif($Private:reportObj.Severity -eq 'high'){
	                        $Private:entry.Cat = "I"
	                    }
	                    else{
	                        Throw $ERRORCREATEPOAM = "No Severity Assigned to $($Private:reportObj.Vuln_Num) STIG $($Private:reportObj.STIG_Title)"
	                    }
	                }
	                else{
	                    Throw $ERRORCREATEPOAM = "No Severity Assigned to $($Private:reportObj.Vuln_Num) STIG $($Private:reportObj.STIG_Title)"
	                }
	                $Private:entry.'IA Control' = $Private:reportObj.IA_Controls
	                $Private:entry.Count = $Private:reportObj.vuln_count
	                $Private:entry.'Assessed Risk Level' = $null
	                $Private:entry.'Quantitative Values' = $null
	                $Private:results += $Private:entry
	            }
	            return $Private:results
	        }
	        if ($nessus) {
	            $Private:results = @()
	            foreach($Private:reportObj in $report){
	                $Private:entry = ($Private:entry = " " | select-object Name, Weaknesses, Cat, "IA Control", Count, "Assessed Risk Level", "Quantitative Values")
	                $Private:entry.Name = "ACAS - Plugin ID: $($Private:reportObj.pluginID) - $($Private:reportObj.pluginName)"
	                $Private:entry.Weaknesses = "Description:" + "`r`n" + $($Private:reportObj.description) + "`r`n" + "Affected System:" + "`r`n" + $($Private:reportObj.AssetName -split "," -join "`r`n")
	                if($Private:reportObj.Severity){
	                    if($Private:reportObj.risk_factor -eq 'low'){
	                        $Private:entry.Cat = "III"
	                    } # if
	                    elseif($Private:reportObj.risk_factor -eq 'medium'){
	                        $Private:entry.Cat = "II"
	                    } # elseif
	                    elseif($Private:reportObj.risk_factor -eq 'high'){
	                        $Private:entry.Cat = "I"
	                    } # elseif
	                    elseif($Private:reportObj.risk_factor -eq 'Critical'){
	                        $Private:entry.Cat = "I"
	                    } # Elseif
	                    else{
	                        Throw $ERRORCREATEPOAM = "No Severity Assigned to $($Private:reportObj.pluginID) Name $($Private:reportObj.pluginName)"
	                    } # Else
	                } # if
	                else{
	                    Throw $ERRORCREATEPOAM = "No Severity Assigned to $($Private:reportObj.pluginID) Name $($Private:reportObj.pluginName)"
	                } # else
	                $Private:entry.'IA Control' = $null
	                $Private:entry.Count = $Private:reportObj.vuln_count
	                $Private:entry.'Assessed Risk Level' = $null
	                $Private:entry.'Quantitative Values' = $null
	                $Private:results += $Private:entry
	            }
	        }
	        if ($diacap) {
	            $Private:results = @()
	            foreach($Private:reportObj in $report){
	                $Private:entry = ($Private:entry = " " | select-object Name, Weaknesses, Cat, "IA Control", Count, "Assessed Risk Level", "Quantitative Values")
	                $Private:entry.Name = "8500.2 - ID: $($Private:reportObj.AssessmentObjectiveID) - $($Private:reportObj.'Control Name')"
	                $Private:entry.Weaknesses = "Description:" + "`r`n" + $($Private:reportObj.'Assessment Objectives') + "`r`n" + "Affected System:" + "`r`n" + "Site"
	                if($Private:reportObj.'Impact Code' -eq 'low'){
	                    $Private:entry.Cat = "III"
	                } # if
	                elseif($Private:reportObj.'Impact Code' -eq 'medium'){
	                    $Private:entry.Cat = "II"
	                } # elseif
	                elseif($Private:reportObj.'Impact Code' -eq 'high'){
	                    $Private:entry.Cat = "I"
	                } # elseif
	                else{
	                    Throw $ERRORCREATEPOAM = "No Severity Assigned to $($Private:reportObj.pluginID) Name $($Private:reportObj.pluginName)"
	                } # Else
	                $Private:entry.'IA Control' = $Private:reportObj.'Control Number'
	                $Private:entry.Count = 1
	                $Private:entry.'Assessed Risk Level' = $null
	                $Private:entry.'Quantitative Values' = $null
	                $Private:results += $Private:entry
	            }
	        }
	        if ($rmf) { # Place Holder
	        }
	        return $Private:results
	    }
	}
	
}
#endregion

#region Call-Expand-ZIP_ps1
function Call-Expand-ZIP_ps1
{
	function Expand-ZIP {
	<#
	.SYNOPSIS
	This function takes a zip archive and extracts to a folder
	
	.PARAMETER source
	This is the Zip Archive
	
	.PARAMETER destination
	This is the destiniation
	
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.14.2016)
	    -Intial Release
	
	#>
	
	
	    Param(
	        [string]$source = $(Throw "No Source Provided"),
	        [string]$destination = $(Throw "No destination Provided")
	    )
	
	    if (Test-Path -Path $destination) {
	        Throw "$($destination) Already Exist"
	    }
	
	    Add-Type -AssemblyName "system.io.compression.filesystem"
	    [io.compression.zipfile]::ExtractToDirectory($source, $destination)
	
	}
	
}
#endregion

#region Call-Get-Average_ps1
function Call-Get-Average_ps1
{
	Function Get-Average($array)
	{
	    $RunningTotal = 0;
	    foreach($i in $array){
	        $RunningTotal += $i
	    }
	    return ([decimal]($RunningTotal) / [decimal]($array.Length));
	}
	
}
#endregion

#region Call-Get-OutPutDir_ps1
function Call-Get-OutPutDir_ps1
{
	function Get-OutPutDir {
	<#
	.SYNOPSIS
	This function looks to see if the path provided exsists. if not it will be created
	
	.PARAMETER Path
	Path to look for
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (01.05.2016)
	    -Intial Release
	
	#>
	
	    [CmdletBinding()]
	    Param(
	        [ValidateNotNull()]
	        [string]$Path = $(Throw "No Path Provided")
	    )
	    if (& $SafeCommands['Test-Path'] $Path) {
	        return 'Path Exsists'
	    }
	    else {
	        Try{
	            $ErrorActionPreference = 'Stop'
	            & $SafeCommands['New-Item'] -ItemType directory -Path $Path | Out-Null
	            return 'Created Path'
	        }
	        Catch {
	            Throw "unable to create at provided path: $($Path)"
	        }
	    }
	
	}
	
}
#endregion

#region Call-Get-Timediff_ps1
function Call-Get-Timediff_ps1
{
	function Get-Timediff {
	<#
	.SYNOPSIS
	This function looks in the provided directory(s) and returns all files that end in .nessus
	
	.PARAMETER Path
	The location of the nessus file(s)
	
	.PARAMETER recurse
	This is a switch and tells the function if it should traverse the path that it was given looking for all
	nessus files
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (01.05.2016)
	    -Intial Release
	
	#>
	
	    [CmdletBinding()]
	    Param(
	        [ValidateNotNull()]
	        [DateTime]$start= $(Throw "No Start Time Provided"),
	
	        [ValidateNotNull()]
	        [DateTime]$end = $(Throw "No End Time Provided")
	    )
	
	    $Private:diff = & $SafeCommands['New-TimeSpan'] -Start $start -End $end
	    return "$($Private:diff.hours):$($Private:diff.minutes):$($Private:diff.seconds)"
	}
	
}
#endregion

#region Call-Import-XML_ps1
function Call-Import-XML_ps1
{
	function Import-XML {
	<#
	.SYNOPSIS
	This function loads an XML into an XML object. Can take a string path, a string xml, or a file object
	
	.PARAMETER Path
	Path to the XML file
	
	.PARAMETER string
	A string Variable version of the XML
	
	.PARAMETER fileobj
	A file object Variable version of the XML
	
	
	.EXAMPLE
	
	.LINK
	
	.VERSION
	1.0.0 (02.9.2016)
	    -Intial Release
	
	#>
	
	    [CmdletBinding()]
	    Param(
	        [string]$Path = $null,
	        [string]$string = $null,
	        [object]$fileobj = $null
	    )
	
	    $Private:doc = New-Object System.Xml.XmlDataDocument # This creates a xlm document object
	
	    if($Path){ # Test Path variable
	        Try {
	            $ErrorActionPreference = 'Stop'
	            $Private:doc.Load($Path)
	            $ErrorActionPreference = 'Continue'
	            return $Private:doc
	        }
	        Catch {
	            $ErrorActionPreference = 'Continue'
	            Throw "$($Path) Not an XML Document"
	        }
	    }
	
	    if($string){ # test string variable
	        Try {
	            $ErrorActionPreference = 'Stop'
	            $Private:doc.LoadXML($string)
	            $ErrorActionPreference = 'Continue'
	            return $Private:doc
	        }
	        Catch {
	            $ErrorActionPreference = 'Continue'
	            Throw "Not an XML Document"
	        }
	    }
	
	    if($fileobj){ # test string variable
	        Try {
	            $ErrorActionPreference = 'Stop'
	            $Private:doc.Load($fileobj.fullname)
	            $ErrorActionPreference = 'Continue'
	            return $Private:doc
	        }
	        Catch {
	            $ErrorActionPreference = 'Continue'
	            Throw "$($fileobj.name) Not an XML Document"
	        }
	    }
	    Throw "no path, string, or fileobj provided"
	}
	
}
#endregion

	# look into a plugin system for use with automating STIGS
	
	if ($PSVersionTable.PSVersion.Major -ge 3) {
	    $script:IgnoreErrorPreference = 'Ignore'
	    $outNullModule = 'Microsoft.PowerShell.Core'
	}
	else {
	    $script:IgnoreErrorPreference = 'SilentlyContinue'
	    $outNullModule = 'Microsoft.PowerShell.Utility'
	}
	
	
	# Tried using $ExecutionState.InvokeCommand.GetCmdlet() here, but it does not trigger module auto-loading the way
	# Get-Command does.  Since this is at import time, before any mocks have been defined, that's probably acceptable.
	# If someone monkeys with Get-Command before they import Pester, they may break something.
	
	$script:SafeCommands = @{
	    'Add-Member'          = Get-Command -Name Add-Member          -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Add-Type'            = Get-Command -Name Add-Type            -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Compare-Object'      = Get-Command -Name Compare-Object      -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Export-ModuleMember' = Get-Command -Name Export-ModuleMember -Module Microsoft.PowerShell.Core       -CommandType Cmdlet -ErrorAction Stop
	    'ForEach-Object'      = Get-Command -Name ForEach-Object      -Module Microsoft.PowerShell.Core       -CommandType Cmdlet -ErrorAction Stop
	    'Format-Table'        = Get-Command -Name Format-Table        -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Get-ChildItem'       = Get-Command -Name Get-ChildItem       -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Get-Command'         = Get-Command -Name Get-Command         -Module Microsoft.PowerShell.Core       -CommandType Cmdlet -ErrorAction Stop
	    'Get-Content'         = Get-Command -Name Get-Content         -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Get-Date'            = Get-Command -Name Get-Date            -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Get-Item'            = Get-Command -Name Get-Item            -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Get-Location'        = Get-Command -Name Get-Location        -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Get-Member'          = Get-Command -Name Get-Member          -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Get-Module'          = Get-Command -Name Get-Module          -Module Microsoft.PowerShell.Core       -CommandType Cmdlet -ErrorAction Stop
	    'Get-PSDrive'         = Get-Command -Name Get-PSDrive         -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Get-Variable'        = Get-Command -Name Get-Variable        -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Get-WmiObject'       = Get-Command -Name Get-WmiObject       -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Group-Object'        = Get-Command -Name Group-Object        -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Join-Path'           = Get-Command -Name Join-Path           -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Measure-Object'      = Get-Command -Name Measure-Object      -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'New-Item'            = Get-Command -Name New-Item            -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'New-Module'          = Get-Command -Name New-Module          -Module Microsoft.PowerShell.Core       -CommandType Cmdlet -ErrorAction Stop
	    'New-Object'          = Get-Command -Name New-Object          -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'New-PSDrive'         = Get-Command -Name New-PSDrive         -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'New-Variable'        = Get-Command -Name New-Variable        -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Out-Null'            = Get-Command -Name Out-Null            -Module $outNullModule                  -CommandType Cmdlet -ErrorAction Stop
	    'Out-String'          = Get-Command -Name Out-String          -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Pop-Location'        = Get-Command -Name Pop-Location        -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Push-Location'       = Get-Command -Name Push-Location       -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Remove-Item'         = Get-Command -Name Remove-Item         -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Remove-PSBreakpoint' = Get-Command -Name Remove-PSBreakpoint -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Remove-PSDrive'      = Get-Command -Name Remove-PSDrive      -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Remove-Variable'     = Get-Command -Name Remove-Variable     -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Resolve-Path'        = Get-Command -Name Resolve-Path        -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Select-Object'       = Get-Command -Name Select-Object       -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Set-Content'         = Get-Command -Name Set-Content         -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Set-PSBreakpoint'    = Get-Command -Name Set-PSBreakpoint    -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Set-StrictMode'      = Get-Command -Name Set-StrictMode      -Module Microsoft.PowerShell.Core       -CommandType Cmdlet -ErrorAction Stop
	    'Set-Variable'        = Get-Command -Name Set-Variable        -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Sort-Object'         = Get-Command -Name Sort-Object         -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Split-Path'          = Get-Command -Name Split-Path          -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Start-Sleep'         = Get-Command -Name Start-Sleep         -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Test-Path'           = Get-Command -Name Test-Path           -Module Microsoft.PowerShell.Management -CommandType Cmdlet -ErrorAction Stop
	    'Where-Object'        = Get-Command -Name Where-Object        -Module Microsoft.PowerShell.Core       -CommandType Cmdlet -ErrorAction Stop
	    'Write-Error'         = Get-Command -Name Write-Error         -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Write-Progress'      = Get-Command -Name Write-Progress      -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Write-Verbose'       = Get-Command -Name Write-Verbose       -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'Write-Warning'       = Get-Command -Name Write-Warning       -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	    'New-TimeSpan'        = Get-Command -Name New-TimeSpan        -Module Microsoft.PowerShell.Utility    -CommandType Cmdlet -ErrorAction Stop
	}
	
	# little sanity check to make sure we don't blow up a system with a typo up there
	# (not that I've EVER done that by, for example, mapping New-Item to Remove-Item...)
	
	foreach ($keyValuePair in $script:SafeCommands.GetEnumerator()) {
	    if ($keyValuePair.Key -ne $keyValuePair.Value.Name) {
	        throw "SafeCommands entry for $($keyValuePair.Key) does not hold a reference to the proper command."
	    }
	}
	
	#Import assembly excel:
	    $BinaryPath = Join-Path $PSScriptRoot 'lib\excel\epplus.dll'
	    if( -not ($Library = & $script:SafeCommands['Add-Type'] -path $BinaryPath -PassThru -ErrorAction stop) )
	    {
	        Throw "Failed to load EPPlus binary from $BinaryPath"
	    }
	
	#Pick and import assemblies sqlite:
	    if([IntPtr]::size -eq 8) #64
	    {
	        $SQLiteAssembly = Join-path $PSScriptRoot "lib\sqlite\x64\System.Data.SQLite.dll"
	    }
	    elseif([IntPtr]::size -eq 4) #32
	    {
	        $SQLiteAssembly = Join-path $PSScriptRoot "lib\sqlite\x86\System.Data.SQLite.dll"
	    }
	    else
	    {
	        Throw "Something is odd with bitness..."
	    }
	
	    if( -not ($Library = Add-Type -path $SQLiteAssembly -PassThru -ErrorAction stop) )
	    {
	        Throw "This module requires the ADO.NET driver for SQLite:`n`thttp://system.data.sqlite.org/index.html/doc/trunk/www/downloads.wiki"
	    }
	
	
	# Import private and public functions
	$moduleRoot = & $script:SafeCommands['Split-Path'] -Path $MyInvocation.MyCommand.Path
	$here = Split-Path -Parent $MyInvocation.MyCommand.Path
	$("$($here)\functions" |
	 Get-ChildItem -Recurse -Filter "*.ps1").fullName | 
	 Where-Object { -not ($_.ToLower().Contains(".tests.")) } | 
	 ForEach-Object {. $_ }
	